<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Repeated Substring Pattern - Solution</title>
</head>
<body>
<h2 id="solution">Repeated Substring Pattern - Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>Given a string <code>s</code>, our task is to check whether it can be constructed by taking a substring of it and
    appending multiple copies of the substring together.</p>
<hr>
<h3 id="approach-1-using-divisors">Approach 1: Using Divisors</h3>
<h4 id="intuition">Intuition</h4>
<p>We may realize that it is impossible to construct <code>s</code> by repeating substrings whose length is not a
    divisor of the length of <code>s</code>.</p>
<p>We only need to look at substrings where the length divides <code>n</code>, where <code>n</code> is the length of
    <code>s</code>. Another thing that we can notice is that the substring would need to be a prefix of <code>s</code>,
    otherwise there would be an immediate mismatch.</p>
<p>For each prefix of length <code>i</code> that divides <code>n</code>, we would concatenate the prefix <code>n /
    i</code> times to generate another string. If this string generated by repeated substrings equals <code>s</code>, we
    return <code>true</code>.</p>
<p>If no prefix is found that when repeated equals <code>s</code>, we return <code>false</code>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> equal to the length of <code>s</code>.</li>
    <li>Iterate over all the prefix substrings of length <code>i = 1</code> to <code>n / 2</code>:
        <ul>
            <li>If <code>i</code> divides <code>n</code>, we declare an empty string <code>pattern</code>. Use an inner
                loop that iterates <code>n / i</code> times to concatenate the substring formed from the first
                <code>i</code> characters of <code>s</code>.
            </li>
            <li>If <code>pattern</code> equals <code>s</code>, we return <code>true</code>.</li>
        </ul>
    </li>
    <li>There is no substring that can be repeated to form <code>s</code>. As a result, we return <code>false</code>.
    </li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public boolean repeatedSubstringPattern(String s) {
        int n = s.length();
        for (int i = 1; i <= n / 2; i++) {
            if (n % i == 0) {
                StringBuilder pattern = new StringBuilder();
                for (int j = 0; j < n / i; j++) {
                    pattern.append(s.substring(0, i));
                }
                if (s.equals(pattern.toString())) {
                    return true;
                }
            }
        }
        return false;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        int n = s.length();
        for (int i = 1; i <= n / 2; i++) {
            if (n % i == 0) {
                string pattern = "";
                for (int j = 0; j < n / i; j++) {
                    pattern += s.substr(0, i);
                }
                if (s == pattern) {
                    return true;
                }
            }
        }
        return false;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        n = len(s)
        for i in range(1, n // 2 + 1):
            if n % i == 0:
                pattern = s[:i] * (n // i)
                if s == pattern:
                    return True
        return False
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the length of <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅n)O(n \cdot \sqrt{n})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1.0503em; vertical-align: -0.25em;"></span><span
                class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
                                                                                             style="height: 0.8003em;"><span
                class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"
                                                                                                            style="padding-left: 0.833em;"><span
                class="mord mathnormal">n</span></span></span><span style="top: -2.7603em;"><span class="pstrut"
                                                                                                  style="height: 3em;"></span><span
                class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em"
                                                                                   viewBox="0 0 400000 1080"
                                                                                   preserveAspectRatio="xMinYMin slice"><path
                d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span
                class="vlist-r"><span class="vlist"
                                      style="height: 0.2397em;"><span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>A number <code>n</code> can have a maximum of <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">2⋅n2 \cdot \sqrt{n}</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">2</span><span
                    class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span
                    class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut"
                                                                                                          style="height: 1.04em; vertical-align: -0.2397em;"></span><span
                    class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
                                                                                                 style="height: 0.8003em;"><span
                    class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span
                    class="mord" style="padding-left: 0.833em;"><span
                    class="mord mathnormal">n</span></span></span><span style="top: -2.7603em;"><span class="pstrut"
                                                                                                      style="height: 3em;"></span><span
                    class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em"
                                                                                       viewBox="0 0 400000 1080"
                                                                                       preserveAspectRatio="xMinYMin slice"><path
                    d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span
                    class="vlist-r"><span class="vlist"
                                          style="height: 0.2397em;"><span></span></span></span></span></span></span></span></span></span>
                number of divisors. As a result, we would execute the inner loop that concatenates the substring <span
                        class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(\sqrt{n})</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0503em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span
                        class="vlist-r"><span class="vlist" style="height: 0.8003em;"><span class="svg-align"
                                                                                            style="top: -3em;"><span
                        class="pstrut" style="height: 3em;"></span><span class="mord"
                                                                         style="padding-left: 0.833em;"><span
                        class="mord mathnormal">n</span></span></span><span style="top: -2.7603em;"><span class="pstrut"
                                                                                                          style="height: 3em;"></span><span
                        class="hide-tail" style="min-width: 0.853em; height: 1.08em;"><svg width="400em" height="1.08em"
                                                                                           viewBox="0 0 400000 1080"
                                                                                           preserveAspectRatio="xMinYMin slice"><path
                        d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span
                        class="vlist-r"><span class="vlist" style="height: 0.2397em;"><span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> times. In the inner loop, we concatenate a
                substring of length <code>i</code> for <code>n / i</code> times to generate a string of length
                <code>n</code>, which would require <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                time for each iteration. As a result, it would take <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n⋅n)O(n \cdot \sqrt{n})</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace"
                                                                                          style="margin-right: 0.2222em;"></span><span
                        class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                        class="base"><span class="strut" style="height: 1.0503em; vertical-align: -0.25em;"></span><span
                        class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist"
                                                                                                     style="height: 0.8003em;"><span
                        class="svg-align" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span
                        class="mord" style="padding-left: 0.833em;"><span class="mord mathnormal">n</span></span></span><span
                        style="top: -2.7603em;"><span class="pstrut" style="height: 3em;"></span><span class="hide-tail"
                                                                                                       style="min-width: 0.853em; height: 1.08em;"><svg
                        width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path
                        d="M95,702
c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14
c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54
c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10
s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429
c69,-144,104.5,-217.7,106.5,-221
l0 -0
c5.3,-9.3,12,-14,20,-14
H400000v40H845.2724
s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7
c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z
M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span
                        class="vlist-r"><span class="vlist" style="height: 0.2397em;"><span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> in total.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>We used another string variable, <code>pattern</code>, which is initialized to an empty string before
                the inner loop iteration and grows up to a length of <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                after the inner loop iteration.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-2-string-concatenation">Approach 2: String Concatenation</h3>
<blockquote>
    <p>Note: This is a very advanced approach and might not be expected in an interview.</p>
</blockquote>
<h4 id="intuition-1">Intuition</h4>
<p>Consider a string <code>S = "helloworld"</code>. Now, given another string <code>T = "lloworldhe"</code>, can we
    figure out if <code>T</code> is a rotated version of <code>S</code>? By rotated version, we mean taking
    <code>S</code> and shifting it any number of spaces (with wrap around). For example, if <code>S = "abc"</code> and
    we shifted it to the left once, we would have <code>"bca"</code>.</p>
<p>Yes, we check if <code>T</code> is a rotated version of <code>S</code> by checking if it is a substring of <code>S +
    S</code>. This is because <code>S + S</code> contains all of the rotations of <code>S</code>.</p>
<p>Let's try to use this fact to solve our problem.</p>
<p>We consider every rotation of string <code>S</code> such that it's rotated by <code>k</code> units (where <code>k
    &lt; s.length</code>) to the left. Specifically, we're looking at strings <code>elloworldh"</code>,
    <code>lloworldhe</code>, <code>loworldhel</code>, etc.</p>
<p>If a string can be constructed by taking a substring of it and appending multiple copies of the substring together,
    <strong>it must be a rotation of itself</strong>. However, it would be inefficient to check all rotations.</p>
<p>Let <code>t = s + s</code>. We can easily and efficiently check all possible rotations by removing the first and last
    character of <code>t</code>, then checking if <code>s</code> is a substring of <code>t</code>.</p>
<p>We can prove that the solution works mathematically.</p>
<p>Let's assume <code>s = p * k</code> where <code>p</code> is a pattern that has been repeated <code>k</code> times. If
    there is no repeating pattern in <code>s</code>, <code>k</code> would be <code>1</code> and <code>p = s</code>. If
    there is a repeating pattern, then <code>k &gt; 1</code>.</p>
<p>If we concatenate <code>s</code> twice, i.e., form another string <code>t</code> where <code>t = s + s</code> and
    remove the first and last character from it, <code>t</code> would look like <code>t = (head + p * (k - 1)) + (p * (k
        - 1) + tail)</code> where <code>head</code> is <code>p</code> without first character, <code>tail</code> is
    <code>p</code> without last character and <code>p * (k - 1)</code> denotes <code>p</code> repeated <code>k -
        1</code> times.</p>
<p>As a result, <code>t = head + p * (2k - 2) + tail</code>. We now have 2 possibilities: either <code>k = 1</code> and
    the answer is false, or <code>k &gt; 1</code> and the answer is true.</p>
<p>If <code>k = 1</code>, then <code>2k - 2 = 0</code> and <code>t = head + tail</code>. Remember, <code>head</code> is
    equal to <code>p</code> with the first character removed, and <code>tail</code> is equal to <code>p</code> with the
    last character removed. We can simplify this as <code>t</code> is equal to <code>p + p</code> with the first and
    last characters removed. Now, <code>s</code> cannot possibly be a substring of <code>t</code> because <code>s =
        p</code> and we removed the first and last character.</p>
<ul>
    <li>Thus, if <code>k = 1</code>, then <code>s</code> cannot be a substring of <code>t</code> and the answer is
        false. Here's a visual representation where <code>k = 1</code>:
    </li>
</ul>
<p><img src="459-1.png" alt="img"></p>
<ul>
    <li>If <code>k &gt; 1</code>, then <code>2k - 2</code> is some nonzero integer <code>x</code>. This means <code>t =
        head + p * x + tail</code>.
    </li>
    <li>Remember: by definition, <code>s = p * k</code>. This means that as long as <code>x &gt;= k</code>,
        <code>s</code> must be contained within <code>p * x</code>, and thus within <code>t</code>.
    </li>
    <li>We have <code>x = 2k - 2</code>, so the inequality becomes <code>2k - 2 &gt;= k</code>. We can rearrange this to
        <code>k &gt;= 2</code>, which is the same thing as <code>k &gt; 1</code>.
    </li>
    <li>In conclusion, if <code>k &gt; 1</code>, it implies two things: first, the answer to the problem is true.
        Second, <code>x &gt;= k</code> and thus <code>s</code> must be a substring of <code>p * x</code>, and thus a
        substring of <code>t</code>. Here's a visual representation where <code>k &gt; 1</code>:
    </li>
</ul>
<p><img src="459-2.png" alt="img"></p>
<p>So, concatenate <code>s</code> twice and then remove the first and last characters from it. The answer to the problem
    is the answer to "does this new string contain <code>s</code> as a substring"?</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>Create a string variable <code>t</code> and set it to <code>s + s</code>.</li>
    <li>If the substring formed by removing the first and last character of <code>t</code> contains <code>s</code>, we
        return <code>true</code>. Otherwise, return <code>false</code>. Note in our implementation, the
        <code>substr</code> function in <code>C++</code> and the <code>substring</code> method in <code>Java</code> both
        take two parameters. In both languages, the first parameter is the initial index from which our substring
        begins, while the second parameter works differently. It is the length of the substring in <code>C++</code> and
        the index of the last character in <code>Java</code>.
    </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        String t = s + s;
        if (t.substring(1, t.length() - 1).contains(s))
            return true;
        return false;
    </code>
    C++
    <code>
        class Solution {
public:
    bool repeatedSubstringPattern(string s) {
        string t = s + s;
        if (t.substr(1, t.size() - 2).find(s) != -1) return true;
        return false;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def repeatedSubstringPattern(self, s: str) -> bool:
        t = s + s
        if s in t[1:-1]:
            return True
        return False
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the length of <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>It takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time to
                form string <code>t</code> followed by its substring by eliminating the first and final character.
            </li>
            <li>Due to implementation differences of the underlying methods, finding <code>s</code> in <code>t</code>
                takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> in <code>Java</code> and
                <code>Python3</code> but <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                in <code>C++</code>. However, one can use algorithms like KMP to solve it in linear time.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>We used a string variable <code>t</code> that takes <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>