<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Number of Provinces - Solution</title>
</head>
<body>
<h2 id="solution">Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>We are given <code>n</code> cities, some of which are connected to other cities given by an <code>n x n</code> matrix
    <code>isConnected</code>. The connectivity is transitive, which means that if city <code>a</code> is directly
    connected with city <code>b</code> and city <code>b</code> is directly connected with city <code>c</code>, then city
    <code>a</code> is indirectly connected with city <code>c</code>.</p>
<p>A province is defined as a group of directly or indirectly connected cities with no other cities outside of the
    group.</p>
<p>Our task is to return the total number of provinces.</p>
<hr>
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that two cities <code>x</code> and <code>y</code> belong to the same province if there is a
    <strong>path</strong> from city <code>x</code> to city <code>y</code> using the cities that are directly connected.
</p>
<p>This leads us to consider the problem in terms of graphs.</p>
<p>Each city can be thought of as a node in a graph. The roads that directly connect the cities are the edges. If there
    is a path in this graph connecting cities <code>x</code> and <code>y</code>, then <code>x</code> and <code>y</code>
    are in the same province. Because the graph is undirected, <code>x</code> and <code>y</code> belong to the same
    province if and only if they are part of the same graph component.</p>
<p><strong>The number of required provinces is the number of connected components formed in such a graph.</strong></p>
<p>To check the number of connected components in a graph, we can use a graph traversal algorithm like depth first
    search (DFS).</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a
    branch, we backtrack to the next branch and continue exploring.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this
    branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p><img src="547-dfs.png" alt="img"></p>
<p>If you are new to Depth First Search, please see our <a
        href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/" target="_blank">LeetCode
    Explore Card</a> for more information on it!</p>
<p>To figure out how many connected components there are in the graph, we first mark all nodes as unvisited.</p>
<p>We iterate through all the nodes from <code>0</code> to <code>n - 1</code>, checking whether each <code>node</code>
    has been visited or not. As the graph is undirected, a DFS traversal from <code>node</code> would visit all of the
    nodes in the component to which <code>node</code> belongs. Whenever we see an unvisited node while looping through
    all the nodes, it means we have found a new component. We run the DFS traversal from the unvisited node to traverse
    over all the nodes in the new component, marking all these nodes as visited to avoid counting a component more than
    once.</p>
<p>The number of connected components in the graph is equal to the number of unvisited nodes we encounter (the number of
    times we start a DFS traversal) in this process.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> which stores the number of cities.</li>
    <li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
    <li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph.
        Initialize it to <code>0</code>.
    </li>
    <li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node
        <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a DFS
        traversal:
        <ul>
            <li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>node</code>,
                <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.
            </li>
            <li>We mark <code>node</code> as visited.</li>
            <li>We iterate over all the values in <code>isConnected[node]</code> to get the neighbors of
                <code>node</code>. If <code>isConnected[node][i] == 1</code>, one neighbor of <code>node</code> is
                <code>i</code> (as we have a direct edge between <code>node</code> and <code>i</code>). For each
                neighbor <code>i</code> that has not yet been visited, we recursively call <code>dfs</code> with
                <code>i</code> as the node.
            </li>
        </ul>
    </li>
    <li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public void dfs(int node, int[][] isConnected, boolean[] visit) {
        visit[node] = true;
        for (int i = 0; i < isConnected.length; i++) {
            if (isConnected[node][i] == 1 && !visit[i]) {
                dfs(i, isConnected, visit);
            }
        }
    }

    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        int numberOfComponents = 0;
        boolean[] visit = new boolean[n];

        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                numberOfComponents++;
                dfs(i, isConnected, visit);
            }
        }

        return numberOfComponents;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    void dfs(int node, vector<vector<int>>& isConnected, vector<bool>& visit) {
        visit[node] = true;
        for (int i = 0; i < isConnected.size(); i++) {
            if (isConnected[node][i] && !visit[i]) {
                dfs(i, isConnected, visit);
            }
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        int numberOfComponents = 0;
        vector<bool> visit(n);

        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                numberOfComponents++;
                dfs(i, isConnected, visit);
            }
        }

        return numberOfComponents;
    }
};
    </code>

</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the number of cities.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>Initializing the <code>visit</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
            <li>The <code>dfs</code> function visits each node once, which takes <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time
                because there are <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                nodes in total. From each <code>node</code>, we iterate over all possible edges using <code>isConnected[node]</code>
                which takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                time for each visited node. As a result, it takes a total of <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html"
                                                                                         aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> time to visit all the nodes and iterate over
                its edges.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>The <code>visit</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.
            </li>
            <li>The recursion call stack used by <code>dfs</code> can have no more than <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.4306em;"></span><span
                    class="mord mathnormal">n</span></span></span></span></span> elements in the worst-case scenario. It
                would take up <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space in that case.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we just have to find the number of connected components in the graph, another method is to use a breadth-first
    search (BFS).</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at
    the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l +
        1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<p>Here is an example with the steps:</p>
<p><img src="547-bfs.png" alt="img"></p>
<p>If you are not familiar with BFS traversal, we suggest you read our <a
        href="https://leetcode.com/explore/featured/card/graph/620/breadth-first-search-in-graph/" target="_blank">LeetCode
    Explore Card</a>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> which stores the number of cities.</li>
    <li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
    <li>Create an integer <code>numberOfComponents</code> which stores the number of connected components in the graph.
        Initialize it to <code>0</code>.
    </li>
    <li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node
        <code>i</code> is not visited, we increment <code>numberOfComponents</code> by <code>1</code> and start a BFS
        traversal:
        <ul>
            <li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>node</code>,
                <code>isConnected</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.
            </li>
            <li>We create an integer queue <code>q</code> and push <code>node</code> into it. We also mark
                <code>node</code> as visited.
            </li>
            <li>We now loop until the queue is empty. The queue's first element, <code>node</code>, is popped out. We
                iterate over all the neighbors of <code>node</code> where the neighboring nodes are found using <code>isConnected[node]</code>.
                If any <code>neighbor</code> has not yet been visited, we mark it as visited and push it into the queue.
            </li>
        </ul>
    </li>
    <li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public void bfs(int node, int[][] isConnected, boolean[] visit) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(node);
        visit[node] = true;

        while (!q.isEmpty()) {
            node = q.poll();

            for (int i = 0; i < isConnected.length; i++) {
                if (isConnected[node][i] == 1 && !visit[i]) {
                    q.offer(i);
                    visit[i] = true;
                }
            }
        }
    }

    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        int numberOfComponents = 0;
        boolean[] visit = new boolean[n];

        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                numberOfComponents++;
                bfs(i, isConnected, visit);
            }
        }

        return numberOfComponents;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    void bfs(int node, vector<vector<int>>& isConnected, vector<bool>& visit) {
        queue<int> q;
        q.push(node);
        visit[node] = true;

        while (!q.empty()) {
            node = q.front();
            q.pop();

            for (int i = 0; i < isConnected.size(); i++) {
                if (isConnected[node][i] && !visit[i]) {
                    q.push(i);
                    visit[i] = true;
                }
            }
        }
    }

    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        int numberOfComponents = 0;
        vector<bool> visit(n);

        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                numberOfComponents++;
                bfs(i, isConnected, visit);
            }
        }

        return numberOfComponents;
    }
};
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the number of cities.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>Initializing the <code>visit</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
            <li>Each queue operation in the BFS algorithm takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span> time, and a single
                node can only be pushed once, leading to <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                operations for <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                nodes. As discussed above, we iterate over all possible edges using <code>isConnected[node]</code> which
                takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                time for each visited node, resulting in <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> operations in total in the worst-case
                scenario while visiting all nodes.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>The BFS queue takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> because
                each node is added, and in the worst-case scenario you could have a linear amount of nodes in the queue
                at once.
            </li>
            <li>The <code>visit</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space as
                well.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-3-union-find">Approach 3: Union-find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving questions based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a union–find data structure or merge–find set, is a data structure that
    stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint
    subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a
    representative member of a set. It implements two useful operations:</p>
<ol>
    <li><code>Find</code>: Determine which subset a particular element is in. This can be used to determine if two
        elements are in the same subset.
    </li>
    <li><code>Union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a
        href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/" target="_blank">LeetCode Explore
    Card</a>. We will not talk about implementation details in this article, but only about the interface to the data
    structure.</p>
<p>Our task, as with the previous approaches, is to count the number of connected components formed in the graph with
    cities acting as nodes and an edge between directly connected cities.</p>
<p>We initialize all nodes as separate components in the union-find data structure. We create a variable called <code>numberOfComponents</code>
    to count the number of connected components in the graph and initialize it to the number to the nodes.</p>
<p>We iterate over all the edges, decrementing <code>numberOfComponents</code> by <code>1</code> for each edge whenever
    two different components are merged into a single one using that edge.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> which stores the number of cities.</li>
    <li>Create an instance of <code>UnionFind</code> of size <code>n</code>.</li>
    <li>Create an integer variable <code>numberOfComponents</code> to count the number of connected components in the
        graph. We initialize it to <code>n</code> as each node initially behaves as a separate component.
    </li>
    <li>We iterate over <code>isConnected</code> using two loops, outer loop running from <code>i = 0</code> to <code>n
        - 1</code> and an inner loop running from <code>j = i + 1</code> to <code>n - 1</code>. For each pair of
        directly connected cities <code>i</code> and <code>j</code>, i.e., <code>isConnected[i][j] == 1</code>, we use
        the <code>find</code> operation to determine which components both of them belong to. If they belong to
        different components, i.e., <code>find(i)!= find(j)</code>, we perform a <code>union</code> operation on both
        nodes, combining the two different connected components into a single connected component. We also reduce <code>numberOfComponents</code>
        by one as we just merged two different components. We don't do anything if <code>i</code> and <code>j</code>
        already belong to the same component.
    </li>
    <li>Return <code>numberOfComponents</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<pre>
    Java
    <code>
        class UnionFind {
    int[] parent;
    int[] rank;
    public UnionFind(int size) {
        parent = new int[size];
        for (int i = 0; i < size; i++)
            parent[i] = i;
        rank = new int[size];
    }
    public int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }
    public void union_set(int x, int y) {
        int xset = find(x), yset = find(y);
        if (xset == yset) {
            return;
        } else if (rank[xset] < rank[yset]) {
            parent[xset] = yset;
        } else if (rank[xset] > rank[yset]) {
            parent[yset] = xset;
        } else {
            parent[yset] = xset;
            rank[xset]++;
        }
    }
}

class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;
        UnionFind dsu = new UnionFind(n);
        int numberOfComponents = n;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] == 1 && dsu.find(i) != dsu.find(j)) {
                    numberOfComponents--;
                    dsu.union_set(i, j);
                }
            }
        }

        return numberOfComponents;
    }
}
    </code>
    C++
    <code>
        class UnionFind {
private:
    vector<int> parent, rank;
    int count;

public:
    UnionFind(int size) {
        parent.resize(size);
        rank.resize(size, 0);
        count = size;
        for (int i = 0; i < size; i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }
    void union_set(int x, int y) {
        int xset = find(x), yset = find(y);
        if (rank[xset] < rank[yset]) {
            parent[xset] = yset;
        } else if (rank[xset] > rank[yset]) {
            parent[yset] = xset;
        } else {
            parent[yset] = xset;
            rank[xset]++;
        }
    }
};

class Solution {
public:
    int findCircleNum(vector<vector<int>>& isConnected) {
        int n = isConnected.size();
        UnionFind dsu(n);
        int numberOfComponents = n;

        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isConnected[i][j] && dsu.find(i) != dsu.find(j)) {
                    numberOfComponents--;
                    dsu.union_set(i, j);
                }
            }
        }

        return numberOfComponents;
    }
};
    </code>
</pre>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the number of cities.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>We need <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time to iterate over all the values in <code>isConnected</code>.
            </li>
            <li>For <span class="math math-inline"><span class="katex"><span class="katex-mathml">TT</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.6833em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.13889em;">T</span></span></span></span></span>
                operations, the amortized time complexity of the union-find algorithm (using path compression with union
                by rank) is <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(alpha(T))O(alpha(T))</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">a</span><span
                        class="mord mathnormal">lp</span><span class="mord mathnormal">ha</span><span
                        class="mopen">(</span><span class="mord mathnormal"
                                                    style="margin-right: 0.13889em;">T</span><span
                        class="mclose">))</span></span></span></span></span>. Here, <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">α(T)\alpha(T)</span><span class="katex-html"
                                                                                           aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span
                        class="mopen">(</span><span class="mord mathnormal"
                                                    style="margin-right: 0.13889em;">T</span><span
                        class="mclose">)</span></span></span></span></span> is the inverse Ackermann function that grows
                so slowly, that it doesn't exceed <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">44</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.6444em;"></span><span
                        class="mord">4</span></span></span></span></span> for all reasonable <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">TT</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.6833em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.13889em;">T</span></span></span></span></span>
                (approximately <span class="math math-inline"><span class="katex"><span class="katex-mathml">T&lt;10600 T &lt; 10^{600}</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.7224em; vertical-align: -0.0391em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mspace"
                                                                                               style="margin-right: 0.2778em;"></span><span
                        class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span
                        class="base"><span class="strut" style="height: 0.8141em;"></span><span
                        class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span
                        class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span
                        class="mord mtight">600</span></span></span></span></span></span></span></span></span></span></span></span></span>).
                You can read more about the complexity of union-find <a
                        href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity"
                        target="_blank">here</a>. Because the function grows so slowly, we consider it to be <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span>.
            </li>
            <li>Initializing <code>UnionFind</code> takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time
                beacuse we are initializing the <code>parent</code> and <code>rank</code> arrays of size <code>n</code>
                each.
            </li>
            <li>We iterate through every edge and use the <code>find</code> operation to find the component of nodes
                connected by each edge. It takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> per operation and takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(e)O(e)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></span>
                time for all the <span class="math math-inline"><span class="katex"><span class="katex-mathml">ee</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.4306em;"></span><span
                        class="mord mathnormal">e</span></span></span></span></span> edges. We can have a maximum of
                <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> edges in between <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.4306em;"></span><span
                        class="mord mathnormal">n</span></span></span></span></span> nodes (each node is connected to
                other), so it would take <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> time. If nodes from different components are
                connected by an edge, we also perform <code>union</code> of the nodes, which takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> time per operation. In the worst-case
                scenario, it may be called <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                times to connect all the components to form a connected graph with only one component.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>We are using the <code>parent</code> and <code>rank</code> arrays, both of which require <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space
                each.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>