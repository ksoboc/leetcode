<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Similar String Groups - Solution</title>
</head>
<body>
<h2 id="solution">Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>The problem states that two strings <code>X</code> and <code>Y</code> are similar if two letters (in different
    positions) of <code>X</code> can be swapped to form string <code>Y</code>. Also, if two strings <code>X</code> and
    <code>Y</code> are equal, they are similar.</p>
<p>We are given an array of strings called <code>strs</code>, where each string is an anagram of every other string in
    the array.</p>
<p>Our task is to group the strings together, where strings in the same group are similar to at least one other string
    in the group.</p>
<p>We have to return the number of such groups that will be formed.</p>
<hr>
<h3 id="approach-1-depth-first-search">Approach 1: Depth First Search</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that two words <code>A</code> and <code>B</code> belong to the same group if they are similar or equal, or
    if there are some words in the group such as <code>X1</code>, <code>X2</code>,... <code>XN</code>, such that
    <code>A</code> is similar to <code>X1</code>, <code>X1</code> is similar to <code>X2</code>,... <code>XN</code> is
    similar to <code>B</code>. It means that if we can create a path from <code>A</code> to <code>B</code> using words
    from the group, then <code>A</code> and <code>B</code> are also members of that group.</p>
<p>This prompts us to think about the problem in terms of graphs.</p>
<p>Each word in <code>strs</code> can be viewed as a node. We add an undirected edge between each pair of similar words.
    If there is a path in this graph from words <code>A</code> to <code>B</code>, then <code>A</code> and <code>B</code>
    belong to the same group. Because the graph is undirected, <code>A</code> and <code>B</code> belong to the same
    group if and only if they belong to the same component of the graph.</p>
<p><strong>The number of required groups is the number of connected components formed in such a graph.</strong></p>
<p>To make the graph, we use a hash map called <code>adj</code> with an integer as the key and a list of integers as the
    value to map the index of the word to a list of indices of words that are similar to it. We are using the indices as
    the nodes instead of the strings themselves because dealing with integers is faster than strings.</p>
<p>For a pair of similar words <code>A</code> and <code>B</code> with indices <code>i</code> and <code>j</code> in
    <code>strs</code>, we add <code>j</code> to the <code>adj[i]</code> map and <code>i</code> to the
    <code>adj[j]</code> map. This adds an undirected edge between nodes <code>i</code> and <code>j</code>. We iterate
    over all the pairs of words that can be formed in <code>strs</code>, see if they are similar, and then add an edge
    between them. This forms our graph.</p>
<p>To check the number of connected components in a graph, we can use a graph traversal algorithm like depth first
    search (DFS).</p>
<p>We use the <code>dfs</code> method, which takes <code>node, adj, visit</code> as parameters. The parameter
    <code>node</code> is the index of the word from which we start our path. <code>visit</code> is used to keep track of
    visited indices. <code>adj</code> is the adjacency list.</p>
<p>In the <code>dfs</code> method, we mark <code>node</code> as visited. We then iterate over all the neighbors of
    <code>node</code> and recursively visit them to cover all the nodes in the current connected component.</p>
<p>To figure out how many connected components there are in the graph, we first mark all nodes as unvisited. We create a
    variable called <code>count</code> to count the number of connected components in the graph and initialize it to
    <code>0</code>.</p>
<p>We iterate through all the nodes from <code>0</code> to <code>n - 1</code>, checking whether each <code>node</code>
    has been visited or not. If <code>node</code> is not visited, we begin a DFS traversal from <code>node</code> and
    increment <code>count</code> by <code>1</code> (a new connected component is discovered). The DFS traversal would
    visit all of the nodes in the component to which <code>node</code> belongs.</p>
<p>As an answer, we return <code>count</code>.</p>
<p>Here's a visual representation of how the approach works in the first example given in the problem description:</p>
<p><img src="839-1.png" alt="img"></p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> which stores the number of words in <code>strs</code>.</li>
    <li>Create an adjacency list of size <code>n</code> using <code>strs</code> where <code>adj[x]</code> contains all
        the indices of words similar to word <code>str[x]</code>.
        <ul>
            <li>We iterate over all pairs of words that can be formed by selecting any two words from <code>str</code>
                to generate the adjacency list.
            </li>
            <li>For any two words at index <code>i</code> and <code>j</code>, we check whether the words
                <code>strs[i]</code> and <code>strs[j]</code> are similar or not by iterating over all the letters of
                the words. If the words are equal or they differ at two indices only, the words are similar.
            </li>
            <li>If they are similar, we add <code>j</code> to the <code>adj[i]</code> and <code>i</code> to the <code>adj[j]</code>
                map.
            </li>
        </ul>
    </li>
    <li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
    <li>Create an integer <code>count</code> which stores the number of connected components in the graph. Initialize it
        to <code>0</code>.
    </li>
    <li>Iterate through all of the nodes, and for each node <code>i</code> check if it has been visited or not. If node
        <code>i</code> is not visited, we increment <code>count</code> by <code>1</code> and start a DFS traversal:
        <ul>
            <li>We use the <code>dfs</code> function to perform the traversal. For each call, pass <code>node</code>,
                <code>adj</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.
            </li>
            <li>We mark <code>node</code> as visited.</li>
            <li>We iterate over all the neighbors of <code>node</code>. If any <code>neighbor</code> has not yet been
                visited, we recursively call <code>dfs</code> with <code>neighbor</code> as the node.
            </li>
        </ul>
    </li>
    <li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public void dfs(int node, Map<Integer, List<Integer>> adj, boolean[] visit) {
        visit[node] = true;
        if (!adj.containsKey(node)) {
            return;
        }
        for (int neighbor : adj.get(node)) {
            if (!visit[neighbor]) {
                visit[neighbor] = true;
                dfs(neighbor, adj, visit);
            }
        }
    }

    public boolean isSimilar(String a, String b) {
        int diff = 0;
        for (int i = 0; i < a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                diff++;
            }
        }
        return diff == 0 || diff == 2;
    }

    public int numSimilarGroups(String[] strs) {
        int n = strs.length;
        Map<Integer, List<Integer>> adj = new HashMap<>();
        // Form the required graph from the given strings array.
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isSimilar(strs[i], strs[j])) {
                    adj.computeIfAbsent(i, k -> new ArrayList<Integer>()).add(j);
                    adj.computeIfAbsent(j, k -> new ArrayList<Integer>()).add(i);
                }
            }
        }

        boolean[] visit = new boolean[n];
        int count = 0;
        // Count the number of connected components.
        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                dfs(i, adj, visit);
                count++;
            }
        }

        return count;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    void dfs(int node, vector<vector<int>>& adj, vector<bool>& visit) {
        visit[node] = true;
        for (int neighbor : adj[node]) {
            if (!visit[neighbor]) {
                dfs(neighbor, adj, visit);
            }
        }
    }

    bool isSimilar(string& a, string& b) {
        int diff = 0;
        for (int i = 0; i < a.size(); i++) {
            if (a[i] != b[i]) {
                diff++;
            }
        }
        return diff == 0 || diff == 2;
    }

    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        vector<vector<int>> adj(n);
        // Form the required graph from the given strings array.
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isSimilar(strs[i], strs[j])) {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }

        vector<bool> visit(n);
        int count = 0;
        // Count the number of connected components.
        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                dfs(i, adj, visit);
                count++;
            }
        }

        return count;
    }
};
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the size of <code>strs</code> and <code>m</code> is length of each word in <code>strs</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2⋅m)O(n^2 \cdot m)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>To iterate over all the pairs of words that can be formed using <code>strs</code>, we need <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time. We also need <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time to
                determine whether the chosen two words are similar or not, which results in <span
                        class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2⋅m)O(n^2 \cdot m)</span><span class="katex-html"
                                                                               aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span
                        class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
                        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                operations to check all the pairs.
            </li>
            <li>The <code>dfs</code> function visits each node once, which takes <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time
                because there are <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                nodes in total. We can have up to <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> edges between <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.4306em;"></span><span
                        class="mord mathnormal">n</span></span></span></span></span> nodes (assume every word is similar
                to every other word). Because we have undirected edges, each edge can only be iterated twice (by nodes
                at the end), resulting in <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> operations total in the worst-case scenario
                while visiting all nodes.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>As there can be a maximum of <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> edges, building the adjacency list takes <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> space.
            </li>
            <li>The <code>visit</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.
            </li>
            <li>The recursion call stack used by <code>dfs</code> can have no more than <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.4306em;"></span><span
                    class="mord mathnormal">n</span></span></span></span></span> elements in the worst-case scenario. It
                would take up <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space in that case.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-2-breadth-first-search">Approach 2: Breadth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>As we just have to find the number of connected components in the graph, another method is to use a breadth-first
    search (BFS).</p>
<p>BFS is an algorithm for traversing or searching a graph. It traverses in a level-wise manner, i.e., all the nodes at
    the present level (say <code>l</code>) are explored before moving on to the nodes at the next level (<code>l +
        1</code>), where a level's number is the distance from a starting node. BFS is implemented with a queue.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> which stores the number of words in <code>strs</code>.</li>
    <li>Create an adjacency list of size <code>n</code> using <code>strs</code> where <code>adj[x]</code> contains all
        the indices of words similar to word <code>str[x]</code>.
        <ul>
            <li>We iterate over all pairs of words that can be formed by selecting any two words from <code>str</code>
                to generate the adjacency list.
            </li>
            <li>For any two words at index <code>i</code> and <code>j</code>, we check whether the words
                <code>strs[i]</code> and <code>strs[j]</code> are similar or not by iterating over all the letters of
                the words. If the words are equal or they differ at two indices only, the words are similar.
            </li>
            <li>If they are similar, we add <code>j</code> to the <code>adj[i]</code> and <code>i</code> to the <code>adj[j]</code>
                map.
            </li>
        </ul>
    </li>
    <li>Create a <code>visit</code> array of length <code>n</code> to keep track of nodes that have been visited.</li>
    <li>Create an integer <code>count</code> which stores the number of connected components in the graph. Initialize it
        to <code>0</code>.
    </li>
    <li>Iterate through all of the nodes and for each node <code>i</code> check if it has been visited or not. If node
        <code>i</code> is not visited, we increment <code>count</code> by <code>1</code> and start a BFS traversal:
        <ul>
            <li>We use the <code>bfs</code> function to perform the traversal. For each call, pass <code>node</code>,
                <code>adj</code>, and <code>visit</code> as the parameters. We start with node <code>i</code>.
            </li>
            <li>We create an integer queue <code>q</code> and push <code>node</code> into it. We also mark
                <code>node</code> as visited.
            </li>
            <li>We now loop until the queue is empty. The queue's first element, <code>node</code>, is popped out. We
                iterate over all the neighbors of <code>node</code>. If any <code>neighbor</code> has not yet been
                visited, we mark it as visited and push it into the queue.
            </li>
        </ul>
    </li>
    <li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public void bfs(int node, Map<Integer, List<Integer>> adj, boolean[] visit) {
        Queue<Integer> q = new LinkedList<>();
        q.offer(node);
        visit[node] = true;
        while (!q.isEmpty()) {
            node = q.poll();
            if (!adj.containsKey(node)) {
                continue;
            }
            for (int neighbor : adj.get(node)) {
                if (!visit[neighbor]) {
                    visit[neighbor] = true;
                    q.offer(neighbor);
                }
            }
        }
    }

    public boolean isSimilar(String a, String b) {
        int diff = 0;
        for (int i = 0; i < a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                diff++;
            }
        }
        return diff == 0 || diff == 2;
    }

    public int numSimilarGroups(String[] strs) {
        int n = strs.length;
        Map<Integer, List<Integer>> adj = new HashMap<>();
        // Form the required graph from the given strings array.
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isSimilar(strs[i], strs[j])) {
                    adj.computeIfAbsent(i, k -> new ArrayList<Integer>()).add(j);
                    adj.computeIfAbsent(j, k -> new ArrayList<Integer>()).add(i);
                }
            }
        }

        boolean[] visit = new boolean[n];
        int count = 0;
        // Count the number of connected components.
        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                bfs(i, adj, visit);
                count++;
            }
        }

        return count;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    void bfs(int node, vector<vector<int>>& adj, vector<bool>& visit) {
        queue<int> q;
        q.push(node);
        visit[node] = true;

        while (!q.empty()) {
            node = q.front();
            q.pop();

            for (int neighbor : adj[node]) {
                if (!visit[neighbor]) {
                    visit[neighbor] = true;
                    q.push(neighbor);
                }
            }
        }
    }

    bool isSimilar(string& a, string& b) {
        int diff = 0;
        for (int i = 0; i < a.size(); i++) {
            if (a[i] != b[i]) {
                diff++;
            }
        }
        return diff == 0 || diff == 2;
    }

    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        vector<vector<int>> adj(n);
        // Form the required graph from the given strings array.
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isSimilar(strs[i], strs[j])) {
                    adj[i].push_back(j);
                    adj[j].push_back(i);
                }
            }
        }

        vector<bool> visit(n);
        int count = 0;
        // Count the number of connected components.
        for (int i = 0; i < n; i++) {
            if (!visit[i]) {
                bfs(i, adj, visit);
                count++;
            }
        }

        return count;
    }
};
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the size of <code>strs</code> and <code>m</code> is length of each word in <code>strs</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2⋅m)O(n^2 \cdot m)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>We need <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time to iterate over all the pairs of words that
                can be formed using <code>strs</code>. We further need <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                time to check whether the chosen two words are similar or not, resulting in <span
                        class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2⋅m)O(n^2 \cdot m)</span><span class="katex-html"
                                                                               aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span
                        class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
                        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                operations to check all the pairs.
            </li>
            <li>Each queue operation in the BFS algorithm takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span> time, and a single
                node can only be pushed once, leading to <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                operations for <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                nodes. As discussed above, we can have up to <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> edges between <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.4306em;"></span><span
                        class="mord mathnormal">n</span></span></span></span></span> nodes (assume every word is similar
                to every other word). Because we have undirected edges, each edge can only be iterated twice (by nodes
                at the end), resulting in <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> operations total in the worst-case scenario
                while visiting all nodes.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>As there can be a maximum of <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span>. edges, building the adjacency list takes <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span>. space in the worst case.
            </li>
            <li>The BFS queue takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> because
                each node is added at most once.
            </li>
            <li>The <code>visit</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space as
                well.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-3-union-find">Approach 3: Union-find</h3>
<h4 id="intuition-2">Intuition</h4>
<p>Another approach to solving questions based on graph connectivity is the union-find data structure.</p>
<p>A disjoint-set data structure also called a union–find data structure or merge–find set, is a data structure that
    stores a collection of disjoint (non-overlapping) sets. Equivalently, it stores a partition of a set into disjoint
    subsets. It provides operations for adding new sets, merging sets (replacing them by their union), and finding a
    representative member of a set. It implements two useful operations:</p>
<ol>
    <li><code>Find</code>: Determine which subset a particular element is in. This can be used to determine if two
        elements are in the same subset.
    </li>
    <li><code>Union</code>: Join two subsets into a single subset.</li>
</ol>
<p>If you are new to Union-Find, we suggest you read our <a
        href="https://leetcode.com/explore/learn/card/graph/618/disjoint-set/3881/" target="_blank">Leetcode Explore
    Card</a>. We will not talk about implementation details in this article, but only about the interface to the data
    structure.</p>
<p>Our task, as with the previous approaches, is to count the number of connected components formed in the graph by
    indices of words acting as nodes and an edge between indices of every two similar words.</p>
<p>We initialize all nodes as separate components in the union-find data structure. We declare and initialize a variable
    called <code>count</code> to count the number of connected components in the graph. We iterate over all the edges,
    decrementing <code>count</code> by <code>1</code> for each edge whenever two different components are merged into a
    single one using that edge.</p>
<p>We iterate through all of the pairs that can be formed by selecting any two words from <code>strs</code>, and for
    each pair of similar words at index <code>i</code> and <code>j</code>, we use the <code>find</code> operation to
    determine which components both of them belong to. If they belong to different components, i.e., <code>find(node1)!=
        find(node2)</code>, we perform a <code>union</code> operation on both nodes, combining the two different
    connected components into a single connected component. We also reduce <code>count</code> by one. We don't do
    anything if <code>i</code> and <code>j</code> belong to the same component.</p>
<p>As an answer, we return <code>count</code>.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
    <li>Createa an integer variable <code>n</code> which stores the number of words in <code>strs</code>.</li>
    <li>Create an instance of <code>UnionFind</code> of size <code>n</code>.</li>
    <li>For any two words at index <code>i</code> and <code>j</code> that behave as nodes, we check whether the words
        <code>strs[i]</code> and <code>strs[j]</code> are similar or not by iterating over all the letters of the words.
        The words are similar if they are equal or differ only at two indices.
        <ul>
            <li>If the words are similar, we use the <code>find</code> operation to determine the components of both the
                nodes.
            </li>
            <li>If both nodes belong to different components, we use the <code>union</code> operation over both nodes to
                combine the two different connected components into a single one. We also decrement <code>count</code>
                by <code>1</code>.
            </li>
        </ul>
    </li>
    <li>Return <code>count</code>.</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<pre>
    Java
    <code>
        class UnionFind {
    int[] parent;
    int[] rank;

    public UnionFind(int size) {
        parent = new int[size];
        for (int i = 0; i < size; i++)
            parent[i] = i;
        rank = new int[size];
    }

    public int find(int x) {
        if (parent[x] != x)
            parent[x] = find(parent[x]);
        return parent[x];
    }

    public void union_set(int x, int y) {
        int xset = find(x), yset = find(y);
        if (xset == yset) {
            return;
        } else if (rank[xset] < rank[yset]) {
            parent[xset] = yset;
        } else if (rank[xset] > rank[yset]) {
            parent[yset] = xset;
        } else {
            parent[yset] = xset;
            rank[xset]++;
        }
    }
}

class Solution {
    public boolean isSimilar(String a, String b) {
        int diff = 0;
        for (int i = 0; i < a.length(); i++) {
            if (a.charAt(i) != b.charAt(i)) {
                diff++;
            }
        }
        return diff == 0 || diff == 2;
    }

    public int numSimilarGroups(String[] strs) {
        int n = strs.length;
        UnionFind dsu = new UnionFind(n);
        int count = n;
        // Form the required graph from the given strings array.
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isSimilar(strs[i], strs[j]) && dsu.find(i) != dsu.find(j)) {
                    count--;
                    dsu.union_set(i, j);
                }
            }
        }

        return count;
    }
}
    </code>
    C++
    <code>
        class UnionFind {
private:
    vector<int> parent, rank;
    int count;

public:
    UnionFind(int size) {
        parent.resize(size);
        rank.resize(size, 0);
        count = size;
        for (int i = 0; i < size; i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (parent[x] != x) parent[x] = find(parent[x]);
        return parent[x];
    }
    void union_set(int x, int y) {
        int xset = find(x), yset = find(y);
        if (rank[xset] < rank[yset]) {
            parent[xset] = yset;
        } else if (rank[xset] > rank[yset]) {
            parent[yset] = xset;
        } else {
            parent[yset] = xset;
            rank[xset]++;
        }
    }
};

class Solution {
public:
    bool isSimilar(string& a, string& b) {
        int diff = 0;
        for (int i = 0; i < a.size(); i++) {
            if (a[i] != b[i]) {
                diff++;
            }
        }
        return diff == 0 || diff == 2;
    }

    int numSimilarGroups(vector<string>& strs) {
        int n = strs.size();
        UnionFind dsu(n);
        int count = n;
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (isSimilar(strs[i], strs[j]) && dsu.find(i) != dsu.find(j)) {
                    count--;
                    dsu.union_set(i, j);
                }
            }
        }

        return count;
    }
};
    </code>
</pre>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the size of <code>strs</code> and <code>m</code> is length of each word in <code>strs</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2⋅m)O(n^2 \cdot m)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>We need <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time to iterate over all the pairs of words that
                can be formed using <code>strs</code>. We further need <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                time to check whether the chosen two words are similar or not, resulting in <span
                        class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2⋅m)O(n^2 \cdot m)</span><span class="katex-html"
                                                                               aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span
                        class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
                        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                operations to check all the pairs.
            </li>
            <li>For <span class="math math-inline"><span class="katex"><span class="katex-mathml">TT</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.6833em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.13889em;">T</span></span></span></span></span>
                operations, the amortized time complexity of the union-find algorithm (using path compression with union
                by rank) is <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(alpha(T))O(alpha(T))</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">a</span><span
                        class="mord mathnormal">lp</span><span class="mord mathnormal">ha</span><span
                        class="mopen">(</span><span class="mord mathnormal"
                                                    style="margin-right: 0.13889em;">T</span><span
                        class="mclose">))</span></span></span></span></span>. Here, <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">α(T)\alpha(T)</span><span class="katex-html"
                                                                                           aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.0037em;">α</span><span
                        class="mopen">(</span><span class="mord mathnormal"
                                                    style="margin-right: 0.13889em;">T</span><span
                        class="mclose">)</span></span></span></span></span> is the inverse Ackermann function that grows
                so slowly, that it doesn't exceed <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">44</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.6444em;"></span><span
                        class="mord">4</span></span></span></span></span> for all reasonable <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">TT</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.6833em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.13889em;">T</span></span></span></span></span>
                (approximately <span class="math math-inline"><span class="katex"><span class="katex-mathml">T&lt;10600 T &lt; 10^{600}</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.7224em; vertical-align: -0.0391em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.13889em;">T</span><span class="mspace"
                                                                                               style="margin-right: 0.2778em;"></span><span
                        class="mrel">&lt;</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span
                        class="base"><span class="strut" style="height: 0.8141em;"></span><span
                        class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span
                        class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span
                        class="mord mtight">600</span></span></span></span></span></span></span></span></span></span></span></span></span>).
                You can read more about the complexity of union-find <a
                        href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure#Time_complexity"
                        target="_blank">here</a>. Because the function grows so slowly, we consider it to be <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span>.
            </li>
            <li>Initializing <code>UnionFind</code> takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time
                beacuse we are initializing the <code>parent</code> and <code>rank</code> arrays of size <code>n</code>
                each.
            </li>
            <li>We iterate through every edge and use the <code>find</code> operation to find the component of nodes
                connected by each edge. It takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> per operation and takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(e)O(e)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">e</span><span class="mclose">)</span></span></span></span></span>
                time for all the <span class="math math-inline"><span class="katex"><span class="katex-mathml">ee</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.4306em;"></span><span
                        class="mord mathnormal">e</span></span></span></span></span> edges. As discussed above, we can
                have a maximum of <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> edges in between <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.4306em;"></span><span
                        class="mord mathnormal">n</span></span></span></span></span> nodes, so it would take <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> time. If nodes from different components are
                connected by an edge, we also perform <code>union</code> of the nodes, which takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> time per operation. In the worst-case
                scenario, it may be called <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                times to connect all the components to form a connected graph with only one component.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>We are using the <code>parent</code> and <code>rank</code> arrays, both of which require <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space
                each.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>