<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Longest Arithmetic Subsequence - Solution</title>
</head>
<body>
<h2 id="solution">Longest Arithmetic Subsequence - Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>Let's explain with the example provided in the problem. We found several sequences from the array and their common
    differences <code>diff</code>.</p>
<p><img src="intro.png" alt="img"></p>
<hr>
<h3 id="approach-dynamic-programming">Approach: Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>We can start with a brute-force approach. Since each arithmetic sequence always has a length greater than or equal to
    <code>2</code>, we can try to find each pair of elements <code>nums[left]</code> and <code>nums[right]</code> that
    form <strong>the first two elements</strong> of an arithmetic sequence by a nested iteration over <code>nums</code>.
</p>
<p>For each pair of indices <code>(left, right)</code>, we can determine the common difference <code>diff = nums[right]
    - nums[left]</code> of the sequence they represent, and continue to traverse the array to the right of
    <code>right</code> to find if there exists following elements. For example:</p>
<ul>
    <li>based on the <code>nums[right]</code> and <code>diff</code>, we can find whether there exists a third element
        <code>nums[right] + diff</code> to the right of <code>nums[right]</code>.
    </li>
</ul>
<p>However, the time complexity of this approach is too expensive. For an array of length <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                               aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>,
    there are <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1.0641em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
            class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
            style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mtight">2</span></span></span></span></span></span></span></span><span
            class="mclose">)</span></span></span></span></span> possible pairs of starting elements, and for each pair,
    we may need to traverse the remaining <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> elements.
    Therefore, the time complexity of this approach is <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">O(n3)O(n^3)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                          style="margin-right: 0.02778em;">O</span><span
            class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span
            class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
            style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mtight">3</span></span></span></span></span></span></span></span><span
            class="mclose">)</span></span></span></span></span>, which is likely to exceed the time limit.</p>
<p><img src="1.png" alt="img"></p>
<br>
<p>Instead of treating <code>nums[left]</code> and <code>nums[right]</code> as the starting elements of a sequence, we
    can consider it as the last two elements of a sequence. Assuming that we have chosen indices <code>left</code> and
    <code>right</code>, how can we determine the length of the sequence that ends with <code>nums[left]</code> and
    <code>nums[right]</code>? Do we need to search backward from <code>left</code> as in the previous brute-force
    approach? Not necessarily.</p>
<p><img src="2.png" alt="img"></p>
<p>Instead, we can keep track of all possible arithmetic sequences that end with each element in the array, along with
    their common difference and length.</p>
<p>Assume we already know which arrays end at <code>left</code> and what their common difference and length are. Then,
    we just need to search among these arrays to find if there is an array with a common difference <code>diff =
        nums[right] - nums[left]</code> and what its length is! If there is, we can extend it to a new arithmetic
    sequence by appending <code>nums[right]</code> and updating the length of the longest arithmetic sequence seen so
    far. The problem only requires us to find the longest sequence, so we don't need to record the specific sequence but
    only need to record their length and common difference.</p>
<p><img src="3.png" alt="img"></p>
<p>As shown in the picture below, if we have recorded that there is a arithmetic sequence (<strong>1, 3</strong>) ending
    at <code>nums[left]</code> with a common difference of <code>2</code>, then we can just extend the sequence by
    adding <code>nums[right]</code> to it as (<strong>1, 3, 5</strong>).</p>
<p><img src="4.png" alt="img"></p>
<br>
<p>This method is called dynamic programming. We can use a 2D array <code>dp</code> to record the length of the longest
    arithmetic sequence that ends with each element, as well as the common difference and the previous element of each
    longest arithmetic sequence. Specifically, let <code>dp[right][diff]</code> represent the length of the longest
    arithmetic sequence that ends with the element at index <code>right</code> and has a common difference of
    <code>diff</code>. The state transition equation is:</p>
<p><code>dp[right][diff] = dp[left][diff] + 1</code><br>
    Where <code>(left &lt; right, diff = nums[right] - nums[left])</code></p>
<p>The final answer is the maximum value in <code>dp</code>.</p>
<br>
<p>As shown in the picture below, when we are at the index <code>right = 1</code>, we can save <code>dp[1][-19] =
    2</code>, which means the longest arithmetic subsequence ending at index <code>i</code> and with a common difference
    of <code>-19</code> has a length of <code>2</code>.</p>
<p><img src="5.png" alt="img"></p>
<br>
<p>Let's take the following slides as an detailed example:</p>
<p>
<div class="relative mx-auto mb-6 flex flex-col overflow-hidden rounded-lg border-[1px] border-label-1"
     style="max-width: 601px;">
    <div class="rounded-lg" style="max-height: 301px;"><img alt="Current"
                                                            class="object-fit-contain !mb-0 max-h-full max-w-full"
                                                            src="blob:https://leetcode.com/4dc80248-c9be-461b-b615-d71214dd8cb5">
    </div>
    <div class="absolute top-[50%] left-[50%] flex h-12 w-12 translate-x-[-50%] translate-y-[-50%] items-center justify-center rounded-full bg-black/30">
        <div class="flex h-4 w-4 cursor-pointer items-center justify-center text-[35px]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="h-full w-full text-white">
                <path fill-rule="evenodd"
                      d="M18.97 12.871l-12.96 7.29a1 1 0 01-1.49-.87V4.71a1 1 0 011.49-.872l12.96 7.29a1 1 0 010 1.743z"
                      clip-rule="evenodd"></path>
            </svg>
        </div>
    </div>
    <div class="relative flex h-8 select-none items-center justify-around bg-black">
        <div class="flex items-center space-x-7">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M16.091 4.929l-7.057 7.078 7.057 7.064a1 1 0 01-1.414 1.414l-7.764-7.77a1 1 0 010-1.415l7.764-7.785a1 1 0 111.415 1.414z"
                      clip-rule="evenodd"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M18.97 12.871l-12.96 7.29a1 1 0 01-1.49-.87V4.71a1 1 0 011.49-.872l12.96 7.29a1 1 0 010 1.743z"
                      clip-rule="evenodd"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M7.913 19.071l7.057-7.078-7.057-7.064a1 1 0 011.414-1.414l7.764 7.77a1 1 0 010 1.415l-7.764 7.785a1 1 0 01-1.414-1.414z"
                      clip-rule="evenodd"></path>
            </svg>
        </div>
        <div class="absolute right-0 mr-5 text-xs font-medium text-white">1 / 11</div>
    </div>
</div>
</p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>
        <p>Initailize <code>dp</code> as memory to store the maximum length of subsequence that ends at
            <code>right</code> and with a common difference of <code>diff</code>.</p>
    </li>
    <li>
        <p>Iterate over the last index <code>right</code>, for each index:</p>
        <ul>
            <li>
                <p>Iterate over the second last index <code>left</code>, where <code>left &lt; right</code>:</p>
            </li>
            <li>
                <p>The common difference is <code>nums[right] - nums[left]</code>.</p>
            </li>
            <li>
                <p>Take <code>dp[left][diff]</code>, the length of the longest subsequence ending at <code>left</code>
                    and with the same common difference. If there exists such a subsequence, <code>dp[right][diff] =
                        dp[left][diff] + 1</code>, if there is no such subsequence, initilalize <code>dp[right][diff] =
                        2</code>.</p>
            </li>
        </ul>
    </li>
    <li>
        <p>Return the maximum value in <code>dp</code>.</p>
    </li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public int longestArithSeqLength(int[] nums) {
        int maxLength = 0;
        HashMap<Integer, Integer>[] dp = new HashMap[nums.length];
        for (int right = 0; right < nums.length; ++right) {
            dp[right] = new HashMap<>();
            for (int left = 0; left < right; ++left) {
                int diff = nums[left] - nums[right];
                dp[right].put(diff, dp[left].getOrDefault(diff, 1) + 1);
                maxLength = Math.max(maxLength, dp[right].get(diff));
            }
        }
        return maxLength;
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def longestArithSeqLength(self, nums: List[int]) -> int:
        dp = {}

        for right in range(len(nums)):
            for left in range(0, right):
                dp[(right, nums[right] - nums[left])] = dp.get((left, nums[right] - nums[left]), 1) + 1

        return max(dp.values())
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                    aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    be the length of the input array <code>nums</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We have a nested iteration over <code>nums</code>, for each last index <code>right</code>, we iterate over
            every second last index <code>left</code>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We create <code>dp</code> as memory where <code>dp[right][diff]</code> stores the length of the longest
            subsequence ending at index <code>right</code> and with a common difference of <code>diff</code>.</p>
        <ul>
            <li>If <code>right = 1</code>, it has 1 <code>left</code> to its left, so as the maximum number of unique
                <code>diff = nums[right] - nums[left]</code>.
            </li>
            <li>If <code>right = 2</code>, it has 2 <code>left</code> indices to its left, so as the maximum number of
                unique <code>diff</code>.<br>
                ...
            </li>
        </ul>
        <p>The maximum number of unique <code>diff</code> for an index <code>right</code> is <code>right</code>. Thus
            there might be at most <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> distinct status <code>(right, diff)</code>, so
            <code>dp</code> stores at most <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> lengths.</p>
    </li>
</ul>
<br>
</body>
</html>