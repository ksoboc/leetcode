<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Search in Rotated Sorted Array II - Solution</title>
</head>
<body>
<h2 id="solution">Search in Rotated Sorted Array II - Solution</h2>
<hr>
<h4 id="approach-1-binary-search">Approach 1: Binary Search</h4>
<p>This problem is an extension to <a href="https://leetcode.com/problems/search-in-rotated-sorted-array/"
                                      target="_blank">33. Search in Rotated Sorted Array</a>. The only difference is
    that this problem allows duplicate elements.</p>
<p><strong>Intuition</strong></p>
<p>Recall that after rotating a sorted array, what we get is two sorted arrays appended to each other.</p>
<p><img src="1.png" alt="rotating a sorted array"></p>
<p>Let's refer to the first sorted array as <code>F</code> and second as <code>S</code>.</p>
<p><img src="2.png" alt="rotating a sorted array"></p>
<p>Also, we can observe that all the elements of the second array <code>S</code> will be smaller or equal to the first
    element <code>start</code> of <code>F</code>.</p>
<p><img src="3.png" alt="rotating a sorted array"></p>
<p>With this observation in mind, we can easily tell which of the 2 arrays (<code>F</code> or <code>S</code>) does a
    <code>target</code> element lie in by just comparing it with the first element of the array.</p>
<p>Let's say we are looking for element <code>target</code> in array <code>arr</code>:</p>
<ul>
    <li>Case 1: If <code>target &gt; arr[start]</code>: <code>target</code> exists in the first array <code>F</code>.
    </li>
</ul>
<p><img src="4.png" alt="rotating a sorted array"></p>
<ul>
    <li>Case 2: If <code>target &lt; arr[start]</code>: <code>target</code> exists in the second array <code>S</code>.
    </li>
</ul>
<p><img src="5.png" alt="rotating a sorted array"></p>
<ul>
    <li>Case 3: If <code>target == arr[start]</code>: <code>target</code> obviously exists in the first array
        <code>F</code>, but it might also be present in the second array <code>S</code>.
    </li>
</ul>
<p><img src="6.png" alt="rotating a sorted array"></p>
<p>Let's define a helper function that tells us which array a target element might be present in:</p>
<pre>
  Java
  <code>
  // returns true if element `target` exists in the first sorted array.
private boolean existsInFirst(int[] arr, int start, int element) {
    return arr[start] <= element;
}
  </code>
  C++
  <code>
    // returns true if element exists in first array, false if it exists in second
bool existsInFirst(vector<int>& nums, int start, int element) {
    return nums[start] <= element;
}
  </code>
</pre>
<p><strong>Algorithm</strong></p>
<p>Recall that in standard binary search, we keep two pointers (i.e. <code>start</code> and <code>end</code>) to track
    the search scope in an <code>arr</code> array. We then divide the search space in three parts <code>[start,
        mid)</code>, <code>[mid, mid]</code>, <code>(mid, end]</code>. Now, we continue to look for our
    <code>target</code> element in one of these search spaces.</p>
<p>By identifying the positions of both <code>arr[mid]</code> and <code>target</code> in <code>F</code> and
    <code>S</code>, we can reduce search space in the very same way as in standard binary search:</p>
<ul>
    <li>Case 1: <code>arr[mid]</code> lies in <code>F</code>, <code>target</code> lies in <code>S</code>: Since
        <code>S</code> starts after <code>F</code> ends, we know that element lies here:<code>(mid, end]</code>.
    </li>
</ul>
<p><img src="7.png" alt="rotating a sorted array"></p>
<ul>
    <li>Case 2: <code>arr[mid]</code> lies in the <code>S</code>, <code>target</code> lies in <code>F</code>: Similarly,
        we know that element lies here: <code>[start, mid)</code>.
    </li>
</ul>
<p><img src="8.png" alt="rotating a sorted array"></p>
<ul>
    <li>Case 3: Both <code>arr[mid]</code> and <code>target</code> lie in <code>F</code>: since both of them are in same
        sorted array, we can compare <code>arr[mid]</code> and <code>target</code> in order to decide how to reduce
        search space.
    </li>
</ul>
<p><img src="9.png" alt="rotating a sorted array"></p>
<ul>
    <li>Case 4: Both <code>arr[mid]</code> and <code>target</code> lie in <code>S</code>: Again, since both of them are
        in same sorted array, we can compare <code>arr[mid]</code> and <code>target</code> in order to decide how to
        reduce search space.
    </li>
</ul>
<p><img src="10.png" alt="rotating a sorted array"></p>
<p>But there is a catch, if <code>arr[mid]</code> equals <code>arr[start]</code>, then we know that
    <code>arr[mid]</code> might belong to both <code>F</code> and <code>S</code> and hence we cannot find the relative
    position of <code>target</code> from it.</p>
<p><img src="11.png" alt="rotating a sorted array"></p>
<pre>
  Java
  <code>
    // returns true if we can reduce the search space in current binary search space
private boolean isBinarySearchHelpful(int[] arr, int left, int element) {
    return arr[left] != element;
}
  </code>
  C++
  <code>
    // returns true if we can reduce the search space in current binary search space
private boolean isBinarySearchHelpful(int[] arr, int left, int element) {
    return arr[left] != element;
}
  </code>
</pre>
<p>In this case, we have no option but to move to next search space iteratively. Hence, there are certain search spaces
    that allow a binary search, and some search spaces that don't.</p>
<pre>
  Java
  <code>
    class Solution {
    public boolean search(int[] nums, int target) {
        int n = nums.length;
        if (n == 0) return false;
        int end = n - 1;
        int start = 0;

        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                return true;
            }

            if (!isBinarySearchHelpful(nums, start, nums[mid])) {
                start++;
                continue;
            }
            // which array does pivot belong to.
            boolean pivotArray = existsInFirst(nums, start, nums[mid]);

            // which array does target belong to.
            boolean targetArray = existsInFirst(nums, start, target);
            if (pivotArray ^ targetArray) { // If pivot and target exist in different sorted arrays, recall that xor is true when both operands are distinct
                if (pivotArray) {
                    start = mid + 1; // pivot in the first, target in the second
                } else {
                    end = mid - 1; // target in the first, pivot in the second
                }
            } else { // If pivot and target exist in same sorted array
                if (nums[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }
        return false;
    }

    // returns true if we can reduce the search space in current binary search space
    private boolean isBinarySearchHelpful(int[] arr, int start, int element) {
        return arr[start] != element;
    }

    // returns true if element exists in first array, false if it exists in second
    private boolean existsInFirst(int[] arr, int start, int element) {
        return arr[start] <= element;
    }
}
  </code>
  C++
  <code>
    class Solution {
public:
    bool search(vector<int>& nums, int target) {
        int n = nums.size();
        if (n == 0) return false;
        int end = n - 1;
        int start = 0;

        while (start <= end) {
            int mid = start + (end - start) / 2;

            if (nums[mid] == target) {
                return true;
            }

            if (!isBinarySearchHelpful(nums, start, nums[mid])) {
                start++;
                continue;
            }

            // which array does pivot belong to.
            bool pivotArray = existsInFirst(nums, start, nums[mid]);

            // which array does target belong to.
            bool targetArray = existsInFirst(nums, start, target);
            if (pivotArray ^ targetArray) { // If pivot and target exist in different sorted arrays, recall that xor is true only when both the operands are distinct
                if (pivotArray) {
                    start = mid + 1; // pivot in the first, target in the second
                } else {
                    end = mid - 1; // target in the first, pivot in the second
                }
            } else { // If pivot and target exist in same sorted array
                if (nums[mid] < target) {
                    start = mid + 1;
                } else {
                    end = mid - 1;
                }
            }
        }
        return false;
    }

    // returns true if we can reduce the search space in current binary search space
    bool isBinarySearchHelpful(vector<int>& nums, int start, int element) {
        return nums[start] != element;
    }

    // returns true if element exists in first array, false if it exists in second
    bool existsInFirst(vector<int>& nums, int start, int element) {
        return nums[start] <= element;
    }
};
  </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<ul>
    <li>
        <p>Time complexity : <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(N)O(N)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span
                class="mclose">)</span></span></span></span></span> worst case, <span class="math math-inline"><span
                class="katex"><span class="katex-mathml">O(log⁡N)O(\log N)</span><span class="katex-html"
                                                                                       aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                          style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span
                class="mclose">)</span></span></span></span></span> best case, where <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">NN</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 0.6833em;"></span><span
                class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span></span> is the
            length of the input array.</p>
        <p>Worst case: This happens when all the elements are the same and we search for some different element. At each
            step, we will only be able to reduce the search space by 1 since <code>arr[mid]</code> equals <code>arr[start]</code>
            and it's not possible to decide the relative position of <code>target</code> from <code>arr[mid]</code>.<br>
            Example: [1, 1, 1, 1, 1, 1, 1], target = 2.</p>
        <p>Best case: This happens when all the elements are distinct. At each step, we will be able to divide our
            search space into half just like a normal binary search.</p>
    </li>
</ul>
<p>This also answers the following follow-up question:</p>
<ol>
    <li>Would this (having duplicate elements) affect the run-time complexity? How and why?</li>
</ol>
<p>As we can see, by having duplicate elements in the array, we often miss the opportunity to apply binary search in
    certain search spaces. Hence, we get <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(N)O(N)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mclose">)</span></span></span></span></span>
    worst case (with duplicates) vs <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(log⁡N)O(\log N)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                      style="margin-right: 0.1667em;"></span><span
            class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mclose">)</span></span></span></span></span>
    best case complexity (without duplicates).</p>
<ul>
    <li>Space complexity : <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord">1</span><span class="mclose">)</span></span></span></span></span>.
    </li>
</ul>
</body>
</html>