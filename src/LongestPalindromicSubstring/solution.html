<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Longest Palindromic Substring</title>
</head>
<body>
<h2 id="solution">Solution</h2>
<hr>
<h4 id="overview">Overview</h4>
<h4 id="approach-1-check-all-substrings">Approach 1: Check All Substrings</h4>
<p><strong>Intuition</strong></p>
<p>We can start with a brute-force approach. We will simply check if each substring is a palindrome, and take the
    longest one that is.</p>
<p>First, let's talk about how we can check if a given string is a palindrome. This is a classic problem and we can do
    it using two pointers. If a string is a palindrome, the first character is equal to the last character. The second
    character is equal to the second last character, and so on.</p>
<p><img src="1.png" alt="Palindrome Check"></p>
<p>We initialize two pointers: one at the start of the string and another at the end of it. We check if the characters
    at the pointers are equal - if they aren't, we know the string cannot be a palindrome. If they are equal, we move to
    the next pair of characters by moving the pointers toward each other. We continue until we either find a mismatch or
    the pointers meet. If the pointers meet, then we have checked all pairs and we know the string is a palindrome.</p>
<p>One bonus to using this algorithm is that we frequently exit early on strings that are not palindromes. If you had a
    string of length <code>1000</code> and the third and third last characters did not match, we would exit the
    algorithm after only 3 iterations.</p>
<p>There's another optimization that we can do. Because the problem wants the longest palindrome, we can start by
    checking the longest-length substrings and iterate toward the shorter-length substrings. This way, the first time we
    find a substring that is a palindrome, we can immediately return it as the answer.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Create a helper method <code>check(i, j)</code> to determine if a substring is a palindrome.
        <ul>
            <li>To save space, we will not pass the substring itself. Instead, we will pass two indices that represent
                the substring in question. The first character will be <code>s[i]</code> and the last character will be
                <code>s[j - 1]</code>.
            </li>
            <li>In this function, declare two pointers <code>left = i</code> and <code>right = j - 1</code>.</li>
            <li>While <code>left &lt; right</code>, do the following steps:</li>
            <li>If <code>s[left] != s[right]</code>, return <code>false</code>.</li>
            <li>Otherwise, increment <code>left</code> and decrement <code>right</code>.</li>
            <li>If we get through the while loop, return <code>true</code>.</li>
        </ul>
    </li>
    <li>Use a for loop to iterate a variable <code>length</code> starting from <code>s.length</code> until
        <code>1</code>. This variable represents the length of the substrings we are currently considering.
    </li>
    <li>Use a for loop to iterate a variable <code>start</code> starting from <code>0</code> until and including <code>s.length
        - length</code>. This variable represents the starting point of the substring we are currently considering.
    </li>
    <li>In each inner loop iteration, we are considering the substring starting at <code>start</code> until <code>start
        + length</code>. Pass these values into <code>check</code> to see if this substring is a palindrome. If it is,
        return the substring.
    </li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public String longestPalindrome(String s) {
        for (int length = s.length(); length > 0; length--) {
            for (int start = 0; start <= s.length() - length; start++) {
                if (check(start, start + length, s)) {
                    return s.substring(start, start + length);
                }
            }
        }

        return "";
    }

    private boolean check(int i, int j, String s) {
        int left = i;
        int right = j - 1;

        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }

            left++;
            right--;
        }

        return true;
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def longestPalindrome(self, s: str) -> str:
        def check(i, j):
            left = i
            right = j - 1

            while left < right:
                if s[left] != s[right]:
                    return False

                left += 1
                right -= 1

            return True

        for length in range(len(s), 0, -1):
            for start in range(len(s) - length + 1):
                if check(start, start + length):
                    return s[start:start + length]

        return ""
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n3)O(n^3)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">3</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>The two nested for loops iterate <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span> times. We check one substring of length
            <code>n</code>, two substrings of length <code>n - 1</code>, three substrings of length <code>n - 2</code>,
            and so on.</p>
        <p>There are <code>n</code> substrings of length 1, but we don't check them all since any substring of length 1
            is a palindrome, and we will return immediately.</p>
        <p>Therefore, the number of substrings that we check in the worst case is <code>1 + 2 + 3 + ... + n - 1</code>.
            This is the partial sum of <a
                    href="https://en.wikipedia.org/wiki/1_%2B_2_%2B_3_%2B_4_%2B_%E2%8B%AF#Partial_sums" target="_blank">this
                series</a> for <code>n - 1</code>, which is equal to <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">n⋅(n−1)2=O(n2)\frac{n \cdot (n - 1)}{2} = O(n^2)</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.355em; vertical-align: -0.345em;"></span><span
                    class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span
                    class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span
                    style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span
                    style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line"
                                                                                                 style="border-bottom-width: 0.04em;"></span></span><span
                    style="top: -3.485em;"><span class="pstrut" style="height: 3em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span
                    class="mord mathnormal mtight">n</span><span class="mbin mtight">⋅</span><span class="mopen mtight">(</span><span
                    class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span
                    class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span
                    class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
                                                                               style="height: 0.345em;"><span></span></span></span></span></span><span
                    class="mclose nulldelimiter"></span></span><span class="mspace"
                                                                     style="margin-right: 0.2778em;"></span><span
                    class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span>.</p>
        <p>In each iteration of the while loop, we perform a palindrome check. The cost of this check is linear with
            <code>n</code> as well, giving us a time complexity of <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n3)O(n^3)</span><span class="katex-html"
                                                                                     aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">3</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span>.</p>
        <p>Note that this time complexity is in the worst case and has a significant constant divisor that is dropped by
            big O. Due to the optimizations of checking the longer length substrings first and exiting the palindrome
            check early if we determine that a substring cannot be a palindrome, the practical runtime of this algorithm
            is not too bad.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord">1</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We don't count the answer as part of the space complexity. Thus, all we use are a few integer variables.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-2-dynamic-programming">Approach 2: Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<p>Let's say that we knew the substring with inclusive bounds <code>i, j</code> was a palindrome. If <code>s[i - 1] ==
    s[j + 1]</code>, then we know the substring with inclusive bounds <code>i - 1, j + 1</code> must also be a
    palindrome, and this check can be done in constant time.</p>
<p>We can flip the direction of this logic as well - if <code>s[i] == s[j]</code> and the substring <code>i + 1, j -
    1</code> is a palindrome, then the substring <code>i, j</code> must also be a palindrome.</p>
<p><img src="2.png" alt="DP Example"></p>
<p>We know that all substrings of length 1 are palindromes. From this, we can check if each substring of length 3 is a
    palindrome using the above fact. We just need to check every <code>i, j</code> pair where <code>j - i = 2</code>.
    Once we know all palindromes of length 3, we can use that information to find all palindromes of length 5, and then
    7, and so on.</p>
<p>What about even-length palindromes? A substring of length 2 is a palindrome if both characters are equal. That is,
    <code>i, i + 1</code> is a palindrome if <code>s[i] == s[i + 1]</code>. From this, we can use the earlier logic to
    find all palindromes of length 4, then 6, and so on.</p>
<p>Let's use a table <code>dp</code> with dimensions of <code>n * n</code>. <code>dp[i][j]</code> is a boolean
    representing if the substring with inclusive bounds <code>i, j</code> is a palindrome. We initialize <code>dp[i][i]
        = true</code> for the substrings of length 1, and then <code>dp[i][i + 1] = (s[i] == s[i + 1])</code> for the
    substrings of length 2.</p>
<p>Now, we need to populate the table. We iterate over all <code>i, j</code> pairs, starting with pairs that have a
    difference of 2 (representing substrings of length 3), then pairs with a difference of 3, then 4, and so on. For
    each <code>i, j</code> pair, we check the condition from earlier:</p>
<p><code>s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code></p>
<p>If this condition is true, then the substring with inclusive bounds <code>i, j</code> must be a palindrome. We set
    <code>dp[i][j] = true</code>.</p>
<p>Because we are starting with the shortest substrings and iterating toward the longest substrings, every time we find
    a new palindrome, it must be the longest one we have seen so far. We can use this fact to keep track of the answer
    on the fly.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>
        <p>Initialize <code>n = s.length</code> and a boolean table <code>dp</code> with size <code>n * n</code>, and
            all values to <code>false</code>.</p>
    </li>
    <li>
        <p>Initialize <code>ans = [0, 0]</code>. This will hold the inclusive bounds of the answer.</p>
    </li>
    <li>
        <p>Set all <code>dp[i][i] = true</code>.</p>
    </li>
    <li>
        <p>Iterate over all pairs <code>i, i + 1</code>. For each one, if <code>s[i] == s[i + 1]</code>, then set <code>dp[i][i
            + 1] = true</code> and update <code>ans = [i, i + 1]</code>.</p>
    </li>
    <li>
        <p>Now, we populate the <code>dp</code> table. Iterate over <code>diff</code> from <code>2</code> until
            <code>n</code>. This variable represents the difference <code>j - i</code>.</p>
    </li>
    <li>
        <p>In a nested for loop, iterate over <code>i</code> from <code>0</code> until <code>n - diff</code>.</p>
        <ul>
            <li>Set <code>j = i + diff</code>.</li>
            <li>Check the condition: if <code>s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]</code>, we found a palindrome.
            </li>
            <li>In that case, set <code>dp[i][j] = true</code> and <code>ans = [i, j]</code></li>
        </ul>
    </li>
    <li>
        <p>Retrieve the answer bounds from <code>ans</code> as <code>i, j</code>. Return the substring of <code>s</code>
            starting at index <code>i</code> and ending with index <code>j</code>.</p>
    </li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public String longestPalindrome(String s) {
        int n = s.length();
        boolean[][] dp = new boolean[n][n];
        int[] ans = new int[]{0, 0};

        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }

        for (int i = 0; i < n - 1; i++) {
            if (s.charAt(i) == s.charAt(i + 1)) {
                dp[i][i + 1] = true;
                ans[0] = i;
                ans[1] = i + 1;
            }
        }

        for (int diff = 2; diff < n; diff++) {
            for (int i = 0; i < n - diff; i++) {
                int j = i + diff;
                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    ans[0] = i;
                    ans[1] = j;
                }
            }
        }

        int i = ans[0];
        int j = ans[1];
        return s.substring(i, j + 1);
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def longestPalindrome(self, s: str) -> str:
        n = len(s)
        dp = [[False] * n for _ in range(n)]
        ans = [0, 0]

        for i in range(n):
            dp[i][i] = True

        for i in range(n - 1):
            if s[i] == s[i + 1]:
                dp[i][i + 1] = True
                ans = [i, i + 1]

        for diff in range(2, n):
            for i in range(n - diff):
                j = i + diff
                if s[i] == s[j] and dp[i + 1][j - 1]:
                    dp[i][j] = True
                    ans = [i, j]

        i, j = ans
        return s[i:j + 1]
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We declare an <code>n * n</code> table <code>dp</code>, which takes <span class="math math-inline"><span
                class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html"
                                                                                 aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span> time. We then populate <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span> states <code>i, j</code> - each state takes <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord">1</span><span class="mclose">)</span></span></span></span></span> time to compute.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>The table <code>dp</code> takes <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span> space.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-3-expand-from-centers">Approach 3: Expand From Centers</h4>
<p><strong>Intuition</strong></p>
<p>In the first approach, the palindrome check cost <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                 style="margin-right: 0.02778em;">O</span><span
        class="mopen">(</span><span class="mord mathnormal">n</span><span
        class="mclose">)</span></span></span></span></span>. In the second approach, the palindrome check cost <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span
        class="mclose">)</span></span></span></span></span>. This allowed us to improve the time complexity from <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">O(n3)O(n^3)</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span
        class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span
        class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                                                         style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span
        class="mord mtight">3</span></span></span></span></span></span></span></span><span
        class="mclose">)</span></span></span></span></span> to <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
        class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                      style="margin-right: 0.02778em;">O</span><span
        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span
        class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span
        class="mord mtight">2</span></span></span></span></span></span></span></span><span
        class="mclose">)</span></span></span></span></span>.</p>
<p>The problem with the second approach is that we <strong>always</strong> iterated over <span class="math math-inline"><span
        class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span
        class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span
        class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                                                         style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span
        class="mord mtight">2</span></span></span></span></span></span></span></span><span
        class="mclose">)</span></span></span></span></span> states of <code>i, j</code>. Can we optimize further to
    minimize the number of iterations required?</p>
<p>In the first approach, we implemented a palindrome check using two pointers. We started by checking the first and
    last characters, then the second and second last characters, and so on.</p>
<p>Instead of starting the pointers at the edges and moving inwards, the same logic can be applied when starting the
    pointers at the center and moving outwards. A palindrome mirrors around its center. Let's say you had <code>s =
        "racecar"</code>. If we start both pointers at the middle (<code>"e"</code>) and move them away from each other,
    we can see that at every iteration, the characters match: <code>e -&gt; c -&gt; a -&gt; r</code>.</p>
<p>The previous two approaches focused on the bounds of a substring - <code>i, j</code>. There are <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span
        class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span
        class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                                                         style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span
        class="mord mtight">2</span></span></span></span></span></span></span></span><span
        class="mclose">)</span></span></span></span></span> bounds, but only <span class="math math-inline"><span
        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
        class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> centers. For each
    index <code>i</code>, we can consider odd-length palindromes by starting the pointers at <code>i, i</code>. To
    consider the even length palindromes, we can start the pointers at <code>i, i + 1</code>. There are <span
            class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                   aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">n</span></span></span></span></span> starting points for the odd-length palindromes
    and <span class="math math-inline"><span class="katex"><span class="katex-mathml">n−1n - 1</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.6667em; vertical-align: -0.0833em;"></span><span
            class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
            class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>
    starting points for the even-length palindromes - that's <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">2n−1=O(n)2n - 1 = O(n)</span><span class="katex-html" aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span
            class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace"
                                                                             style="margin-right: 0.2222em;"></span><span
            class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span
            class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace"
                                                                                                   style="margin-right: 0.2778em;"></span></span><span
            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> starting points in
    total.</p>
<p>This is very promising - we can lower the minimum iterations required if we focus on the centers instead of on the
    bounds. Let's use a helper method <code>expand(i, j)</code> that starts two pointers <code>left = i</code> and
    <code>right = j</code>. In this method, we will consider <code>i, j</code> as a center. When <code>i == j</code>, we
    are considering odd-length palindromes. When <code>i != j</code>, we are considering even-length palindromes. We
    will expand from the center as far as we can to find the longest palindrome, and then return the length of this
    palindrome.</p>
<p>Let's say that we have a center <code>i, i</code>. We call <code>expand</code> and find a length of
    <code>length</code>. What are the bounds of the palindrome? Because we are centered at <code>i, i</code>, it means
    <code>length</code> must be odd. If we perform floor division of <code>length</code> by 2, we will get the number of
    characters <code>dist</code> on each side of the palindrome. For example, given <code>s = "racecar"</code>, we have
    <code>length = 7</code> and <code>dist = 7 / 2 = 3</code>. There are 3 characters on each side - <code>"rac"</code>
    on the left and <code>"car"</code> on the right. Therefore, we can determine that the bounds of the palindrome are
    <code>i - dist, i + dist</code>.</p>
<p>What about a center at <code>i, i + 1</code>? <code>length</code> must be even now. If we have a palindrome with
    length <code>2</code>, then <code>length / 2 = 1</code>, but there are zero characters on each side of the center.
    We can see that <code>dist</code> is too large by 1. Therefore, we will calculate <code>dist</code> as <code>(length
        / 2) - 1</code> instead. Now, <code>dist</code> correctly represents the number of characters on each side. The
    bounds of the palindrome are <code>i - dist, i + 1 + dist</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Create a helper method <code>expand(i, j)</code> to find the length of the longest palindrome centered at <code>i,
        j</code>.
        <ul>
            <li>Set <code>left = i</code> and <code>right = j</code>.</li>
            <li>While <code>left</code> and <code>right</code> are both in bounds and <code>s[left] == s[right]</code>,
                move the pointers away from each other.
            </li>
            <li>The formula for the length of a substring starting at <code>left</code> and ending at <code>right</code>
                is <code>right - left + 1</code>.
            </li>
            <li>However, when the while loop ends, it implies <code>s[left] != s[right]</code>. Therefore, we need to
                subtract <code>2</code>. Return <code>right - left - 1</code>.
            </li>
        </ul>
    </li>
    <li>Initialize <code>ans = [0, 0]</code>. This will hold the inclusive bounds of the answer.</li>
    <li>Iterate <code>i</code> over all indices of <code>s</code>.
        <ul>
            <li>Find the length of the longest odd-length palindrome centered at <code>i</code>: <code>oddLength =
                expand(i, i)</code>.
            </li>
            <li>If <code>oddLength</code> is the greatest length we have seen so far, i.e. <code>oddLength &gt; ans[1] -
                ans[0] + 1</code>, update <code>ans</code>.
            </li>
            <li>Find the length of the longest odd-length palindrome centered at <code>i</code>: <code>evenLength =
                expand(i, i + 1)</code>.
            </li>
            <li>If <code>evenLength</code> is the greatest length we have seen so far, update <code>ans</code>.</li>
        </ul>
    </li>
    <li>Retrieve the answer bounds from <code>ans</code> as <code>i, j</code>. Return the substring of <code>s</code>
        starting at index <code>i</code> and ending with index <code>j</code>.
    </li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public String longestPalindrome(String s) {
        int[] ans = new int[]{0, 0};

        for (int i = 0; i < s.length(); i++) {
            int oddLength = expand(i, i, s);
            if (oddLength > ans[1] - ans[0] + 1) {
                int dist = oddLength / 2;
                ans[0] = i - dist;
                ans[1] = i + dist;
            }

            int evenLength = expand(i, i + 1, s);
            if (evenLength > ans[1] - ans[0] + 1) {
                int dist = (evenLength / 2) - 1;
                ans[0] = i - dist;
                ans[1] = i + 1 + dist;
            }
        }

        int i = ans[0];
        int j = ans[1];
        return s.substring(i, j + 1);
    }

    private int expand(int i, int j, String s) {
        int left = i;
        int right = j;

        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }

        return right - left - 1;
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def longestPalindrome(self, s: str) -> str:
        def expand(i, j):
            left = i
            right = j

            while left >= 0 and right < len(s) and s[left] == s[right]:
                left -= 1
                right += 1

            return right - left - 1

        ans = [0, 0]

        for i in range(len(s)):
            odd_length = expand(i, i)
            if odd_length > ans[1] - ans[0] + 1:
                dist = odd_length // 2
                ans = [i - dist, i + dist]

            even_length = expand(i, i + 1)
            if even_length > ans[1] - ans[0] + 1:
                dist = (even_length // 2) - 1
                ans = [i - dist, i + 1 + dist]

        i, j = ans
        return s[i:j + 1]
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>There are <span class="math math-inline"><span class="katex"><span class="katex-mathml">2n−1=O(n)2n - 1 = O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 0.7278em; vertical-align: -0.0833em;"></span><span
                class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace"
                                                                                 style="margin-right: 0.2222em;"></span><span
                class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span><span
                class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace"
                                                                                                       style="margin-right: 0.2778em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> centers. For
            each center, we call <code>expand</code>, which costs up to <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
        <p>Although the time complexity is the same as in the DP approach, the average/practical runtime of the
            algorithm is much faster. This is because most centers will not produce long palindromes, so most of the
            <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> calls to
            <code>expand</code> will cost far less than <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                    class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
            iterations.</p>
        <p>The worst case scenario is when every character in the string is the same.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord">1</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We don't use any extra space other than a few integers. This is a big improvement on the DP approach.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-4-manachers-algorithm">Approach 4: Manacher's Algorithm</h4>
<p>Believe it or not, this problem can be solved in linear time.</p>
<p><a href="https://en.wikipedia.org/wiki/Longest_palindromic_substring#Manacher's_algorithm" target="_blank">Manacher's
    algorithm</a> finds the longest palindromic substring in <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                 style="margin-right: 0.02778em;">O</span><span
        class="mopen">(</span><span class="mord mathnormal">n</span><span
        class="mclose">)</span></span></span></span></span> time and space.</p>
<p>Note: this algorithm is completely out of scope for coding interviews. Because of this, we will not be talking about
    the algorithm in detail. This approach has been included for the sake of completeness and for those who are curious
    about algorithms beyond the scope of interviews.</p>
<p>If you wish to learn more about Manacher's algorithm, please reference the above link.</p>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public String longestPalindrome(String s) {
        StringBuilder sPrime = new StringBuilder("#");
        for (char c: s.toCharArray()) {
            sPrime.append(c).append("#");
        }

        int n = sPrime.length();
        int[] palindromeRadii = new int[n];
        int center = 0;
        int radius = 0;

        for (int i = 0; i < n; i++) {
            int mirror = 2 * center - i;

            if (i < radius) {
                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);
            }

            while (i + 1 + palindromeRadii[i] < n &&
                   i - 1 - palindromeRadii[i] >= 0 &&
                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {
                palindromeRadii[i]++;
            }

            if (i + palindromeRadii[i] > radius) {
                center = i;
                radius = i + palindromeRadii[i];
            }
        }

        int maxLength = 0;
        int centerIndex = 0;
        for (int i = 0; i < n; i++) {
            if (palindromeRadii[i] > maxLength) {
                maxLength = palindromeRadii[i];
                centerIndex = i;
            }
        }

        int startIndex = (centerIndex - maxLength) / 2;
        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);

        return longestPalindrome;
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def longestPalindrome(self, s: str) -> str:
        s_prime = '#' + '#'.join(s) + '#'
        n = len(s_prime)
        palindrome_radii = [0] * n
        center = radius = 0

        for i in range(n):
            mirror = 2 * center - i

            if i < radius:
                palindrome_radii[i] = min(radius - i, palindrome_radii[mirror])

            while (i + 1 + palindrome_radii[i] < n and
                   i - 1 - palindrome_radii[i] >= 0 and
                   s_prime[i + 1 + palindrome_radii[i]] == s_prime[i - 1 - palindrome_radii[i]]):
                palindrome_radii[i] += 1

            if i + palindrome_radii[i] > radius:
                center = i
                radius = i + palindrome_radii[i]

        max_length = max(palindrome_radii)
        center_index = palindrome_radii.index(max_length)
        start_index = (center_index - max_length) // 2
        longest_palindrome = s[start_index: start_index + max_length]

        return longest_palindrome
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p>From Wikipedia (the implementation they describe is slightly different from the above code, but it's the same
            algorithm):</p>
        <blockquote>
            <p>The algorithm runs in linear time. This can be seen by noting that Center strictly increases after each
                outer loop and the sum Center + Radius is non-decreasing. Moreover, the number of operations in the
                first inner loop is linear in the increase of the sum Center + Radius while the number of operations in
                the second inner loop is linear in the increase of Center. Since Center <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">≤\leq</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.7719em; vertical-align: -0.136em;"></span><span
                        class="mrel">≤</span></span></span></span></span> 2n+1 and Radius <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">≤\leq</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.7719em; vertical-align: -0.136em;"></span><span
                        class="mrel">≤</span></span></span></span></span> n, the total number of operations in the first
                and second inner loops is <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                and the total number of operations in the outer loop, other than those in the inner loops, is also <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
                The overall running time is therefore <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
            </p>
        </blockquote>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p>We use <code>sPrime</code> and <code>palindromeRadii</code>, both of length <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
    </li>
</ul>
<br>
<hr>
</body>
</html>