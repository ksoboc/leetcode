<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Maximum Score of a Good Subarray - Solution</title>
</head>
<body>
<h2 id="solution">Maximum Score of a Good Subarray - Solution</h2>
<hr>
<h4 id="approach-1-binary-search">Approach 1: Binary Search</h4>
<p><strong>Intuition</strong></p>
<p>The score of a subarray is its length multiplied by its minimum element. In this problem, we must find the maximum
    score of all subarrays that contain <code>nums[k]</code>.</p>
<p>How can we improve our score? When we take more elements we increase the length of the subarray, which helps the
    score. However, we may find new minimums, which would decrease our score.</p>
<p>We can start by separating the array - numbers to the left of <code>k</code> and numbers to the right of
    <code>k</code> (and including <code>k</code>).</p>
<p><img src="1.png" alt="img"><br>
    <br></p>
<p>Notice that <code>k</code> is the meeting point of these sections. If we want to take elements in the left section,
    we start from the end of the left section and move toward the beginning. If we want to take elements in the right
    section, we start from the beginning and move toward the end.</p>
<p>Of course, each element we take will increase our length by <code>1</code>. But how will it affect our minimum? To
    compute this quickly, we can create new arrays for each section. These arrays will represent the minimum element we
    have seen in the section if we started from <code>k</code>.</p>
<p><img src="2.png" alt="img"><br>
    <br></p>
<p>In the above example, let's say that we took two elements from the left section. We can quickly see that the minimum
    element from the left section is <code>3</code> using these arrays. Similarly, if we took all elements from the
    right section, we could quickly see that the minimum element from the right section is <code>4</code>.</p>
<blockquote>
    <p>We will call these arrays that allow us to find the minimums <code>left</code> and <code>right</code>.</p>
</blockquote>
<p>Now that we have these arrays, how can we solve the problem? Because <code>nums[k]</code> is in the right section, we
    will iterate over the entire right section and try to take each element. Let's say we take some number of elements
    from the right section, and the minimum is <code>x</code>. How many elements can we take from the left section
    without changing <code>x</code> as the minimum? We must only take elements from the left that are greater than or
    equal to <code>x</code>.</p>
<p>Let's switch to another example. For a given array, assuming we have already built the <code>left</code> and <code>right</code>
    arrays using the previous method.</p>
<p><img src="3.png" alt="img"><br>
    <br></p>
<p>In the above example, let's say that we take four elements from the right section. The minimum is <code>5</code>. How
    many elements can we take from the left section without changing the minimum? Two. This gives us a total size of
    <code>4 + 2 = 6</code>, and a total score of <code>6 * 5 = 30</code>.</p>
<p>How do we quickly find the number of elements we can take from the left section? Note that when we are building the
    array <code>left</code> from right to left, each time we go left we encounter a new number that is only likely to
    lower the minimum value, and the further to the left we go, the smaller the minimum value becomes, i.e.,
    <code>left</code> is already sorted from smallest to largest. Therefore, we can perform a binary search to identify
    how many elements we can take.</p>
<p>This brings us to our solution. We iterate with <code>j</code> over each index of <code>right</code> and assign
    <code>currMin = right[j]</code>, which represents the minimum of our subarray. We then perform a binary search to
    find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code>. Once we have <code>i</code>,
    we can calculate the size of our subarray, and thus the score. We take the maximum of all scores.</p>
<p>How do we calculate the size of our subarray given <code>i</code> and <code>j</code>?</p>
<p><img src="4.png" alt="img"><br>
    <br></p>
<p>Because the right section starts at index <code>k</code>, its indices are offset by <code>k</code> from the real
    indices. Thus, in the original array, <code>right[j]</code> points to index <code>k + j</code>. The left section is
    not offset at all, so <code>i</code> is correctly positioned. The size of a subarray bounded by <code>[left,
        right]</code> is <code>right - left + 1</code>. Thus, the size of our subarray <code>[i, k + j]</code> is <code>(k
        + j) - i + 1</code>. We can multiply this by <code>right[j]</code> to calculate our score.</p>
<p>You may have noticed: this algorithm assumes that in the optimal subarray, the minimum value is in the right section.
    But what if this assumption is wrong, and its actually in the left section? We can check the left section by simply
    reversing the array and then applying the same algorithm to it. Note that when we reverse the array, <code>k</code>
    will change. After reversal, the original <code>k</code> will be at <code>nums.length - k - 1</code>.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Define a function <code>solve(nums, k)</code> that runs our algorithm:
        <ul>
            <li>Set <code>n = nums.length</code>, <code>left</code> to an array of length <code>k</code>, and <code>currMin</code>
                to a large value.
            </li>
            <li>Iterate <code>i</code> from <code>k - 1</code> until <code>0</code>. At each index, update
                <code>currMin</code> with <code>nums[i]</code> if it is smaller and set <code>left[i] = currMin</code>.
            </li>
            <li>Initialize an empty array <code>right</code> and reset <code>currMin</code> to a large value.</li>
            <li>Iterate <code>i</code> from <code>k</code> until <code>n - 1</code>. At each index, update
                <code>currMin</code> with <code>nums[i]</code> if it is smaller and push <code>currMin</code> to <code>right</code>.
            </li>
            <li>Initialize <code>ans = 0</code>.</li>
            <li>Iterate <code>j</code> over the indices of <code>right</code>:
                <ul>
                    <li>Set <code>currMin = right[j]</code>.</li>
                    <li>Find <code>i</code>, the insertion index of <code>currMin</code> in <code>left</code> using
                        binary search.
                    </li>
                    <li>Calculate <code>size = (k + j) - i - 1</code>.</li>
                    <li>Update <code>ans</code> with <code>currMin * size</code> if it is larger.</li>
                </ul>
            </li>
            <li>Return <code>ans</code>.</li>
        </ul>
    </li>
    <li>Initialize <code>ans = solve(nums, k)</code>.</li>
    <li>Reverse <code>nums</code>.</li>
    <li>Return the larger of <code>ans, solve(nums, nums.length - k - 1)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public int maximumScore(int[] nums, int k) {
        int ans = solve(nums, k);
        for (int i = 0; i < nums.length / 2; i++) {
            int temp = nums[i];
            nums[i] = nums[nums.length - i - 1];
            nums[nums.length - i - 1] = temp;
        }

        return Math.max(ans, solve(nums, nums.length - k - 1));
    }

    public int solve(int[] nums, int k) {
        int n = nums.length;
        int left[] = new int[k];
        int currMin = Integer.MAX_VALUE;
        for (int i = k - 1; i >= 0; i--) {
            currMin = Math.min(currMin, nums[i]);
            left[i] = currMin;
        }

        List<Integer> right = new ArrayList();
        currMin = Integer.MAX_VALUE;
        for (int i = k; i < n; i++) {
            currMin = Math.min(currMin, nums[i]);
            right.add(currMin);
        }

        int ans = 0;
        for (int j = 0; j < right.size(); j++) {
            currMin = right.get(j);
            int i = binarySearch(left, currMin);
            int size = (k + j) - i + 1;
            ans = Math.max(ans, currMin * size);
        }

        return ans;
    }

    public int binarySearch(int[] nums, int num) {
        int left = 0;
        int right = nums.length;

        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return left;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        int ans = solve(nums, k);
        reverse(nums.begin(), nums.end());
        return max(ans, solve(nums, nums.size() - k - 1));
    }

    int solve(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> left(k, 0);
        int currMin = INT_MAX;
        for (int i = k - 1; i >= 0; i--) {
            currMin = min(currMin, nums[i]);
            left[i] = currMin;
        }

        vector<int> right;
        currMin = INT_MAX;
        for (int i = k; i < n; i++) {
            currMin = min(currMin, nums[i]);
            right.push_back(currMin);
        }

        int ans = 0;
        for (int j = 0; j < right.size(); j++) {
            currMin = right[j];
            int i = lower_bound(left.begin(), left.end(), currMin) - left.begin();
            int size = (k + j) - i + 1;
            ans = max(ans, currMin * size);
        }

        return ans;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        def solve(nums, k):
            n = len(nums)
            left = [0] * k
            curr_min = inf
            for i in range(k - 1, -1, -1):
                curr_min = min(curr_min, nums[i])
                left[i] = curr_min

            right = []
            curr_min = inf
            for i in range(k, n):
                curr_min = min(curr_min, nums[i])
                right.append(curr_min)

            ans = 0
            for j in range(len(right)):
                curr_min = right[j]
                i = bisect_left(left, curr_min)
                size = (k + j) - i + 1
                ans = max(ans, curr_min * size)

            return ans

        return max(solve(nums, k), solve(nums[::-1], len(nums) - k - 1))
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>nums</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅log⁡n)O(n \cdot \log{}n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                      style="margin-right: 0.1667em;"></span><span
                class="mord"></span><span class="mord mathnormal">n</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We require <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time to create
            <code>left</code> and <code>right</code>. Then, we iterate over the indices of <code>right</code>, which is
            not more than <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
            iterations. At each iteration, we perform a binary search over <code>left</code>, which does not cost more
            than <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(log⁡n)O(\log{}n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                              style="margin-right: 0.1667em;"></span><span
                    class="mord"></span><span class="mord mathnormal">n</span><span
                    class="mclose">)</span></span></span></span></span>. Thus, <code>solve</code> costs <span
                    class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n⋅log⁡n)O(n \cdot \log{}n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                              style="margin-right: 0.1667em;"></span><span
                    class="mord"></span><span class="mord mathnormal">n</span><span
                    class="mclose">)</span></span></span></span></span>, and we call it twice.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p><code>left</code> and <code>right</code> have a combined length of <span class="math math-inline"><span
                class="katex"><span class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>.
        </p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-2-monotonic-stack">Approach 2: Monotonic Stack</h4>
<p><strong>Intuition</strong></p>
<p>In this approach, we will use a similar idea as in the previous approach. For a given index <code>i</code>, if we
    treat <code>nums[i]</code> as the minimum element, we need to know how many elements we can take on the left and
    right such that we do not take any elements less than <code>nums[i]</code>.</p>
<blockquote>
    <p>You might be thinking: what if <code>nums[k]</code> is not included? We will get to that after presenting the
        full idea of the approach.</p>
</blockquote>
<p>Essentially, we need to know how far away the next lesser element is on both sides. If we have this information for
    all indices, we can quickly calculate the maximum score possible by treating every <code>nums[i]</code> as the
    minimum, since in the optimal solution, one of the indices must be the minimum.</p>
<p>There is a very similar problem called <a href="https://leetcode.com/problems/next-greater-element-i/"
                                             target="_blank">Next Greater Element</a>. The logic is identical, except
    that we are looking for the next smaller element. We can accomplish this using a monotonic stack.</p>
<details>
    <summary><b>If you aren't familiar with monotonic stacks, click here.</b></summary>
    <p>A monotonic stack is a stack whose elements are always sorted. In our case, we want a monotonic <strong>increasing</strong>
        stack, i.e. the elements in the stack are always sorted in ascending order.</p>
    <p>To maintain this monotonic stack, we need to make sure that whenever we push a new element, it is the largest
        value in the stack. Before we push an element <code>num</code>, we check the top of the stack. If the top of the
        stack is greater than <code>num</code>, we pop from it. Since there may be multiple elements greater than <code>num</code>
        in the stack, we need to use a while loop to "clean" the stack before pushing <code>num</code>.</p>
    <p>Only once there are no elements in the stack greater than <code>num</code> will we push <code>num</code>.</p>
</details>
<br>
<p>We will create an array <code>left</code>, where <code>left[i]</code> has the index of the first element to the left
    of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>Similarly, we will create an array <code>right</code> where <code>right[i]</code> has the index of the first element
    to the right of <code>i</code> that has a lower value in <code>nums</code> than <code>nums[i]</code>.</p>
<p>So how do we calculate <code>right</code>? Let's say that we are iterating over <code>nums</code> from the left and
    we have a chain of increasing numbers:</p>
<p><img src="5.png" alt="img"><br>
    <br></p>
<p>As you can see in the example, we have 6 increasing numbers, and then a <code>1</code> that is less than all of them.
    This <code>1</code> (at index 6) should be the value of <code>right</code> for all the indices of the increasing
    numbers. If we maintain a monotonic increasing stack, then this <code>1</code> will cause all those numbers to be
    popped out.</p>
<p>With a monotonic increasing stack, whenever we see an element that is smaller than the top of the stack, it is
    guaranteed to be the first smaller element for the element at the top of the stack. This is exactly what we are
    looking for.</p>
<p>To calculate <code>left</code>, we use the exact same process, except we iterate backward starting from the end of
    <code>nums</code>.</p>
<p>Note that because we need to remember what indices to update when we pop from the stack, we will store indices on the
    stack instead of the elements themselves. We can easily find the values by referencing <code>nums</code>.</p>
<p>We will initialize the values of <code>left</code> to <code>-1</code> and the values of <code>right</code> to
    <code>n</code>. This way, the math will still work out later if there are elements that do not have any lower values
    to the left or right.</p>
<p>Once we have <code>left</code> and <code>right</code>, we can iterate over all indices <code>i</code> and try to find
    a maximum score. Remember that the subarray must contain index <code>k</code>. Thus, we can only use an index <code>i</code>
    as the minimum if <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>.</p>
<p>When we treat an index <code>i</code> as the minimum, what score can we achieve? Our window starts one index after
    <code>left[i]</code> because including <code>left[i]</code> would create a new minimum. Similarly, our window ends
    one index before <code>right[i]</code>. Thus, we need to subtract <code>2</code> from the normal subarray size
    formula. This gives us a subarray size of <code>right[i] - left[i] - 1</code>. We multiply this size by <code>nums[i]</code>
    to get our score.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Initialize <code>n = nums.length</code>, <code>left</code> as an array of length <code>n</code> with values of
        <code>-1</code>, and an empty <code>stack</code>.
    </li>
    <li>Iterate <code>i</code> from <code>n - 1</code> until <code>0</code>:
        <ul>
            <li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>,
                pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the
                <code>stack</code>, set <code>left[j] = i</code>.
            </li>
            <li>Push <code>i</code> to <code>stack</code>.</li>
        </ul>
    </li>
    <li>Initialize <code>right</code> as an array of length <code>n</code> with values of <code>n</code> and reset
        <code>stack</code>.
    </li>
    <li>Iterate <code>i</code> over the indices of <code>nums</code>:
        <ul>
            <li>While the element at the index at the top of <code>stack</code> is greater than <code>nums[i]</code>,
                pop this index from <code>stack</code>. Given <code>j</code> as the index popped from the
                <code>stack</code>, set <code>right[j] = i</code>.
            </li>
            <li>Push <code>i</code> to <code>stack</code>.</li>
        </ul>
    </li>
    <li>Initialize <code>ans = 0</code>.</li>
    <li>Iterate <code>i</code> over the indices of <code>nums</code>:
        <ul>
            <li>If <code>left[i] &lt; k</code> and <code>right[i] &gt; k</code>, update <code>ans</code> with <code>nums[i]
                * (right[i] - left[i] - 1)</code> if it is larger.
            </li>
        </ul>
    </li>
    <li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int left[] = new int[n];
        Arrays.fill(left, -1);
        Stack<Integer> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {
                left[stack.pop()] = i;
            }

            stack.push(i);
        }

        int right[] = new int[n];
        Arrays.fill(right, n);
        stack = new Stack<>();

        for (int i = 0; i < n; i++) {
            while (!stack.isEmpty() && nums[stack.peek()] > nums[i]) {
                right[stack.pop()] = i;
            }

            stack.push(i);
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (left[i] < k && right[i] > k) {
                ans = Math.max(ans, nums[i] * (right[i] - left[i] - 1));
            }
        }

        return ans;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();
        vector<int> left(n, -1);
        vector<int> stack;

        for (int i = n - 1; i >= 0; i--) {
            while (!stack.empty() && nums[stack.back()] > nums[i]) {
                left[stack.back()] = i;
                stack.pop_back();
            }

            stack.push_back(i);
        }

        vector<int> right(n, n);
        stack.clear();
        for (int i = 0; i < n; i++) {
            while (!stack.empty() && nums[stack.back()] > nums[i]) {
                right[stack.back()] = i;
                stack.pop_back();
            }

            stack.push_back(i);
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            if (left[i] < k && right[i] > k) {
                ans = max(ans, nums[i] * (right[i] - left[i] - 1));
            }
        }

        return ans;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        left = [-1] * n
        stack = []

        for i in range(n - 1, -1, -1):
            while stack and nums[stack[-1]] > nums[i]:
                left[stack.pop()] = i

            stack.append(i)

        right = [n] * n
        stack = []
        for i in range(n):
            while stack and nums[stack[-1]] > nums[i]:
                right[stack.pop()] = i

            stack.append(i)

        ans = 0
        for i in range(n):
            if left[i] < k and right[i] > k:
                ans = max(ans, nums[i] * (right[i] - left[i] - 1))

        return ans
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>nums</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p>It costs <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> to calculate
            <code>left</code> and <code>right</code>. We iterate over each index once and perform amortized <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span> work at each
            iteration. The reason it amortizes to <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span>, despite the while
            loop, is because the while loop can run a maximum of <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 0.4306em;"></span><span
                    class="mord mathnormal">n</span></span></span></span></span> times across all iterations, and each
            index can only be pushed onto and popped from the stack once.</p>
        <p>To calculate <code>ans</code>, we iterate over the indices once and perform <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord">1</span><span class="mclose">)</span></span></span></span></span> work at each iteration.
        </p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p><code>left</code>, <code>right</code>, and <code>stack</code> all require <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-3-greedy">Approach 3: Greedy</h4>
<p><strong>Intuition</strong></p>
<p>Sometimes the simplest approach is the best! The optimal subarray must contain index <code>k</code>, so it makes
    sense to consider the subarray with only <code>nums[k]</code> as a starting point.</p>
<p>From here, how do we expand the subarray? We can either add an element to the left or an element to the right. Let's
    say we have two pointers, <code>left</code> and <code>right</code> that represent our subarray. Which direction
    should we go?</p>
<p>If we move left, it's equivalent to adding <code>nums[left - 1]</code> to our subarray. If we move right, it's
    equivalent to adding <code>nums[right + 1]</code> to our subarray. We should move in the direction of the greater
    element.</p>
<p>At each step, we update <code>currMin</code> which is initially set to <code>nums[k]</code>, and try to update <code>ans</code>
    which is also initially set to <code>nums[k]</code>. We can update <code>ans</code> with <code>currMin * (right -
        left + 1)</code> if it is larger.</p>
<p>This greedy process is very similar to the one used to solve <a
        href="https://leetcode.com/problems/container-with-most-water/" target="_blank">Container With Most Water</a>.
    But why does it work? We will use a proof by contradiction to demonstrate that not doing it this way wouldn't result
    in a higher value either.</p>
<p>At each step, we choose between having our subarray as <code>[left - 1, right]</code> or <code>[left, right +
    1]</code>. Let's assume that <code>nums[left - 1] &gt; nums[right + 1]</code> and the optimal subarray has not been
    found yet. The optimal subarray must include <code>nums[left - 1]</code>. If it doesn't, then it must include <code>nums[right
        + 1]</code>, since we could only move right to "avoid" <code>nums[left - 1]</code>. However, any subarray that
    includes <code>nums[right + 1]</code> could also include <code>nums[left - 1]</code> without affecting the minimum,
    while also increasing the length of the subarray and thus the score. Thus, it is impossible for the optimal subarray
    to include <code>nums[right + 1]</code> and not <code>nums[left - 1]</code>, and in general the optimal subarray
    must include <code>nums[left - 1]</code>.</p>
<p><strong>Algorithm</strong></p>
<p>To implement the while loop, we will iterate until we have exhausted the array. If one of the pointers is out of
    bounds, we will consider the element it points to as <code>0</code>.</p>
<ol>
    <li>Initialize <code>n = nums.length</code>, <code>left = k</code>, <code>right = k</code>, <code>ans =
        nums[k]</code>, and <code>currMin = nums[k]</code>.
    </li>
    <li>While <code>left &gt; 0</code> or <code>right &lt; n - 1</code>:
        <ul>
            <li>Compare <code>nums[left - 1]</code> with <code>nums[right + 1]</code>:
                <ul>
                    <li>If <code>nums[right + 1]</code> is greater, increment <code>right</code> and update <code>currMin</code>
                        with <code>nums[right]</code> if it is lower.
                    </li>
                    <li>Otherwise, decrement <code>left</code> and update <code>currMin</code> with
                        <code>nums[left]</code> if it is lower.
                    </li>
                </ul>
            </li>
            <li>Update <code>ans</code> with <code>currMin * (right - left + 1)</code> if it is greater.</li>
        </ul>
    </li>
    <li>Return <code>ans</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public int maximumScore(int[] nums, int k) {
        int n = nums.length;
        int left = k;
        int right = k;
        int ans = nums[k];
        int currMin = nums[k];

        while (left > 0 || right < n - 1) {
            if ((left > 0 ? nums[left - 1]: 0) < (right < n - 1 ? nums[right + 1] : 0)) {
                right++;
                currMin = Math.min(currMin, nums[right]);
            } else {
                left--;
                currMin = Math.min(currMin, nums[left]);
            }

            ans = Math.max(ans, currMin * (right - left + 1));
        }

        return ans;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int maximumScore(vector<int>& nums, int k) {
        int n = nums.size();
        int left = k;
        int right = k;
        int ans = nums[k];
        int currMin = nums[k];

        while (left > 0 || right < n - 1) {
            if ((left > 0 ? nums[left - 1]: 0) < (right < n - 1 ? nums[right + 1] : 0)) {
                right++;
                currMin = min(currMin, nums[right]);
            } else {
                left--;
                currMin = min(currMin, nums[left]);
            }

            ans = max(ans, currMin * (right - left + 1));
        }

        return ans;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def maximumScore(self, nums: List[int], k: int) -> int:
        n = len(nums)
        left = k
        right = k
        ans = nums[k]
        curr_min = nums[k]

        while left > 0 or right < n - 1:
            if (nums[left - 1] if left else 0) < (nums[right + 1] if right < n - 1 else 0):
                right += 1
                curr_min = min(curr_min, nums[right])
            else:
                left -= 1
                curr_min = min(curr_min, nums[left])

            ans = max(ans, curr_min * (right - left + 1))

        return ans
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>nums</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p>At each iteration, our <code>left</code> or <code>right</code> pointers move closer to the edges of the array
            by <code>1</code>. Thus, we perform <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
            iterations. Each iteration costs <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord">1</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We aren't using any extra space other than a few integers.</p>
    </li>
</ul>
<br>
<hr>
</body>
</html>