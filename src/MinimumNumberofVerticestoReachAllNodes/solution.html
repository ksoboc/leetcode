<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minimum Number of Vertices to Reach All Nodes - Solution</title>
</head>
<body>
<h2 id="solution">Solution</h2>
<hr>
<h4 id="approach-in-degree-count">Approach: In-Degree Count</h4>
<p><strong>Intuition</strong></p>
<p>We have <span class="math math-inline"><span class="katex"><span class="katex-mathml">NN</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 0.6833em;"></span><span
        class="mord mathnormal" style="margin-right: 0.10903em;">N</span></span></span></span></span> vertices connected
    via <span class="math math-inline"><span class="katex"><span class="katex-mathml">EE</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.05764em;">E</span></span></span></span></span>
    directed edges, and there is no cycle. We need to return the minimum set of vertices that are required so that all
    the vertices are reachable from these vertices.</p>
<p>Let's first find out the vertices we are sure won't be in the final set. Consider the below figure, there is a
    directed edge from vertex <code>a</code> to <code>b</code>; should vertex <code>b</code> be in the final answer set?
    No, if we include <code>a</code> we can reach <code>b</code> from it using this edge. Similarly, consider the edge
    <code>c -&gt; d</code>; the vertex <code>d</code> will also not be present in the answer as we can shrink the
    required vertices group from <code>{c, d}</code> to just <code>c</code> and then traverse to<code>d</code> from it.
</p>
<p><img src="1557A.png" alt="fig"></p>
<p>From this discussion, one thing is clear: any vertex that has an edge in-coming from some other vertex should not be
    part of the answer.</p>
<p>The next question concerns the vertices that don't have an incoming edge. Are these all required and will we need to
    include all of them, or will only a few be sufficient?</p>
<p>Let's try to answer the first question, are all those vertices that don't have an incoming edge required? If a vertex
    doesn't have any edge that ends on it, this implies there is no way to reach it from any other vertex. The only way
    to cover these vertices is to include them in the set. Hence, all vertices that have no in-coming edge or have the
    in-degree as <code>0</code> will be included in the answer.</p>
<p>The second question is, are these vertices enough? Will we be able to cover the remaining vertices using these
    vertices? Think of any vertex that we didn't include, this vertex would have at least one incoming edge, i.e.,
    instead of including it, we will consider including the vertices that can lead to this. All these vertices again
    have two possibilities; first, they don't have any incoming edge, in which case it would already be in our answer
    set, the second, they have an incoming edge in which we shouldn't include it. Hence, every vertex that has not been
    included; an edge from the included vertices can lead to it, and thus all vertices are reachable in this set of
    vertices.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Create a boolean list <code>isIncomingEdgeExists</code> of length <span class="math math-inline"><span
            class="katex"><span class="katex-mathml">NN</span><span class="katex-html" aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.10903em;">N</span></span></span></span></span>
        which store <code>true</code> if there is an incoming edge to it, false otherwise. Initialize it with every
        entry as <code>false</code>.
    </li>
    <li>Iterate over <code>edges</code>, and for every <code>edge</code>, mark the second vertex as <code>true</code> in
        the list <code>isIncomingEdgeExists</code>.
    </li>
    <li>Iterate over the list <code>isIncomingEdgeExists</code> and include all the vertices that have a
        <code>false</code> value in the final answer list <code>requiredNodes</code>.
    </li>
    <li>Return <code>requiredNodes</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
  public List<Integer> findSmallestSetOfVertices(int n, List<List<Integer>> edges) {
    // List to signify if the vertex has an incoming edge or not.
    boolean[] isIncomingEdgeExists = new boolean[n];
    for (List<Integer> edge : edges) {
      isIncomingEdgeExists[edge.get(1)] = true;
    }

    List<Integer> requiredNodes = new ArrayList();
    for (int i = 0; i < n; i++) {
      // Store all the nodes that don't have an incoming edge.
      if (!isIncomingEdgeExists[i]) {
        requiredNodes.add(i);
      }
    }

    return requiredNodes;
  }
}
    </code>
    C++
    <code>
        class Solution {
public:
    vector<int> findSmallestSetOfVertices(int n, vector<vector<int>>& edges) {
        // List to signify if the vertex has an incoming edge or not.
        vector<bool> isIncomingEdgeExists(n, false);
        for (vector<int>& edge : edges) {
            isIncomingEdgeExists[edge[1]] = true;
        }

        vector<int> requiredNodes;
        for (int i = 0; i < n; i++) {
            // Store all the nodes that don't have an incoming edge.
            if (!isIncomingEdgeExists[i]) {
                requiredNodes.push_back(i);
            }
        }

        return requiredNodes;
    }
};
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">NN</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal"
                                                                                style="margin-right: 0.10903em;">N</span></span></span></span></span>
    is the number of vertices and <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">EE</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal"
                                                                 style="margin-right: 0.05764em;">E</span></span></span></span></span>
    is the number of edges.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(N+E)O(N + E)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mspace"
                                                                                       style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.05764em;">E</span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <p>We first iterate over every one of <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">EE</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal"
                                                                     style="margin-right: 0.05764em;">E</span></span></span></span></span>
            edges to mark the vertex in the list <code>isIncomingEdgeExists</code>, then we iterate over the vertices to
            see if it's required or not. Hence, the total time complexity equals <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(N+E)O(N + E)</span><span class="katex-html"
                                                                                        aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span class="mspace"
                                                                                           style="margin-right: 0.2222em;"></span><span
                    class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.05764em;">E</span><span
                    class="mclose">)</span></span></span></span></span>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(N)O(N)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.10903em;">N</span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <p>The only space required is the list <code>isIncomingEdgeExists</code> of size <span class="math math-inline"><span
                class="katex"><span class="katex-mathml">NN</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal"
                                                                                        style="margin-right: 0.10903em;">N</span></span></span></span></span>
            to store if vertices have an incoming edge or not. The other list, <code>requiredNodes</code> is to store
            the output, which is not considered part of space complexity.<br>
            <br></p>
    </li>
</ul>
<hr>
</body>
</html>