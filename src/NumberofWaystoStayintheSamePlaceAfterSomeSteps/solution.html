<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Number of Ways to Stay in the Same Place After Some Steps - Solution</title>
</head>
<body>
<h2 id="solution">Number of Ways to Stay in the Same Place After Some Steps - Solution</h2>
<hr>
<h4 id="approach-1-top-down-dynamic-programming">Approach 1: Top-Down Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<blockquote>
    <p><strong>Note.</strong> For this approach, we assume that you already know the fundamentals of dynamic programming
        and are figuring out how to apply it to a wide range of problems, such as this one. If you are not yet at this
        stage, we recommend checking out our relevant <a
                href="https://leetcode.com/explore/featured/card/dynamic-programming/" target="_blank">Explore Card
            content on dynamic programming</a> before coming back to this problem.</p>
</blockquote>
<p>Let's imagine that we are positioned on a number line. This number line starts at <code>0</code> and ends at <code>arrLen
    - 1</code> (since <code>arrLen</code> is 0-indexed). We start at <code>0</code> on this number line, and on each
    move we are allowed to move left, right, or stay.</p>
<p>We start at <code>0</code>, need to make <code>steps</code> moves, and want to end up back at <code>0</code>. Without
    loss of generality, let's say we are currently at <code>curr</code> on the number line and need to make
    <code>remain</code> more moves. We have three options:</p>
<ol>
    <li>Don't move. We will stay at <code>curr</code> and need to make <code>remain - 1</code> more moves.</li>
    <li>Move left. We can only do this if <code>curr &gt; 0</code>. We move to <code>curr - 1</code> and need to make
        <code>remain - 1</code> more moves.
    </li>
    <li>Move right. We can only do this if <code>curr &lt; arrLen - 1</code>. We move to <code>curr + 1</code> and need
        to make <code>remain - 1</code> more moves.
    </li>
</ol>
<p>Let's define a function <code>dp(curr, remain)</code> that returns the number of ways we can arrive at <code>0</code>
    from <code>curr</code> after <code>remain</code> moves. If we want to go back to <code>0</code>, we can only do so
    through one of these three options. In other words, the number of ways to return to <code>0</code> from the current
    state is equivalent to the sum of the number of ways to return to <code>0</code> in the next three options. We have
    the following transitions:</p>
<ol>
    <li><code>dp(curr, remain) += dp(curr, remain - 1)</code></li>
    <li><code>dp(curr, remain) += dp(curr - 1, remain - 1) if curr &gt; 0</code></li>
    <li><code>dp(curr, remain) += dp(curr + 1, remain - 1) if curr &lt; arrLen - 1&gt;</code></li>
</ol>
<p>What will be the base case of this function? If <code>remain = 0</code>, we have no more moves to make. If <code>curr
    = 0</code>, then we have found a way to accomplish our task, so we <code>return 1</code>. Otherwise, we return
    <code>0</code>.</p>
<p>This recursive approach will solve the problem, but will have an exponential time complexity as each call to
    <code>dp</code> creates three more calls. Many states of <code>curr, remain</code> will be repeated. In the below
    tree, each node represents a call to <code>dp</code> with the first number being <code>curr</code> and the second
    one being <code>steps</code>. Nodes with the same color represent the same arguments. With larger values of <code>steps</code>
    and <code>arrLen</code>, the tree will quickly grow beyond what we can compute.</p>
<p><img src="1.png" alt="img"><br>
    <br></p>
<p>To prevent repeated computation, we will memoize the <code>dp</code> function. Using a data structure
    <code>memo</code>, the first time we find the answer for a state <code>curr, remain</code>, we will save it in
    <code>memo</code>. In the future when we see the same <code>curr, remain</code> state again, we can refer to <code>memo</code>
    instead of having to re-calculate. With memoization, the tree now looks like this:</p>
<p><img src="2.png" alt="img"><br>
    <br></p>
<p>If we want to use a 2D array to implement <code>memo</code>, we must be careful with the sizing. Notice in the
    constraints that while <code>steps</code> can be up to <code>500</code>, <code>arrLen</code> can be up to <span
            class="math math-inline"><span class="katex"><span class="katex-mathml">10610^6</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.8141em;"></span><span
            class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span
            class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
            style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mtight">6</span></span></span></span></span></span></span></span></span></span></span></span>.
    However, it is impossible for any call to have a value of <code>curr</code> greater than <code>steps</code>. The
    furthest we can go is by only making moves to the right, but we would run out of moves after <code>steps</code>
    moves. Thus, we can safely perform <code>arrLen = min(arrLen, steps)</code> before starting the algorithm.</p>
<p>The answer to the original problem is <code>dp(0, steps)</code>. We start at <code>0</code> and need to make <code>steps</code>
    moves.</p>
<p><strong>Algorithm</strong></p>
<p>All arithmetic operations should be done mod <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">109+710^9 + 7</span><span class="katex-html" aria-hidden="true"><span class="base"><span
        class="strut" style="height: 0.8974em; vertical-align: -0.0833em;"></span><span class="mord">1</span><span
        class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span
        class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                                                         style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span
        class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                           style="margin-right: 0.2222em;"></span><span
        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>.</p>
<ol>
    <li>Create a memoized function <code>dp(curr, remain)</code>:
        <ul>
            <li>If <code>remain == 0</code>:
                <ul>
                    <li>Return <code>1</code> if <code>curr == 0</code>, and <code>0</code> otherwise.</li>
                </ul>
            </li>
            <li>Initialize <code>ans = dp(curr, remain - 1)</code>.</li>
            <li>If <code>curr &gt; 0</code>, add <code>dp(curr - 1, remain - 1)</code> to <code>ans</code>.</li>
            <li>If <code>curr &lt; arrLen - 1</code>, add <code>dp(curr + 1, remain - 1)</code> to <code>ans</code>.
            </li>
            <li>Return <code>ans</code>.</li>
        </ul>
    </li>
    <li>Set <code>arrLen = min(arrLen, steps)</code>.</li>
    <li>Return <code>dp(0, steps)</code>.</li>
</ol>
<p>To memoize <code>dp</code>:</p>
<ol>
    <li>After the base case, check if <code>curr, remain</code> has already been calculated using a data structure
        <code>memo</code>.
        <ul>
            <li>If it has already been calculated, return the saved result.</li>
        </ul>
    </li>
    <li>Before returning <code>ans</code>, store <code>ans</code> in <code>memo</code> while associating it with <code>curr,
        remain</code>.
    </li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
    <p>In Python, we use <a href="https://docs.python.org/3/library/functools.html#functools.cache" target="_blank">@functools.cache</a>
        to memoize our function.</p>
</blockquote>
<pre>
    Java
    <code>
        class Solution {
    int[][] memo;
    int MOD = (int) 1e9 + 7;
    int arrLen;

    public int dp(int curr, int remain) {
        if (remain == 0) {
            if (curr == 0) {
                return 1;
            }

            return 0;
        }

        if (memo[curr][remain] != -1) {
            return memo[curr][remain];
        }

        int ans = dp(curr, remain - 1);
        if (curr > 0) {
            ans = (ans + dp(curr - 1, remain - 1)) % MOD;
        }

        if (curr < arrLen - 1) {
            ans = (ans + dp(curr + 1, remain - 1)) % MOD;
        }

        memo[curr][remain] = ans;
        return ans;
    }

    public int numWays(int steps, int arrLen) {
        arrLen = Math.min(arrLen, steps);
        this.arrLen = arrLen;
        memo = new int[arrLen][steps + 1];
        for (int[] row : memo) {
            Arrays.fill(row, -1);
        }

        return dp(0, steps);
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    vector<vector<int>> memo;
    int MOD = 1e9 + 7;
    int arrLen;

    int dp(int curr, int remain) {
        if (remain == 0) {
            if (curr == 0) {
                return 1;
            }

            return 0;
        }

        if (memo[curr][remain] != -1) {
            return memo[curr][remain];
        }

        int ans = dp(curr, remain - 1);
        if (curr > 0) {
            ans = (ans + dp(curr - 1, remain - 1)) % MOD;
        }

        if (curr < arrLen - 1) {
            ans = (ans + dp(curr + 1, remain - 1)) % MOD;
        }

        memo[curr][remain] = ans;
        return ans;
    }

    int numWays(int steps, int arrLen) {
        arrLen = min(arrLen, steps);
        this->arrLen = arrLen;
        memo = vector(arrLen, vector(steps + 1, -1));
        return dp(0, steps);
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        @cache
        def dp(curr, remain):
            if remain == 0:
                if curr == 0:
                    return 1

                return 0

            ans = dp(curr, remain - 1)
            if curr > 0:
                ans = (ans + dp(curr - 1, remain - 1)) % MOD

            if curr < arrLen - 1:
                ans = (ans + dp(curr + 1, remain - 1)) % MOD

            return ans

        MOD = 10 ** 9 + 7
        return dp(0, steps)
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as <code>steps</code> and <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as <code>arrLen</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span></p>
        <p>There can be <code>steps</code> values of <code>remain</code> and <code>min(steps, arrLen)</code> values of
            <code>curr</code>. The reason <code>curr</code> is limited by <code>steps</code> is because if we were to
            only move right, we would eventually run out of moves. Thus, there are <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mop">min</span><span class="mspace" style="margin-right: 0.1667em;"></span><span
                    class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                    class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                    class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span> states of
            <code>curr, remain</code>. Due to memoization, we never calculate a state more than once. To calculate a
            given state costs <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span> as we are simply
            adding up three options.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span></p>
        <p>The recursion call stack uses up to <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
            space, but this is dominated by <code>memo</code> which has a size of <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mop">min</span><span class="mspace" style="margin-right: 0.1667em;"></span><span
                    class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                    class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                    class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span>.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-2-bottom-up-dynamic-programming">Approach 2: Bottom-Up Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<p>The "answer state" is <code>curr = 0, remain = steps</code>. In the previous approach, we started by making a call to
    <code>dp(0, steps)</code> and made function calls down to the base case. In this approach, we will start at the base
    case and iterate toward the answer state.</p>
<p>To implement this iterative algorithm, we will convert <code>dp</code> from a function to an array. Here, <code>dp[curr][remain]</code>
    is analogous to <code>dp(curr, remain)</code> from the previous approach.</p>
<p>First, we need to size <code>dp</code>. The first dimension needs to be the range of <code>curr</code>. As the number
    line has a limit of <code>arrLen - 1</code>, the first dimension of <code>dp</code> should have a size of <code>arrLen</code>.
    As we mentioned briefly in the previous approach, the value of <code>arrLen</code> can be reduced to <code>min(arrLen,
        steps)</code>. Larger values of <code>arrLen</code> (greater than <code>steps</code>) are pointless because we
    could not reach those states due to running out of <code>steps</code>. The second dimension of <code>dp</code> needs
    to be the range of <code>remain</code>. As the maximum value of <code>remain</code> is <code>steps</code>, the
    second dimension of <code>dp</code> should have a size of <code>steps + 1</code>. Thus, dp will have a size of
    <code>arrLen * (steps + 1)</code> (after we update <code>arrLen = min(arrLen, steps)</code>).</p>
<p>Second, we need to initialize the base case. Assuming <code>dp</code> is initialized with values of <code>0</code>,
    the only non-zero base case is when <code>curr = 0, remain = 0</code>, the answer is <code>1</code>. Thus, we will
    set <code>dp[0][0] = 1</code>.</p>
<p>Third, we need to configure our for-loops. We will use nested for-loops to iterate over all states of <code>curr,
    remain</code>. We must iterate starting from the base case. Thus, our first loop will be over <code>remain</code>
    starting at <code>1</code> and ending at <code>steps</code>. Our second loop will be over <code>curr</code> starting
    at <code>arrLen - 1</code> and ending at <code>0</code>.</p>
<blockquote>
    <p>Generally, you want the final loop iteration to calculate the final answer. As our answer state is <code>curr =
        0, remain = steps</code>, we have the loop for <code>remain</code> end at <code>steps</code> and the loop for
        <code>curr</code> end at <code>0</code>.</p>
</blockquote>
<p>Finally, each inner loop iteration represents a state <code>curr, remain</code>. We will calculate its value <code>dp[curr][remain]</code>
    just like we did in the previous approach by considering the three options:</p>
<ol>
    <li>Don't move. Add <code>dp[curr][remain - 1]</code>.</li>
    <li>Move left. We can only do this if <code>curr &gt; 0</code>. Add <code>dp[curr - 1][remain - 1]</code>.</li>
    <li>Move right. We can only do this if <code>curr &lt; arrLen - 1</code>. Add <code>dp[curr + 1][remain - 1]</code>.
    </li>
</ol>
<p>The answer to the original problem is <code>dp[0][steps]</code>. We return this value at the end.</p>
<p><strong>Algorithm</strong></p>
<p>All arithmetic operations should be done mod <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">109+710^9 + 7</span><span class="katex-html" aria-hidden="true"><span class="base"><span
        class="strut" style="height: 0.8974em; vertical-align: -0.0833em;"></span><span class="mord">1</span><span
        class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span
        class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                                                         style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span
        class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                           style="margin-right: 0.2222em;"></span><span
        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>.</p>
<ol>
    <li>Set <code>arrLen = min(arrLen, steps)</code>.</li>
    <li>Create an array <code>dp[arrLen][steps + 1]</code>.</li>
    <li>Set <code>dp[0][0] = 1</code>, the base case.</li>
    <li>Iterate <code>remain</code> from <code>1</code> to <code>steps</code>:
        <ul>
            <li>Iterate <code>curr</code> from <code>arrLen - 1</code> to <code>0</code>:
                <ul>
                    <li>Initialize <code>ans = dp[curr][remain - 1]</code>.</li>
                    <li>If <code>curr &gt; 0</code>, add <code>dp[curr - 1][remain - 1]</code> to <code>ans</code>.</li>
                    <li>If <code>curr &lt; arrLen - 1</code>, add <code>dp[curr + 1][remain - 1]</code> to
                        <code>ans</code>.
                    </li>
                    <li>Set <code>dp[curr][remain] = ans</code>.</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Return <code>dp[0][steps]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public int numWays(int steps, int arrLen) {
        int MOD = (int) 1e9 + 7;
        arrLen = Math.min(arrLen, steps);
        int[][] dp = new int[arrLen][steps + 1];
        dp[0][0] = 1;

        for (int remain = 1; remain <= steps; remain++) {
            for (int curr = arrLen - 1; curr >= 0; curr--) {
                int ans = dp[curr][remain - 1];

                if (curr > 0) {
                    ans = (ans + dp[curr - 1][remain - 1]) % MOD;
                }

                if (curr < arrLen - 1) {
                    ans = (ans + dp[curr + 1][remain - 1]) % MOD;
                }

                dp[curr][remain] = ans;
            }
        }

        return dp[0][steps];
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int numWays(int steps, int arrLen) {
        int MOD = 1e9 + 7;
        arrLen = min(arrLen, steps);
        vector<vector<int>> dp(arrLen, vector(steps + 1, 0));
        dp[0][0] = 1;

        for (int remain = 1; remain <= steps; remain++) {
            for (int curr = arrLen - 1; curr >= 0; curr--) {
                int ans = dp[curr][remain - 1];

                if (curr > 0) {
                    ans = (ans + dp[curr - 1][remain - 1]) % MOD;
                }

                if (curr < arrLen - 1) {
                    ans = (ans + dp[curr + 1][remain - 1]) % MOD;
                }

                dp[curr][remain] = ans;
            }
        }

        return dp[0][steps];
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = 10 ** 9 + 7
        arrLen = min(arrLen, steps)
        dp = [[0] * (steps + 1) for _ in range(arrLen)]
        dp[0][0] = 1

        for remain in range(1, steps + 1):
            for curr in range(arrLen - 1, -1, -1):
                ans = dp[curr][remain - 1]

                if curr > 0:
                    ans = (ans + dp[curr - 1][remain - 1]) % MOD

                if curr < arrLen - 1:
                    ans = (ans + dp[curr + 1][remain - 1]) % MOD

                dp[curr][remain] = ans

        return dp[0][steps]
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as <code>steps</code> and <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as <code>arrLen</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span></p>
        <p>Our nested for-loops iterate over <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span class="katex-html"
                                                                                       aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span> states of <code>curr,
            remain</code>. Calculating each state is done in <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord">1</span><span
                class="mclose">)</span></span></span></span></span>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span></p>
        <p><code>dp</code> has a size of <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span>.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-3-space-optimized-dynamic-programming">Approach 3: Space-Optimized Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<p>You may notice that in the previous two approaches, to calculate a state <code>curr, remain</code>, we only needed
    states involving <code>remain - 1</code>. For example, if we wanted to calculate <code>dp[4][6]</code>, we only
    needed values of <code>dp[...][5]</code>. Values stored in <code>dp[...][4], dp[...][3], dp[...][2]</code>, etc. are
    no longer required.</p>
<p>As we iterate over <code>remain</code> using the outer for-loop, we only need to store values of <code>dp</code> for
    the current value of <code>remain</code> and the previous value <code>remain - 1</code>. We will use two arrays of
    size <code>arrLen</code> to do this: <code>dp</code> and <code>prevDp</code>.</p>
<p>Here, <code>dp[curr]</code> is analogous to <code>dp[curr][remain]</code> from the previous approach. <code>prevDp[curr]</code>
    is analogous to <code>dp[curr][remain - 1]</code> from the previous approach.</p>
<p>As the first value of <code>remain = 1</code>, this means initially, <code>prevDp</code> represents values for <code>remain
    = 0</code>. This means we must initialize <code>prevDp[0]</code>, as this is our base case <code>curr = 0, remain =
    0</code>.</p>
<p>At the beginning of each outer for-loop iteration, we will reset <code>dp</code>. We will then calculate
    <code>dp</code> using values from <code>prevDp</code>. Once we have finished calculating <code>dp</code>, we will
    update <code>prevDp = dp</code>, so that in the next iteration, <code>prevDp</code> will represent the correct
    values.</p>
<p>For example, when <code>remain = 5</code>:</p>
<ol>
    <li><code>dp[curr]</code> represents <code>dp[curr][5]</code> from the previous approach. We calculate it using
        <code>prevDp</code>, where <code>prevDp[curr]</code> represents <code>prevDp[curr][4]</code> from the previous
        approach.
    </li>
    <li>Once we finish calculating <code>dp</code>, the next for-loop iteration has <code>remain = 6</code>, and now
        <code>prevDp</code> must represent values of <code>remain = 5</code>.
    </li>
    <li>This is why we update <code>prevDp = dp</code>, since we just calculated <code>dp</code> to have the values for
        <code>remain = 5</code>.
    </li>
</ol>
<p>The final value we have in our for-loop over <code>remain</code> is <code>steps</code>. Thus, the final calculated
    <code>dp</code> will represent values for <code>remain = steps</code>. We can simply return <code>dp[0]</code>,
    which represents <code>dp[0][steps]</code> from the previous approach, our answer state.</p>
<p><strong>Algorithm</strong></p>
<p>All arithmetic operations should be done mod <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">109+710^9 + 7</span><span class="katex-html" aria-hidden="true"><span class="base"><span
        class="strut" style="height: 0.8974em; vertical-align: -0.0833em;"></span><span class="mord">1</span><span
        class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span
        class="vlist" style="height: 0.8141em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                                                         style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span
        class="mord mtight">9</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                           style="margin-right: 0.2222em;"></span><span
        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 0.6444em;"></span><span class="mord">7</span></span></span></span></span>.</p>
<ol>
    <li>Set <code>arrLen = min(arrLen, steps)</code>.</li>
    <li>Create an array <code>dp[arrLen]</code> and an array <code>prevDp[arrLen]</code>.</li>
    <li>Set <code>prevDp[0] = 1</code>, the base case.</li>
    <li>Iterate <code>remain</code> from <code>1</code> to <code>steps</code>:
        <ul>
            <li>Reset <code>dp</code>.</li>
            <li>Iterate <code>curr</code> from <code>arrLen - 1</code> to <code>0</code>:
                <ul>
                    <li>Initialize <code>ans = prevDp[curr]</code>.</li>
                    <li>If <code>curr &gt; 0</code>, add <code>prevDp[curr - 1]</code> to <code>ans</code>.</li>
                    <li>If <code>curr &lt; arrLen - 1</code>, add <code>prevDp[curr + 1]</code> to <code>ans</code>.
                    </li>
                    <li>Set <code>dp[curr] = ans</code>.</li>
                </ul>
            </li>
            <li>Update <code>prevDp = dp</code>.</li>
        </ul>
    </li>
    <li>Return <code>dp[0]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public int numWays(int steps, int arrLen) {
        int MOD = (int) 1e9 + 7;
        arrLen = Math.min(arrLen, steps);
        int[] dp = new int[arrLen];
        int[] prevDp = new int[arrLen];
        prevDp[0] = 1;

        for (int remain = 1; remain <= steps; remain++) {
            dp = new int[arrLen];

            for (int curr = arrLen - 1; curr >= 0; curr--) {
                int ans = prevDp[curr];
                if (curr > 0) {
                    ans = (ans + prevDp[curr - 1]) % MOD;
                }

                if (curr < arrLen - 1) {
                    ans = (ans + prevDp[curr + 1]) % MOD;
                }

                dp[curr] = ans;
            }

            prevDp = dp;
        }

        return dp[0];
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int numWays(int steps, int arrLen) {
        int MOD = 1e9 + 7;
        arrLen = min(arrLen, steps);
        vector<int> dp(arrLen, 0);
        vector<int> prevDp(arrLen, 0);
        prevDp[0] = 1;

        for (int remain = 1; remain <= steps; remain++) {
            dp = vector(arrLen, 0);

            for (int curr = arrLen - 1; curr >= 0; curr--) {
                int ans = prevDp[curr];

                if (curr > 0) {
                    ans = (ans + prevDp[curr - 1]) % MOD;
                }

                if (curr < arrLen - 1) {
                    ans = (ans + prevDp[curr + 1]) % MOD;
                }

                dp[curr] = ans;
            }

            prevDp = dp;
        }

        return dp[0];
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def numWays(self, steps: int, arrLen: int) -> int:
        MOD = 10 ** 9 + 7
        arrLen = min(arrLen, steps)
        dp = [0] * (arrLen)
        prevDp = [0] * (arrLen)
        prevDp[0] = 1

        for remain in range(1, steps + 1):
            dp = [0] * (arrLen)

            for curr in range(arrLen - 1, -1, -1):
                ans = prevDp[curr]

                if curr > 0:
                    ans = (ans + prevDp[curr - 1]) % MOD

                if curr < arrLen - 1:
                    ans = (ans + prevDp[curr + 1]) % MOD

                dp[curr] = ans

            prevDp = dp

        return dp[0]
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as <code>steps</code> and <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as <code>arrLen</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span></p>
        <p>Our nested for-loops iterate over <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n⋅min⁡(n,m))O(n \cdot \min{(n, m)})</span><span class="katex-html"
                                                                                       aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">min</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord"><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mpunct">,</span><span
                class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal">m</span><span
                class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span> states of <code>curr,
            remain</code>. Calculating each state is done in <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord">1</span><span
                class="mclose">)</span></span></span></span></span>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(min⁡(n,m))O(\min{(n, m)})</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mop">min</span><span class="mspace" style="margin-right: 0.1667em;"></span><span
                class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span
                class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p><code>dp</code> and <code>prevDp</code> have a size of <span class="math math-inline"><span
                class="katex"><span class="katex-mathml">O(min⁡(n,m))O(\min{(n, m)})</span><span class="katex-html"
                                                                                                 aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mop">min</span><span class="mspace" style="margin-right: 0.1667em;"></span><span
                class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span
                class="mpunct">,</span><span class="mspace" style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span></span><span class="mclose">)</span></span></span></span></span>.
        </p>
    </li>
</ul>
<br>
<hr>
</body>
</html>