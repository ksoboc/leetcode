<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Total Cost to Hire K Workers - Solution</title>
</head>
<body>
<h2 id="solution">Total Cost to Hire K Workers - Solution</h2>
<hr>
<h3 id="approach-1-2-priority-queues">Approach 1: 2 Priority Queues</h3>
<h4 id="intuition">Intuition</h4>
<blockquote>
    <p>If you are not familiar with the priority queue, please refer to our explore cards <a
            href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/" target="_blank">Heaps
        Explore Card</a>. We will focus on the usage in this article and not the implementation details.</p>
</blockquote>
<p><strong>For the sake of brevity, let <code>m</code> represent the input integer <code>candidates</code> for the rest
    of the article.</strong></p>
<p>To begin with, we need to understand the problem requirements. In each of the <code>k</code> hiring rounds, we must
    hire a worker with the lowest cost (with the smallest index being a tiebreaker) based on the provided rules.</p>
<p>We have the option to select the worker with the lowest cost from either the first <code>m</code> candidates or the
    last <code>m</code> candidates from <code>costs</code>. Once we choose a worker from either of these sections, we
    remove the chosen worker from the array, which makes space for another worker to be in either the first or last
    <code>m</code> candidates. We continue to select the worker with the lowest cost, each time making space for another
    worker from <code>costs</code> to be into consideration. Because we need to repeatedly find the minimum cost, using
    a priority queue is the most appropriate approach to simulate this process.</p>
<br>
<p>During each hiring session, our goal is to select the worker with the lowest cost. As mentioned above, after
    selecting a worker, a spot will open up for another worker to be among the first or last <code>m</code> candidates.
    As such, we need to distinguish between the first <code>m</code> candidates and the last <code>m</code> candidates.
    That way, when we choose a worker, we know if a spot was opened in the first <code>m</code> candidates or the last
    <code>m</code> candidates.</p>
<p><img src="1.png" alt="img"></p>
<p>To store the workers in two sections separately, we can use two priority queues, <code>head_workers</code> and <code>tail_workers</code>,
    where the worker with the lowest cost has the highest priority.</p>
<p><img src="2.png" alt="img"></p>
<p>Throughout the process, after we hire a worker from a section, we need to add an additional candidate to this
    section. Therefore, we need two pointers, <code>next_head</code> and <code>next_tail</code>, that denotes the next
    worker to be added to the respective queues.</p>
<p><img src="3.png" alt="img"></p>
<p>Just like in this situation shown in the picture, if two workers with the same cost appear at the top of both queues,
    we will hire the one from <code>head_workers</code>, since this worker has a smaller index compared with the other
    one from <code>tail_workers</code>. Afterwards, we need to refill <code>head_workers</code> with the worker at
    <code>next_head</code> to ensure that it still contains the first <code>m</code> unselected candidates.</p>
<p><img src="4.png" alt="img"></p>
<p>We add the worker <code>costs[next_head]</code> to <code>head_workers</code>, and then increment this pointer by 1,
    indicating the next unselected worker.</p>
<p><img src="5.png" alt="img"></p>
<p>However, if we encounter the condition <code>next_tail &lt; next_head</code>, it indicates that all the workers have
    been selected as candidates and there are no more workers outside the two queues. To avoid double counting, we
    should not add a worker to both queues or update either pointer. Therefore, we can simply move on without making any
    updates to the queues or pointers.</p>
<p><img src="6.png" alt="img"></p>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>
        <p>Initialize two priority queues <code>head_workers</code> and <code>tail_workers</code> that store the first
            <code>m</code> workers and the last <code>m</code> workers, where the worker with the lowest cost has the
            highest priority.</p>
    </li>
    <li>
        <p>Set up two pointers <code>next_head = m</code>, <code>next_tail = n - m - 1</code> indicating the next worker
            to be added to two queues.</p>
    </li>
    <li>
        <p>Compare the top workers in both queues, and hire the one with the lowest cost, if both workers have the same
            cost, hire the worker from <code>head_workers</code>. Add the cost of this worker to the total cost.</p>
    </li>
    <li>
        <p>If <code>next_head &lt;= next_tail</code>, we need to fill the queue with one worker:</p>
        <ul>
            <li>If the hired worker is from <code>head_workers</code>, we add the worker <code>costs[next_head]</code>
                to it and increment <code>next_head</code> by 1.
            </li>
            <li>If the hired worker is from <code>tail_workers</code>, we add the worker <code>costs[tail_head]</code>
                to it and decrement <code>tail_head</code> by 1.
            </li>
        </ul>
        <p>Otherwise, skip this step.</p>
    </li>
    <li>
        <p>Repeat steps 3 and 4 <code>k</code> times.</p>
    </li>
    <li>
        <p>Return the total cost of all the hired workers.</p>
    </li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public long totalCost(int[] costs, int k, int candidates) {
        PriorityQueue<Integer> headWorkers = new PriorityQueue<>();
        PriorityQueue<Integer> tailWorkers = new PriorityQueue<>();

        // headWorkers stores the first k workers.
        // tailWorkers stores at most last k workers without any workers from the first k workers.
        for (int i = 0; i < candidates; i++) {
            headWorkers.add(costs[i]);
        }
        for (int i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {
            tailWorkers.add(costs[i]);
        }

        long answer = 0;
        int nextHead = candidates;
        int nextTail = costs.length - 1 - candidates;

        for (int i = 0; i < k; i++) {
            if (tailWorkers.isEmpty() || !headWorkers.isEmpty() && headWorkers.peek() <= tailWorkers.peek()) {
                answer += headWorkers.poll();

                // Only refill the queue if there are workers outside the two queues.
                if (nextHead <= nextTail) {
                    headWorkers.add(costs[nextHead]);
                    nextHead++;
                }
            }

            else {
                answer += tailWorkers.poll();

                // Only refill the queue if there are workers outside the two queues.
                if (nextHead <= nextTail) {
                    tailWorkers.add(costs[nextTail]);
                    nextTail--;
                }
            }
        }

        return answer;
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        # head_workers stores the first k workers.
        # tail_workers stores at most last k workers without any workers from the first k workers.
        head_workers = costs[:candidates]
        tail_workers = costs[max(candidates, len(costs) - candidates):]
        heapify(head_workers)
        heapify(tail_workers)

        answer = 0
        next_head, next_tail = candidates, len(costs) - 1 - candidates

        for _ in range(k):
            if not tail_workers or head_workers and head_workers[0] <= tail_workers[0]:
                answer += heappop(head_workers)

                # Only refill the queue if there are workers outside the two queues.
                if next_head <= next_tail:
                    heappush(head_workers, costs[next_head])
                    next_head += 1
            else:
                answer += heappop(tail_workers)

                # Only refill the queue if there are workers outside the two queues.
                if next_head <= next_tail:
                    heappush(tail_workers, costs[next_tail])
                    next_tail -= 1

        return answer
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html"
                                                                                                    aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
    be the given integer <code>candidates</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O((k+m)⋅log⁡m)O((k + m) \cdot\log m)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">((</span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                       style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace"
                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                      style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>
                <p>We need to initialize two priority queues of size <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>,
                    which takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅log⁡m)O(m \cdot\log m)</span><span
                            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                              style="margin-right: 0.2222em;"></span><span
                            class="mbin">⋅</span><span class="mspace"
                                                       style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    time.</p>
            </li>
            <li>
                <p>During the hiring rounds, we keep removing the top element from priority queues and adding new
                    elements for up to <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">kk</span><span class="katex-html" aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 0.6944em;"></span><span
                            class="mord mathnormal"
                            style="margin-right: 0.03148em;">k</span></span></span></span></span> times. Operations on a
                    priority queue take amortized <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">O(log⁡m)O(\log m)</span><span class="katex-html"
                                                                               aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    time. Thus this process takes <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">O(k⋅log⁡m)O(k \cdot\log m)</span><span class="katex-html"
                                                                                        aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mord mathnormal"
                                                        style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span><span
                            class="mbin">⋅</span><span class="mspace"
                                                       style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    time.</p>
            </li>
            <li>
                <p>Note: in Python, <code>heapq.heapify()</code> creates the priority queue in linear time. Therefore,
                    in Python, the time complexity is <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">O(m+k⋅log⁡m)O(m + k \cdot \log m)</span><span class="katex-html"
                                                                                               aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                              style="margin-right: 0.2222em;"></span><span
                            class="mbin">+</span><span class="mspace"
                                                       style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                 style="margin-right: 0.03148em;">k</span><span
                            class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span
                            class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>.
                </p>
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <ul>
            <li>We need to store the first <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                    class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
                and the last <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
                workers in two priority queues.
            </li>
        </ul>
    </li>
</ul>
<br>
<hr>
<h3 id="approach-2-1-priority-queue">Approach 2: 1 Priority Queue</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also implement the hiring process using a single priority queue. However, if we only store the costs of the
    candidates as before, we cannot sort them based on their index. To address this, we can add a new field to each
    worker to denote their section ID. For instance, we can assign <code>0</code> to the first <code>m</code> candidates
    and <code>1</code> to the last <code>m</code> candidates. This way, when two workers have the same cost, the
    priority queue can sort them based on their section IDs, and the worker with the smaller section ID will be hired.
    This approach fully meets the requirements given in the problem.</p>
<p>As illustrated in the following picture, we store each candidate in <code>pq</code>, in the format of <code>(cost,
    section ID)</code>. For example:</p>
<ul>
    <li>
        <p><code>costs[1] = 12</code> is from the head section and stored as <code>(12, 0)</code>.</p>
    </li>
    <li>
        <p><code>costs[9] = 2</code> is from the tail section and stored as <code>(2, 1)</code>.</p>
    </li>
</ul>
<p><img src="7.png" alt="img"></p>
<p>We will proceed with the hiring process for <code>k</code> rounds by hiring the top worker from <code>pq</code> each
    time.</p>
<p>Similar to the previous solution:</p>
<blockquote>
    <p>If we choose a worker from <code>head_workers</code>, we add the worker at <code>next_head</code> to <code>head_workers</code>.<br>
        If we choose a worker from <code>tail_workers</code>, we add the worker at <code>next_tail</code> to <code>tail_workers</code>.
    </p>
</blockquote>
<p>Here, we check whether the hired worker is from the first <code>m</code> candidates or the last <code>m</code>
    candidates by checking his section ID.</p>
<blockquote>
    <p>If the section ID is <code>0</code>, it means that the worker is from the first <code>m</code> candidates, we add
        the worker at <code>next_head</code> to <code>pq</code> with a section ID as <code>0</code>.<br>
        If the section ID is <code>1</code>, it means that the worker is from the last <code>m</code> candidates, we add
        the worker at <code>next_tail</code> to <code>pq</code> with a section ID as <code>1</code>.</p>
</blockquote>
<p><img src="8.png" alt="img"></p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>
        <p>Create a priority queue <code>pq</code> and initialize it with the first <code>m</code> workers and last
            <code>m</code> workers from <code>costs</code>, along with their section IDs (0 for the first <code>m</code>
            workers, and 1 for the last <code>m</code> workers). The worker with the lowest cost has the highest
            priority.</p>
    </li>
    <li>
        <p>Initialize two pointers <code>next_head = m</code> and <code>next_tail = n - m - 1</code>, indicating the
            next worker to be added to <code>pq</code>.</p>
    </li>
    <li>
        <p>Pop the top worker with the lowest cost from <code>pq</code> and add the cost of this hired worker to the
            total cost.</p>
    </li>
    <li>
        <p>If <code>next_head &gt;= next_tail</code>, we need to fill <code>pq</code> with the next worker:</p>
        <ul>
            <li>If the hired worker's section ID is <code>0</code>, we push the worker <code>costs[next_head]</code> to
                into <code>pq</code> and increment <code>next_head</code> by 1.
            </li>
            <li>If the hired worker's section ID is <code>1</code>, we push the worker <code>costs[next_tail]</code> to
                into <code>pq</code> and decrement <code>next_tail</code> by 1.
            </li>
        </ul>
        <p>Otherwise, skip this step.</p>
    </li>
    <li>
        <p>Repeat steps 3 and 4 <code>k</code> times.</p>
    </li>
    <li>
        <p>Return the total cost of all the hired workers.</p>
    </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public long totalCost(int[] costs, int k, int candidates) {
        // The worker with the lowest cost has the highest priority, if two players has the
        // same cost, break the tie by their indices (0 or 1).
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {
            if (a[0] == b[0]) {
                return a[1] - b[1];
            }
            return a[0] - b[0];});

        // Add the first k workers with section id of 0 and
        // the last k workers with section id of 1 (without duplication) to pq.
        for (int i = 0; i < candidates; i++) {
            pq.offer(new int[] {costs[i], 0});
        }
        for (int i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {
            pq.offer(new int[] {costs[i], 1});
        }

        long answer = 0;
        int nextHead = candidates;
        int nextTail = costs.length - 1 - candidates;

        for (int i = 0; i < k; i++) {
            int[] curWorker = pq.poll();
            int curCost = curWorker[0], curSectionId = curWorker[1];
            answer += curCost;

            // Only refill pq if there are workers outside.
            if (nextHead <= nextTail) {
                if (curSectionId == 0) {
                    pq.offer(new int[]{costs[nextHead], 0});
                    nextHead++;
                } else {
                    pq.offer(new int[]{costs[nextTail], 1});
                    nextTail--;
                }
            }
        }

        return answer;
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def totalCost(self, costs: List[int], k: int, candidates: int) -> int:
        # Add the first k workers with section id of 0 and
        # the last k workers with section id of 1 (without duplication) to pq.
        pq = []
        for i in range(candidates):
            pq.append((costs[i], 0))
        for i in range(max(candidates, len(costs) - candidates), len(costs)):
            pq.append((costs[i], 1))

        heapify(pq)

        answer = 0
        next_head, next_tail = candidates, len(costs) - 1 - candidates

        # Only refill pq if there are workers outside.
        for _ in range(k):
            cur_cost, cur_section_id = heappop(pq)
            answer += cur_cost
            if next_head <= next_tail:
                if cur_section_id == 0:
                    heappush(pq, (costs[next_head], 0))
                    next_head += 1
                else:
                    heappush(pq, (costs[next_tail], 1))
                    next_tail -= 1

        return answer
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>For the sake of brevity, let <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                                           style="height: 0.4306em;"></span><span
        class="mord mathnormal">m</span></span></span></span></span> be the given integer <code>candidates</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O((k+m)⋅log⁡m)O((k + m) \cdot\log m)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">((</span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                       style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span><span class="mspace"
                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                      style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>
                <p>We need to initialize one priority queue <code>pq</code> of size up to <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">2⋅m2\cdot m</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.6444em;"></span><span
                        class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                        class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>,
                    which takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅log⁡m)O(m \cdot\log m)</span><span
                            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                              style="margin-right: 0.2222em;"></span><span
                            class="mbin">⋅</span><span class="mspace"
                                                       style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    time.</p>
            </li>
            <li>
                <p>During <code>k</code> hiring rounds, we keep popping top elements from <code>pq</code> and pushing
                    new elements into <code>pq</code> for up to <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">kk</span><span class="katex-html" aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 0.6944em;"></span><span
                            class="mord mathnormal"
                            style="margin-right: 0.03148em;">k</span></span></span></span></span> times. Operations on a
                    priority queue take amortized <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">O(log⁡m)O(\log m)</span><span class="katex-html"
                                                                               aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    time. Thus this process takes <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">O(k⋅log⁡m)O(k \cdot\log m)</span><span class="katex-html"
                                                                                        aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mord mathnormal"
                                                        style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span><span
                            class="mbin">⋅</span><span class="mspace"
                                                       style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    time.</p>
            </li>
            <li>
                <p>Note: in Python, <code>heapq.heapify()</code> creates the priority queue in linear time. Therefore,
                    in Python, the time complexity is <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">O(m+k⋅log⁡m)O(m + k \cdot \log m)</span><span class="katex-html"
                                                                                               aria-hidden="true"><span
                            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                            class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                              style="margin-right: 0.2222em;"></span><span
                            class="mbin">+</span><span class="mspace"
                                                       style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                 style="margin-right: 0.03148em;">k</span><span
                            class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span
                            class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
                            class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                            style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>.
                </p>
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <ul>
            <li>We need to store at most <span class="math math-inline"><span class="katex"><span class="katex-mathml">2⋅m2 \cdot m</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.6444em;"></span><span
                    class="mord">2</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span
                    class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut"
                                                                                                          style="height: 0.4306em;"></span><span
                    class="mord mathnormal">m</span></span></span></span></span> elements (the first <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.4306em;"></span><span
                    class="mord mathnormal">m</span></span></span></span></span> and the last <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.4306em;"></span><span
                    class="mord mathnormal">m</span></span></span></span></span> elements) of <code>costs</code> in the
                priority queue <code>pq</code>.
            </li>
        </ul>
    </li>
</ul>
<br>
</body>
</html>