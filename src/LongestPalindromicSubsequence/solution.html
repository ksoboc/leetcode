<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Longest Palindromic Subsequence solution</title>
</head>
<body>
<h2 id="solution">Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>We are given a string <code>s</code>. Our task is to find the longest palindromic subsequence length in
    <code>s</code>.</p>
<hr>
<h3 id="approach-1-recursive-dynamic-programming">Approach 1: Recursive Dynamic Programming</h3>
<h4 id="intuition">Intuition</h4>
<p>If you are new to Dynamic Programming, please see our <a
        href="https://leetcode.com/explore/featured/card/dynamic-programming/" target="_blank">Leetcode Explore Card</a>
    for more information on it!</p>
<p>An intutive approach to solve this problem is to generate all the subsequences of the given string and find the
    longest palindromic string among all the generated strings. There are a total of <span
            class="math math-inline"><span class="katex"><span class="katex-mathml">2n2^{n}</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.6644em;"></span><span
            class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span
            class="vlist-r"><span class="vlist" style="height: 0.6644em;"><span
            style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span
            class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span>
    strings possible, where <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.4306em;"></span><span
            class="mord mathnormal">n</span></span></span></span></span> denotes the length of the given string.</p>
<p>We can use recursion to generate all possible strings.</p>
<p>If the first and last characters are the same, both characters are guaranteed to be considered in the final
    palindrome. As a result, we add <code>2</code> to our answer variable and recursively remove the first and last
    characters from the remaining substring.</p>
<p>If the first and last characters arenâ€™t the same, they cannot both occur in the final palindrome. As a result, we
    recurse over the substring removing the first and also recurse over the substring removing the last character. As we
    want the longest palindromic subsequence, we pick the maximum out of both of these.</p>
<p>To perform this recursion, we use two pointers, <code>i</code> and <code>j</code>, where <code>i</code> is the index
    of the first character and <code>j</code> is the index of the last character, to form a substring of <code>s</code>
    that is being considered. As a result, the recursive relation can be written as follows:</p>
<blockquote>
    <ol>
        <li>If <code>s[i] == s[j]</code>, perform <code>answer = 2 + LPS(i + 1, j - 1)</code>.</li>
        <li>Else, perform <code>answer = max(LPS(i, j - 1), LPS(i + 1, j)</code>.</li>
    </ol>
</blockquote>
<p>where <code>LPS(int i, int j)</code> is a recursive method that returns the longest palindromic subsequence of the
    substring formed from index <code>i</code> to index <code>j</code> in <code>s</code>. The solution is <code>LPS(0, n
        - 1)</code>, where <code>n</code> is the length of <code>s</code></p>
<p>The recursion tree of the above relation would look something like this:</p>
<p><img src="516-1.png" alt="img"></p>
<p>Several subproblems, such as <code>LPS(2, n - 2)</code>, <code>LPS(1, n - 3)</code>, etc., are solved twice in the
    partial recursion tree shown above. If we draw the entire recursion tree, we can see that there are many subproblems
    that are solved repeatedly.</p>
<p>To avoid this issue, we store the solution of the subproblem in a 2D array when it is solved. When we encounter the
    same subproblem again, we simply refer to the array. This is called <strong>memoization</strong>.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> and initialize it to the size of <code>s</code>.</li>
    <li>Create a 2D-array called <code>memo</code> having <code>n</code> rows and <code>n</code> columns where <code>memo[i][j]</code>
        contains the length of the longest palindromic subsequence of the substring formed from index <code>i</code> to
        <code>j</code> in <code>s</code>.
    </li>
    <li>Return <code>lps(s, 0, n - 1, memo)</code> where <code>lps</code> is a recursive method with four parameters:
        <code>s</code>, the starting index of the substring under consideration as <code>i</code>, the ending index of
        the substring as <code>j</code> and <code>memo</code>. We perform the following in this method:
        <ul>
            <li>If <code>memo[i][j] != 0</code>, it indicates that we have already solved this subproblem, so we return
                <code>memo[i][j]</code>.
            </li>
            <li>If <code>i &gt; j</code>, the string is empty. We return <code>0</code>.</li>
            <li>If <code>i == j</code>, it is a substring having one character. As a result, we return <code>1</code>.
            </li>
            <li>If the first and the last characters are the same, i.e., <code>s[i] == s[j]</code>, we include these two
                characters in the palindromic subsequence and add it to the longest palindromic subsequence formed using
                the substring from index <code>i + 1</code> to <code>j - 1</code> (inclusive). We perform <code>memo[i][j]
                    = lps(s, i + 1, j - 1, memo) + 2</code>.
            </li>
            <li>Otherwise, if the first and the last characters do not match, we recursively search for the longest
                palindromic subsequence in both the substrings formed after ignoring the first and last characters. We
                pick the maximum of these two. We perform <code>memo[i][j] = max(lps(s, i + 1, j, memo), lps(s, i, j -
                    1, memo))</code>.
            </li>
            <li>Return <code>memo[i][j]</code>.</li>
        </ul>
    </li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] memo = new int[n][n];
        return lps(s, 0, n - 1, memo);
    }

    private int lps(String s, int i, int j, int[][] memo) {
        if (memo[i][j] != 0) {
            return memo[i][j];
        }
        if (i > j) {
            return 0;
        }
        if (i == j) {
            return 1;
        }

        if (s.charAt(i) == s.charAt(j)) {
            memo[i][j] = lps(s, i + 1, j - 1, memo) + 2;
        } else {
            memo[i][j] = Math.max(lps(s, i + 1, j, memo), lps(s, i, j - 1, memo));
        }
        return memo[i][j];
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> memo(n, vector<int>(n));
        return lps(s, 0, n - 1, memo);
    }

    int lps(string s, int i, int j, vector<vector<int>>& memo) {
        if (memo[i][j] != 0) {
            return memo[i][j];
        }
        if (i > j) {
            return 0;
        }
        if (i == j) {
            return 1;
        }

        if (s[i] == s[j]) {
            memo[i][j] = lps(s, i + 1, j - 1, memo) + 2;
        } else {
            memo[i][j] = max(lps(s, i + 1, j, memo), lps(s, i, j - 1, memo));
        }
        return memo[i][j];
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)

        memo = {}
        def lps(l, r):
            if (l,r) in memo:
                return memo[(l,r)]
            if l > r:
                return 0
            if l == r:
                return 1

            if s[l] == s[r]:
                memo[(l,r)] = lps(l + 1, r - 1) + 2
            else:
                memo[(l,r)] = max(lps(l, r - 1), lps(l + 1, r))
            return memo[(l, r)]

        return lps(0, n - 1)
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the length of <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Initializing the <code>memo</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time.
            </li>
            <li>Since there are <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> states that we need to iterate over, the
                recursive function is called <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span> times.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>The <code>memo</code> array consumes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> space.
            </li>
            <li>The recursion stack used in the solution can grow to a maximum size of <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>. When we
                try to form the recursion tree, we see that there are maximum of two branches that can be formed at each
                level (when <code>s[i]!= s[j]</code>). The recursion stack would only have one call out of the two
                branches. The height of such a tree will be <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                because at each level we are decrementing the length of the string under consideration by '1'. As a
                result, the recursion tree that will be formed will have <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                height. Hence, the recursion stack will have a maximum of <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                elements.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-2-iterative-dynamic-programming">Approach 2: Iterative Dynamic Programming</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We used memoization in the preceding approach to store the answers to subproblems in order to solve a larger problem.
    We can also use a bottom-up approach to solve such problems without using recursion. We build answers to subproblems
    iteratively first, then use them to build answers to larger problems.</p>
<p>Using the same method as before, we create a 2D-array <code>dp</code>, where <code>dp[i][j]</code> contains the
    answer of the longest palindromic subsequence of the substring formed from index <code>i</code> to <code>j</code> in
    <code>s</code>. Our answer would be <code>dp[0][n - 1]</code>, where <code>n</code> is the size of <code>s</code>.
    The state transition would be as follows:</p>
<blockquote>
    <ol>
        <li>If <code>s[i] == s[j]</code>, perform <code>dp[i][j] = 2 + dp[i + 1][j - 1]</code>.</li>
        <li>Otherwise, perform <code>dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]</code>.</li>
    </ol>
</blockquote>
<p>The <code>dp</code> array can be filled in a variety of ways. A few of them are briefly discussed below:</p>
<ul>
    <li><strong>Building from smaller to larger strings</strong>: We can begin by selecting all possible substrings of
        length '1', then find the largest palindromic subsequence in all substrings of length '2', then in length '3',
        and so on to obtain the answer for the entire string.
    </li>
    <li><strong>Using two pointers</strong>: We can use two pointers, <code>i</code> and <code>j</code>, where
        <code>i</code> points to the first character of the substring under consideration and <code>j</code> points to
        the last character. Using <code>dp</code> entries corresponding to all the substrings formed by selecting
        indices within the range from <code>i</code> to <code>j</code> (inclusive), we form answers for all the
        substrings that start index <code>i - 1</code>. The pointer <code>j</code> moves from <code>j = i - 1</code> to
        <code>j = n - 1</code> to cover all possible substrings that start at index <code>i - 1</code>. (we can also
        choose to move from <code>i</code> to <code>j + 1</code>, i.e., from left to right). From the end of the string,
        we move from right to left, decrementing <code>i</code> by <code>1</code> until we reach the index
        <code>0</code>. This is the approach we take here.
    </li>
</ul>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> and initialize it to the size of <code>s</code>.</li>
    <li>Create a 2D-array called <code>dp</code> having <code>n</code> rows and <code>n</code> columns where <code>dp[i][j]</code>
        contains the length of the longest palindromic subsequence of the substring formed from index <code>i</code> to
        <code>j</code> in <code>s</code>.
    </li>
    <li>We iterate using two loops. The outer loop iterates from <code>i = n - 1</code> to <code>i = 0</code>
        decrementing <code>i</code> by <code>1</code> after each iteration. At the end of each iteration, we will have
        the length of longest palindromic subsequence in all the substrings that start from index <code>i</code> in
        <code>s</code>. For each <code>i</code>, we first mark <code>dp[i][i] = 1</code> because it denotes just one
        character and then we iterate over <code>j = i + 1</code> to <code>j = n - 1</code> and perform the following:
        <ul>
            <li>If the first and the last characters are the same, i.e., <code>s[i] == s[j]</code>, we include these two
                characters in the palindromic subsequence and add it to the longest palindromic subsequence formed using
                the substring from index <code>i + 1</code> to <code>j - 1</code> (inclusive). We perform <code>dp[i][j]
                    = dp[i + 1][j - 1] + 2</code>. We already have the answer for <code>dp[i + 1][j - 1]</code> because
                we computed it for substrings starting at index <code>i + 1</code> in the previous iteration of outer
                loop.
            </li>
            <li>Otherwise, if the first and the last characters do not match, we look for the longest palindromic
                subsequence in both the substrings formed after ignoring the first and last characters. We pick the
                maximum of these two. We perform <code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code>.
            </li>
        </ul>
    </li>
    <li>Return <code>dp[0][n - 1]</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public int longestPalindromeSubseq(String s) {
        int[][] dp = new int[s.length()][s.length()];

        for (int i = s.length() - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < s.length(); j++) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][s.length() - 1];
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<vector<int>> dp(n, vector<int>(n));

        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            for (int j = i + 1; j < n; j++) {
                if (s[i] == s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][n - 1];
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        dp = [[0] * n for _ in range(n)]

        for i in range(n - 1, -1, -1):
            dp[i][i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    dp[i][j] = dp[i + 1][j - 1] + 2
                else:
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])

        return dp[0][n - 1]
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the length of <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Initializing the <code>dp</code> array takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time.
            </li>
            <li>We fill the <code>dp</code> array which takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>The <code>dp</code> array consumes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> space.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-3-dynamic-programming-with-space-optimization">Approach 3: Dynamic Programming with Space
    Optimization</h3>
<h4 id="intuition-2">Intuition</h4>
<p>The state transition, as we discussed in previous approaches, is:</p>
<blockquote>
    <ol>
        <li>If <code>s[i] == s[j]</code>, perform <code>dp[i][j] = 2 + dp[i + 1][j - 1]</code>.</li>
        <li>Otherwise, perform <code>dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]</code>.</li>
    </ol>
</blockquote>
<p>If we look closely at this transition, to fill <code>dp[i][j]</code> for a particular <code>i</code> and all possible
    values of <code>j</code>, we only need the values from the current and previous rows. To fill row <code>i + 1</code>
    in the <code>dp</code> grid, we need the values from row <code>i + 1</code> (<code>dp[i + 1][j - 1]</code>) and
    previously computed value in the <span class="math math-inline"><span class="katex"><span class="katex-mathml">ithi^{th}</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.8491em;"></span><span
            class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span
            class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span
            style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span
            class="mord mathnormal mtight">t</span><span
            class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span></span>
    row itself (<code>dp[i][j - 1]</code>). Values in rows <code>i + 2</code>, <code>i + 3</code>, and so on are no
    longer needed.</p>
<p>Our task is complete if we can store the values of the previous iteration, i.e., for row <code>i + 1</code> after
    each iteration of the outer loop.</p>
<p>We can solve this by using two 1D arrays of size <code>n</code>, <code>dp</code> and <code>dpPrev</code>, where
    <code>n</code> is the size of <code>s</code>. We repeat the previous approach by running two loops. The outer loop
    runs from <code>i = n - 1</code> to <code>i = 0</code>, and the inner loop runs from <code>j = i + 1</code> to
    <code>j = n - 1</code>.</p>
<p>Now, <code>dp[j]</code> stores the length of longest palindromic subsequence of the substring from index
    <code>i</code> to <code>j</code> in <code>s</code>. It is similar to what <code>dp[i][j]</code> stored in previous
    approach.</p>
<p>The other array <code>dpPrev</code> is important to understand. It helps us by remembering the previous state that we
    completed previously. <code>dpPrev[j]</code> stores the length of the longest palindromic subsequence of the
    substring from index <code>i + 1</code> to <code>j</code> in <code>s</code>. It is analogous to <code>dp[i +
        1][j]</code> in the previous approach.</p>
<p>Because <code>dpPrev</code> stores the answers of substrings beginning with index <code>i + 1</code> and
    <code>dp</code> stores the answers of substrings beginning with index <code>i</code> we must copy the elements of
    <code>dp</code> to <code>dpPrev</code> after iterating over all the substrings beginning with index <code>i</code>
    to prepare for the next iteration. After we copy <code>dp</code> to <code>dpPrev</code>, for the next iteration
    which considers substrings from <code>i - 1</code>, <code>dpPrev</code> will hold values of substrings beginning at
    index <code>i</code> which is exactly what we want.</p>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
    <li>Create an integer variable <code>n</code> and initialize it to the size of <code>s</code>.</li>
    <li>Create two arrays called <code>dp</code> and <code>dpPrev</code> of size <code>n</code>.</li>
    <li>We iterate using two loops with outer loop running from <code>i = n - 1</code> to <code>i = 0</code>
        decrementing <code>i</code> by <code>1</code> after each iteration. For each <code>i</code>, we first mark
        <code>dp[i] = 1</code> since it denotes just one character at index <code>i</code> and then we iterate over
        <code>j = i + 1</code> to <code>j = n - 1</code> and perform the following:
        <ul>
            <li>If the first and the last characters are the same, i.e., <code>s[i] == s[j]</code>, we include these two
                characters in the palindromic subsequence and add it to the longest palindromic subsequence formed using
                the substring from index <code>i + 1</code> to <code>j - 1</code> (inclusive). We perform <code>dp[j] =
                    dpPrev[j - 1] + 2</code>. Note that we already have computed answer for substrings starting from
                index <code>i + 1</code> in the previous iteration of outer loop. We have it in <code>dpPrev</code>.
            </li>
            <li>Otherwise, if the first and the last characters do not match, we check for the longest palindromic
                subsequence in both the substrings formed after ignoring the first and last characters. We pick the
                maximum of these two. We perform <code>dp[j] = max(dpPrev[j], dp[j - 1])</code>.
            </li>
            <li>After the completion of inner loop, we copy <code>dp</code> to <code>dpPrev</code>.</li>
        </ul>
    </li>
    <li>Return <code>dp[n - 1]</code> (or <code>dpPrev[n - 1]</code> as both are similar).</li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[] dp = new int[n];
        int[] dpPrev = new int[n];

        for (int i = n - 1; i >= 0; --i) {
            dp[i] = 1;
            for (int j = i + 1; j < n; ++j) {
                if (s.charAt(i) == s.charAt(j)) {
                    dp[j] = dpPrev[j - 1] + 2;
                } else {
                    dp[j] = Math.max(dpPrev[j], dp[j - 1]);
                }
            }
            dpPrev = dp.clone();
        }

        return dp[n - 1];
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int longestPalindromeSubseq(string s) {
        int n = s.size();
        vector<int> dp(n), dpPrev(n);

        for (int i = n - 1; i >= 0; --i) {
            dp[i] = 1;
            for (int j = i + 1; j < n; ++j) {
                if (s[i] == s[j]) {
                    dp[j] = dpPrev[j - 1] + 2;
                } else {
                    dp[j] = max(dpPrev[j], dp[j - 1]);
                }
            }
            dpPrev = dp;
        }

        return dp[n - 1];
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def longestPalindromeSubseq(self, s: str) -> int:
        n = len(s)
        dp, dpPrev = [0] * n, [0] * n

        for i in range(n - 1, -1, -1):
            dp[i] = 1
            for j in range(i + 1, n):
                if s[i] == s[j]:
                    dp[j] = dpPrev[j - 1] + 2
                else:
                    dp[j] = max(dpPrev[j], dp[j - 1])
            dpPrev = dp[:]

        return dp[n - 1]
    </code>
</pre>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the length of <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Initializing the <code>dp</code> and <code>dpPrev</code> arrays take <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
            <li>To get the answer, we use two loops that take <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> time.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <ul>
            <li>The <code>dp</code> and <code>dpPrev</code> arrays take <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space
                each.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>