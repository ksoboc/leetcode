<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Minimum Size Subarray Sum - Solution</title>
</head>
<body>
<h2 id="solution">Minimum Size Subarray Sum - Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, our task is to
    return the minimal length of a subarray whose sum is greater than or equal to <code>target</code>. If there is no
    such subarray, we have to return <code>0</code>.</p>
<hr>
<h3 id="approach-sliding-window">Approach: Sliding Window</h3>
<h4 id="intuition">Intuition</h4>
<p>An intuitive technique is to go through all the subarrays one by one and check the sum of each one. If the total of
    the subarray under consideration is larger than or equal to <code>target</code>, we attempt to update our answer
    variable by using the minimum of the current answer and the length of this subarray. To get all the subarrays, we
    can run two loops: the outer loop selects a starting point and the inner loop selects an ending point. This
    solution, however, will take <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1.0641em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
            class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
            style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mtight">2</span></span></span></span></span></span></span></span><span
            class="mclose">)</span></span></span></span></span> time, resulting in a time limit exceeded (TLE).</p>
<p>Let's think whether we really need to iterate over all the subarrays.</p>
<p>Given that we only have positive integers, there is no purpose in adding further elements to a subarray if its sum
    exceeds or equals <code>target</code>. Adding more elements to such a subarray will result in the construction of
    longer subarrays, which is useless because we have already found a smaller subarray that meets our requirements.</p>
<p>Only if the sum of the current subarray under consideration is smaller than <code>target</code>, we should append
    elements to the subarray. When the sum of the subarrays exceeds or equals <code>target</code>, we will attempt to
    update our answer with the length of the current subarray.</p>
<p>We now try to remove the elements from the start and see if we can form a smaller subarray that meets our
    requirements. We remove the first element from the subarray and check if we still have the total higher than or
    equal to <code>target</code>. If the total exceeds or equals <code>target</code>, we have a smaller subarray that
    meets our requirement. As a result, we again try to update our answer with the length of the current subarray and
    repeat the process of eliminating the first element from the current subarray until the sum no longer exceeds or
    equals <code>target</code>.</p>
<p>Now after removing elements, if the sum of the subarray is less than <code>target</code>, we have to append more
    elements to it until the sum becomes larger than or equal to <code>target</code>. We append elements until the sum
    equals or exceeds 'target', then try to update our answer variable and repeat the process of eliminating the first
    element.</p>
<p>The above approach can be efficiently solved using the <strong>sliding window approach</strong>.</p>
<p>If you are not familiar with sliding window, please refer to our explore cards <a
        href="https://leetcode.com/explore/featured/card/leetcodes-interview-crash-course-data-structures-and-algorithms/703/arraystrings/4502/"
        target="_blank">Sliding Window Explore Card</a>.</p>
<p>A sliding window is achieved by using two pointers <code>left</code> and <code>right</code>, which point to the
    starting and ending indices of the subarray. We set them to a value of <code>0</code>.</p>
<p>To "add" elements to the window, we loop over the array by incrementing <code>right</code>. In this problem, if the
    sum of the window exceeds or equals <code>target</code>, we try to update our answer and then "remove" elements from
    the window by incrementing <code>left</code> until the sum is less than <code>target</code> again.</p>
<p>Here's a visual representation of how the approach works:</p>
<p>
<div class="relative mx-auto mb-6 flex flex-col overflow-hidden rounded-lg border-[1px] border-label-1"
     style="max-width: 601px;">
    <div class="rounded-lg" style="max-height: 301px;"><img alt="Current"
                                                            class="object-fit-contain !mb-0 max-h-full max-w-full"
                                                            src="blob:https://leetcode.com/77329366-0d02-4e72-a5c0-a6c3af026c33">
    </div>
    <div class="absolute top-[50%] left-[50%] flex h-12 w-12 translate-x-[-50%] translate-y-[-50%] items-center justify-center rounded-full bg-black/30">
        <div class="flex h-4 w-4 cursor-pointer items-center justify-center text-[35px]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="h-full w-full text-white">
                <path fill-rule="evenodd"
                      d="M18.97 12.871l-12.96 7.29a1 1 0 01-1.49-.87V4.71a1 1 0 011.49-.872l12.96 7.29a1 1 0 010 1.743z"
                      clip-rule="evenodd"></path>
            </svg>
        </div>
    </div>
    <div class="relative flex h-8 select-none items-center justify-around bg-black">
        <div class="flex items-center space-x-7">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M16.091 4.929l-7.057 7.078 7.057 7.064a1 1 0 01-1.414 1.414l-7.764-7.77a1 1 0 010-1.415l7.764-7.785a1 1 0 111.415 1.414z"
                      clip-rule="evenodd"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M18.97 12.871l-12.96 7.29a1 1 0 01-1.49-.87V4.71a1 1 0 011.49-.872l12.96 7.29a1 1 0 010 1.743z"
                      clip-rule="evenodd"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M7.913 19.071l7.057-7.078-7.057-7.064a1 1 0 011.414-1.414l7.764 7.77a1 1 0 010 1.415l-7.764 7.785a1 1 0 01-1.414-1.414z"
                      clip-rule="evenodd"></path>
            </svg>
        </div>
        <div class="absolute right-0 mr-5 text-xs font-medium text-white">1 / 11</div>
    </div>
</div>
</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create three integer variables <code>left</code>, <code>right</code> and <code>sumOfCurrentWindow</code>. The
        variables <code>left</code> and <code>right</code> form a subarray by pointing to the starting and ending
        indices of the current subarray (or window), and <code>sumOfCurrentWindow</code> stores the sum of this window.
        Intialize all of them with <code>0</code>.
    </li>
    <li>Create another variable <code>res</code> to store the answer to the problem. We initialize it to a large integer
        value.
    </li>
    <li>We iterate over <code>nums</code> using <code>right</code> starting from <code>right = 0</code> till <code>nums.length
        - 1</code> incrementing <code>right</code> by <code>1</code> after each iteration. We perform the following
        inside this iteration:
        <ul>
            <li>Add element at index <code>right</code> to the current window, incrementing
                <code>sumOfCurrentWindow</code> by <code>nums[right]</code>.
            </li>
            <li>We check if <code>sumOfCurrentWindow &gt;= target</code>. If so, we have a subarray that satisfies our
                condition. As a result, we attempt to update our answer variable with the length of this subarray. We
                perform <code>res = min(res, right - left + 1)</code>. We then remove the first element from this window
                by reducing <code>sumOfCurrentWindow</code> by <code>nums[left]</code> and incrementing
                <code>left</code> by <code>1</code>. This step is repeated in an inner loop as long as <code>sumOfCurrentWindow
                    &gt;= target</code>.
            </li>
            <li>The current window's sum is now smaller than <code>target</code>. We need to add more elements to it. As
                a result, <code>right</code> is incremented by <code>1</code>.
            </li>
        </ul>
    </li>
    <li>Return <code>res</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int left = 0, right = 0, sumOfCurrentWindow = 0;
        int res = Integer.MAX_VALUE;

        for(right = 0; right < nums.length; right++) {
            sumOfCurrentWindow += nums[right];

            while (sumOfCurrentWindow >= target) {
                res = Math.min(res, right - left + 1);
                sumOfCurrentWindow -= nums[left++];
            }
        }

        return res == Integer.MAX_VALUE ? 0 : res;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int left = 0, right = 0, sumOfCurrentWindow = 0;
        int res = INT_MAX;

        for(right = 0; right < nums.size(); right++) {
            sumOfCurrentWindow += nums[right];

            while (sumOfCurrentWindow >= target) {
                res = min(res, right - left + 1);
                sumOfCurrentWindow -= nums[left];
                left++;
            }
        }

        return res == INT_MAX ? 0 : res;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        left = 0
        right = 0
        sumOfCurrentWindow = 0
        res = float('inf')

        for right in range(0, len(nums)):
            sumOfCurrentWindow += nums[right]

            while sumOfCurrentWindow >= target:
                res = min(res, right - left + 1)
                sumOfCurrentWindow -= nums[left]
                left += 1

        return res if res != float('inf') else 0
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the length of <code>nums</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.
        </p>
        <ul>
            <li>You may be thinking: there is an inner while loop inside another for loop, isn't the time complexity
                <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span
                        class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist"
                                                                                          style="height: 0.8141em;"><span
                        style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                        class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span
                        class="mclose">)</span></span></span></span></span>? The reason it is still <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                is because the right pointer <code>right</code> can move <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                times and the left pointer <code>left</code> can move also <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                times in total. The inner loop is not running <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                times for each iteration of the outer loop. A sliding window guarantees a maximum of <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">2n2n</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 0.6444em;"></span><span
                        class="mord">2</span><span class="mord mathnormal">n</span></span></span></span></span> window
                iterations. This is what is referred to as <a href="https://en.wikipedia.org/wiki/Amortized_analysis"
                                                              target="_blank">amortized analysis</a> - even though the
                worst case for an iteration inside the for loop is <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>,
                it averages out to <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> when you consider the entire runtime of the
                algorithm.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord">1</span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <ul>
            <li>We are not using any extra space other than an using few integer <code>left</code>, <code>right</code>,
                <code>sumOfCurrentWinddow</code>, and <code>res</code>, which takes up constant space each.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>