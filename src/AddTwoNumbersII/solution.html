<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Add Two Numbers II - Solution</title>
</head>
<body>
<h2 id="solution">Add Two Numbers II - Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>We are given two non-empty linked lists representing two non-negative integers. The most significant digit comes
    first and each of their nodes contains a single digit.</p>
<p>Our task is to add the two numbers and return the sum as a linked list.</p>
<hr>
<h3 id="approach-1-using-stack">Approach 1: Using Stack</h3>
<h4 id="intuition">Intuition</h4>
<p>We are told that the most significant digit comes first, and that each of their nodes includes a single digit. To do
    a basic addition of two numbers using a sum of two digits and a carry, we must start with the least significant
    digits (1's place) and work our way up to the most significant digits.</p>
<p>To get the order of digits from the least significant digits to the the most significant digits, we can iterate over
    both the given linked lists one by one and store their values in two different stacks (or a list of integers).</p>
<p>The advantage of using a stack is that when we loop over a given linked list from the first node to the last and push
    all the digits in the stack, the top of the stack will have the least significant digit and the bottom will contain
    the most significant digit.</p>
<p>We can add the digits at corresponding places of the linked lists using the two stacks moving from the least to the
    most significant digits using the stack's <code>pop</code> method.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create two integer stacks <code>s1</code> and <code>s2</code> to store the integers of the linked lists
        <code>l1</code> and <code>l2</code> respectively.
    </li>
    <li>Push all the integers of <code>l1</code> in <code>s1</code> starting from the integer at the first node. The
        most significant comes first in the list, so it will be stored at the bottom of the stack and the least
        significant digit will stored at the top.
    </li>
    <li>Similarly, push all the integers of <code>l2</code> in <code>s2</code>.</li>
    <li>Create two integers <code>totalSum</code> and <code>carry</code> to store the sum and carry of current digits.
    </li>
    <li>Create a new <code>ListNode</code>, <code>ans</code> that will store the answer.</li>
    <li>We will add the two numbers present in the linked list now by adding the digits one by one. We continue until
        both <code>s1</code> and <code>s2</code> are empty:
        <ul>
            <li>If <code>s1</code> is not empty, pop the first element from the stack and add it to
                <code>totalSum</code>.
            </li>
            <li>If <code>s2</code> is not empty, pop the first element from the stack and add it to
                <code>totalSum</code>.
            </li>
            <li>Set <code>ans.val = totalSum % 10</code>.</li>
            <li>Store the <code>carry</code> as <code>totalSum / 10</code>.</li>
            <li>Create a new <code>ListNode</code>, <code>newNode</code> that will have <code>val</code> as
                <code>carry</code>. Set <code>next</code> of <code>newNode</code> to <code>ans</code>. Update <code>ans
                    = newNode</code> to use the same variable <code>ans</code> for the next iteration.
            </li>
            <li>Update <code>totalSum = carry</code>.</li>
        </ul>
    </li>
    <li>If <code>carry == 0</code>, it means the <code>newNode</code> that we created in the final iteration of while
        loop has <code>val = 0</code>. Because we perform <code>ans = newNode</code> at the of end of the while loop, to
        avoid returning a linked list with a head of <code>0</code> (leading zero), we return the next element, i.e., we
        return <code>ans.next</code>. Otherwise, if <code>carry</code> is not equal to <code>0</code>, the value of
        <code>ans</code> is non-zero. Hence, we just return <code>ans</code>.
    </li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        public class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> s1 = new Stack<Integer>();
        Stack<Integer> s2 = new Stack<Integer>();

        while(l1 != null) {
            s1.push(l1.val);
            l1 = l1.next;
        };
        while(l2 != null) {
            s2.push(l2.val);
            l2 = l2.next;
        }

        int totalSum = 0, carry = 0;
        ListNode ans = new ListNode();
        while (!s1.empty() || !s2.empty()) {
            if (!s1.empty()) totalSum += s1.pop();
            if (!s2.empty()) totalSum += s2.pop();

            ans.val = totalSum % 10;
            carry = totalSum / 10;
            ListNode head = new ListNode(carry);
            head.next = ans;
            ans = head;
            totalSum = carry;
        }

        return carry == 0 ? ans.next: ans;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        stack<int> s1, s2;

        while (l1 != nullptr) {
            s1.push(l1->val);
            l1 = l1->next;
        }

        while (l2 != nullptr) {
            s2.push(l2->val);
            l2 = l2->next;
        }

        int totalSum = 0, carry = 0;
        ListNode* ans = new ListNode();
        while (!s1.empty() || !s2.empty()) {
            if (!s1.empty()) {
                totalSum += s1.top();
                s1.pop();
            }
            if (!s2.empty()) {
                totalSum += s2.top();
                s2.pop();
            }

            ans->val = totalSum % 10;
            carry = totalSum / 10;
            ListNode* newNode = new ListNode(carry);
            newNode->next = ans;
            ans = newNode;
            totalSum = carry;
        }

        return carry == 0 ? ans->next : ans;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        s1 = []
        s2 = []

        while l1:
            s1.append(l1.val)
            l1 = l1.next
        while l2:
            s2.append(l2.val)
            l2 = l2.next

        total_sum = 0
        carry = 0
        ans = ListNode()
        while s1 or s2:
            if s1:
                total_sum += s1.pop()
            if s2:
                total_sum += s2.pop()

            ans.val = total_sum % 10
            carry = total_sum // 10
            head = ListNode(carry)
            head.next = ans
            ans = head
            total_sum = carry

        return ans.next if carry == 0 else ans
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
    and <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">n</span></span></span></span></span> are is the number of nodes in <code>l1</code>
    and <code>l2</code> respectively</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m+n)O(m + n)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Iterating over both the lists and pushing all the values in the respective stacks take <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
            <li>We then iterate over digits of the both lists. We iterate until both the stacks are empty. We iterate in
                the while loop <code>max(m, n)</code> times. We compute <code>sum</code>, <code>carry</code> and create
                a new node in each iteration which takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> time. Hence, the complexity of all the while
                loop can be written as <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                          style="margin-right: 0.2222em;"></span><span
                        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>The <code>s1</code> stack takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> space and
                the <code>s2</code> stack takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-2-reverse-given-linked-lists">Approach 2: Reverse Given Linked Lists</h3>
<h4 id="intuition-1">Intuition</h4>
<p>Our task is to do a basic addition of two numbers starting with the least significant digits and working our way up
    to the most significant digits. In the previous approach, we used stacks to access the least significant digits
    first. We can also reverse the given lists so the least significant digits come first.</p>
<p>We can then iterate over the reversed lists to perform the addition of digits at corresponding places similar to the
    first approach.</p>
<p>Let's understand how to reverse a linked list. This is a classical problem that you can try <a
        href="https://leetcode.com/problems/reverse-linked-list/" target="_blank">here</a>.</p>
<p>To reverse a linked list, we need three pointers. The first pointer <code>head</code> points to the current node
    under consideration, <code>temp</code> points to the next node, and <code>prev</code> points to the previous node.
    This is because while traversing the list, we change the current node's (<code>head</code>) next pointer to point to
    its previous element (<code>prev</code>). Since a node does not have reference to its previous node, we must store
    its previous element beforehand. We also need another pointer to store the next node (<code>temp</code>) before
    changing the reference so we don't lose it after changing <code>head.next</code>.</p>
<p>We start with initializing <code>prev</code> to <code>null</code>. We then loop until <code>head</code> is null,
    i.e., until we iterate over all the elements. We store <code>head.next</code> in <code>temp</code> to store the next
    node we will go to. After storing the next node, we reverse <code>next</code> of <code>head</code> to the previous
    element, i.e., <code>head.next = prev</code>. We then move <code>prev</code> to <code>head</code> as this becomes
    the previous node for the next node and also move <code>head</code> to <code>temp</code> as this becomes the new
    node under consideration.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>Create two linked lists <code>r1</code> and <code>r2</code> to store the reverse of the linked lists
        <code>l1</code> and <code>l2</code> respectively.
    </li>
    <li>Create two integers <code>totalSum</code> and <code>carry</code> to store the sum and carry of current digits.
    </li>
    <li>Create a new <code>ListNode</code>, <code>ans</code> that will store the sum of current digits.</li>
    <li>We will add the two numbers using the reverse list by adding the digits one by one. We continue until we cover
        all the nodes in <code>r1</code> and <code>r2</code>:
        <ul>
            <li>If <code>r1</code> is not <code>null</code>, we add <code>r1.val</code> to <code>totalSum</code>.</li>
            <li>If <code>r2</code> is not <code>null</code>, we add <code>r2.val</code> to <code>totalSum</code>.</li>
            <li>Set <code>ans.val = totalSum % 10</code>.</li>
            <li>Store the <code>carry</code> as <code>totalSum / 10</code>.</li>
            <li>Create a new <code>ListNode</code>, <code>newNode</code> that will have <code>val</code> as
                <code>carry</code>. Set <code>next</code> of <code>newNode</code> to <code>ans</code>. Update <code>ans
                    = newNode</code> to use the same variable <code>ans</code> for the next iteration.
            </li>
            <li>Update <code>totalSum = carry</code>.</li>
        </ul>
    </li>
    <li>If <code>carry == 0</code>, it means the <code>newNode</code> that we created in the final iteration of while
        loop has <code>val = 0</code>. Because we perform <code>ans = newNode</code> at the of while loop, to avoid
        returning a linked list with a head of <code>0</code> (leading zero), we return the next element, i.e., we
        return <code>ans.next</code>. Otherwise, if <code>carry</code> is not equal to <code>0</code>, the value of
        <code>ans</code> is non-zero. Hence, we just return <code>ans</code>.
    </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        public class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null, temp;
        while (head != null) {
            // Keep the next node
            temp = head.next;
            // Reverse the link
            head.next = prev;
            // Update the previous node and the current node.
            prev = head;
            head = temp;
        }
        return prev;
    }

    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode r1 = reverseList(l1);
        ListNode r2 = reverseList(l2);

        int totalSum = 0, carry = 0;
        ListNode ans = new ListNode();
        while (r1 != null || r2 != null) {
            if (r1 != null) totalSum += r1.val;
            if (r2 != null) totalSum += r2.val;

            ans.val = totalSum % 10;
            carry = totalSum / 10;
            ListNode head = new ListNode(carry);
            head.next = ans;
            ans = head;
            totalSum = carry;

            r1 = r1 != null ? r1.next : null;
            r2 = r2 != null ? r2.next : null;
        }

        return carry == 0 ? ans.next: ans;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* temp;
        while (head) {
            // Keep the next node.
             temp = head->next;
            // reverse the link
            head->next = prev;
            // Update the previous node and the current node.
            prev = head;
            head = temp;
        }
        return prev;
    }

    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* r1 = reverseList(l1);
        ListNode* r2 = reverseList(l2);

        int totalSum = 0;
        int carry = 0;
        ListNode* ans = new ListNode();
        while (r1 || r2) {
            if (r1) {
                totalSum += r1->val;
                r1 = r1->next;
            }
            if (r2) {
                totalSum += r2->val;
                r2 = r2->next;
            }

            ans->val = totalSum % 10;
            carry = totalSum / 10;
            ListNode* head = new ListNode(carry);
            head->next = ans;
            ans = head;
            totalSum = carry;
        }

        return carry == 0 ? ans->next : ans;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        temp = None
        while head:
            # Keep the next node
            temp = head.next
            # Reverse the link
            head.next = prev
            # Update the previous node and the current node.
            prev = head
            head = temp
        return prev

    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        r1 = self.reverseList(l1)
        r2 = self.reverseList(l2)

        total_sum = 0
        carry = 0
        ans = ListNode()
        while r1 or r2:
            if r1:
                total_sum += r1.val
                r1 = r1.next
            if r2:
                total_sum += r2.val
                r2 = r2.next

            ans.val = total_sum % 10
            carry = total_sum // 10
            head = ListNode(carry)
            head.next = ans
            ans = head
            total_sum = carry

        return ans.next if carry == 0 else ans
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
    and <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">n</span></span></span></span></span> are is the number of nodes in <code>l1</code>
    and <code>l2</code> respectively</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m+n)O(m + n)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Reversing the list <code>l1</code> and <code>l2</code> take <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> and <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time
                respectively.
            </li>
            <li>We then iterate over digits of the both lists. We iterate until both the lists are fully traversed. We
                iterate in the while loop <code>max(m, n)</code> times. We compute <code>totalSum</code>,
                <code>carry</code> and create a new node in each iteration which takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> time. Hence, the complexity of all the while
                loop can be written as <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                          style="margin-right: 0.2222em;"></span><span
                        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>As we have reversed the input linked lists, we will count the space consumed by the reversed lists. The
                <code>r1</code> linked list takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                space and <code>r2</code> takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space.
            </li>
            <li>Note: one could argue that because <code>r1</code> and <code>r2</code> are only referencing the input
                lists and not making copies of them, we are using <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(1)O(1)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord">1</span><span
                        class="mclose">)</span></span></span></span></span> space. In most problems, you wouldn't count
                the input as part of the space complexity because the input doesn't contribute toward the algorithm. In
                this approach, the input is used heavily by our algorithm in terms of logic, and thus, we are counting
                it as part of the space complexity.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>