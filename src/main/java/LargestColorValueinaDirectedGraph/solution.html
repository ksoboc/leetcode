<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Largest Color Value in a Directed Graph</title>
</head>
<body>
<h2 id="solution">Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>We are given a directed graph with <code>n</code> nodes and <code>m</code> edges. We are also given a string <code>colors</code> where <code>colors[i]</code> is a lowercase English letter representing the color of the <span class="math math-inline"><span class="katex"><span class="katex-mathml">ithi^{th}</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.8491em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8491em;"><span style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">h</span></span></span></span></span></span></span></span></span></span></span></span></span> node in this graph (0-indexed).</p>
<p>Our task is to return the maximum frequency of any color that occurs in any path in the given graph.</p>
<hr>
<h3 id="approach-1-topological-sort-using-kahns-algorithm">Approach 1: Topological Sort Using Kahn's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>To find the maximum frequency of a color in a directed graph, we must iterate over all of its paths in an optimal manner. If we know the maximum frequency of all the colors for paths ending at <code>u</code>, we can use it to calculate the frequency of all colors for paths that use the outgoing edges from <code>u</code>.</p>
<p>If there is an edge from <code>u -&gt; v</code>, the path ending at <code>v</code> will have the same color frequencies as the path ending at <code>u</code>, except that the color of <code>v</code> will be incremented by one.</p>
<p>Now, if we do this for all the nodes that have an incoming edge to <code>v</code> and take the maximum frequency of each color across these edges, we will have the maximum frequency of all the colors for paths ending at <code>v</code>. After covering all the edges going into <code>v</code>, we can use the maximum frequency of all the colors stored in <code>v</code> for edges going out of <code>v</code>.</p>
<p>We notice that for each edge <code>u -&gt; v</code>, we must first obtain the maximum frequency of all the colours for paths ending until <code>u</code>, and only then can we form the answers for paths ending until <code>v</code>. This leads us to consider using topological sort to solve the problem.</p>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge <code>u -&gt; v</code> from vertex <code>u</code> to vertex <code>v</code>, <code>u</code> comes before <code>v</code> in the ordering.</p>
<p>In a directed acyclic graph, we can use Kahn's algorithm to get the topological ordering. Kahn’s algorithm works by keeping track of the number of incoming edges into each node (indegree). It works by repeatedly visiting the nodes with an indegree of zero and deleting all the edges associated with it leading to a decrement of indegree for the nodes whose incoming edges are deleted. This process continues until no elements with zero indegree can be found.</p>
<blockquote>
  <p>If you are not familiar with Kahn's algorithm, we suggest you read our <a href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/" target="_blank">Leetcode Explore Card</a>.</p>
</blockquote>
<p>We also need to detect if a cycle is in the graph and return <code>-1</code> if so. The advantage of using Kahn's algorithm is that it also aids in the detection of graph cycles.</p>
<p>Let's perform Kahn's algorithm on directed graph having a cycle. Here's a visual step-by-step represenntation of how it would work:</p>
<p><img src="1857-1.png" alt="img"></p>
<p>We can see that if there is a cycle, the indegree of nodes in the cycle cannot be set to <code>0</code> due to cyclic dependency. We are unable to visit the cycle's nodes. So, if the number of visited nodes is less than the total number of nodes in the graph, we have a cycle.</p>
<p>To solve the problem, we create a 2D-array <code>count</code> with <code>n</code> rows and <code>26</code> columns, where <code>n</code> is the number of graph nodes. We have an array of size <code>26</code> for each node to store the maximum frequency of each colour across the paths that end at the node.</p>
<p>We use Kahn's algorithm to perform the topological sort. A popped-out <code>node</code> indicates that all of its incoming edges have been processed, and it can now be used to iterate over all of its outgoing edges. So for each <code>node -&gt; neighbor</code> edge, we use <code>count[neighbor][i] = max(count[neighbor][i], count[node][i])</code> (we use max here instead of just setting it because there could be multiple ways to reach the neighbor) for all colors <code>i</code>.</p>
<p>We also need to count the colour of <code>node</code>. So when <code>node</code> is popped (or pushed) out of the queue, we increase the frequency of the colour of <code>node</code> by '1'.</p>
<p>We make an <code>answer</code> variable to compute the answer. We update it every time when <code>node</code> is popped out of the queue by simply taking <code>node</code>'s colour into account. We perform <code>answer = max(answer, count[node][colors[node] - 'a'])</code>.</p>
<p>You may have noticed that we can update <code>answer</code> each time we update the frequencies of the colours using the outgoing edges of <code>nodes</code>, but only the <code>node</code> colour is sufficient. This is because on any path with the highest frequency of a particular colour, we can shorten it by starting from the first node with that colour and keeping the same count of the colour on this path. As a result, simply using the colour of the node itself suffices for the answer computations.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
  <li>Create an integer variable <code>n = colors.length()</code> which stores the number of nodes in the graph.</li>
  <li>Create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all nodes with an incoming edge from node <code>x</code>.</li>
  <li>Create an array <code>indegree</code> of length <code>n</code> where <code>indegree[x]</code> stores the number of edges entering node <code>x</code>.</li>
  <li>Create a 2D-array <code>count</code> with <code>n</code> rows and <code>26</code> columns where <code>count[x]</code> keeps track of the maximum frequencies of all the colors for paths that end at node <code>x</code>. Note that color <code>a</code> corresponds to column <code>0</code>, <code>b</code> corresponds to column <code>1</code>, and so on.</li>
  <li>Initialize a queue of integers <code>q</code> and start a BFS algorithm moving from the leaf nodes to the parent nodes.</li>
  <li>Begin the BFS traversal by pushing all of the leaf nodes (<code>indegree</code> equal to <code>0</code>) in the queue.</li>
  <li>Create two integer variables <code>answer = 0</code> to store the answer to the problem and <code>nodesSeen = 0</code> to count number of visited nodes.</li>
  <li>While the queue is not empty;
    <ul>
      <li>Dequeue the first <code>node</code> from the queue.</li>
      <li>Increment the frequency of the color of <code>node</code> by <code>1</code> and also update <code>answer</code>. We perform <code>answer = max(answer, ++count[node][colors[node] - 'a'])</code>.</li>
      <li>Increment <code>nodesSeen</code> by <code>1</code>.</li>
      <li>For each <code>neighbor</code> (nodes that have an incoming edge from <code>node</code>) of <code>node</code>, we try to update the frequencies of all colors stored for <code>neighbor</code> to cover all the paths that use <code>node -&gt; neighbor</code> edge. We perform <code>count[neighbor][i] = max(count[neighbor][i], count[node][i])</code> for every color <code>i</code> where color <code>a</code> corresponds to <code>0</code>, <code>b</code> corresponds to <code>1</code>, and so on.</li>
      <li>We further decrement <code>indegree[neighbor]</code>by <code>1</code> to delete the <code>node -&gt; neighbor</code> edge.</li>
      <li>If <code>indegree[neighbor] == 0</code>, it means that <code>neighbor</code> behaves as a leaf node, so we push <code>neighbor</code> in the queue.</li>
    </ul>
  </li>
  <li>If number of nodes visited is less than total number of nodes, i.e., <code>nodesSeen &lt; n</code> we return <code>-1</code> as there must be a cycle. Otherwise, we return <code>answer</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
  Java
  <code>
    class Solution {
  public int largestPathValue(String colors, int[][] edges) {
        int n = colors.length();
        Map<Integer, List<Integer>> adj = new HashMap<>();
        int[] indegree = new int[n];

        for (int[] edge : edges) {
            adj.computeIfAbsent(edge[0], k->new ArrayList<Integer>()).add(edge[1]);
            indegree[edge[1]]++;
        }

        int[][] count = new int[n][26];
        Queue<Integer> q = new LinkedList<>();

        // Push all the nodes with indegree zero in the queue.
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.offer(i);
            }
        }

        int answer = 1, nodesSeen = 0;
        while (!q.isEmpty()) {
            int node = q.poll();
            answer = Math.max(answer, ++count[node][colors.charAt(node) - 'a']);
            nodesSeen++;

            if (!adj.containsKey(node)) {
                continue;
            }

            for (int neighbor : adj.get(node)) {
                for (int i = 0; i < 26; i++) {
                    // Try to update the frequency of colors for the neighbor to include paths
                    // that use node->neighbor edge.
                    count[neighbor][i] = Math.max(count[neighbor][i], count[node][i]);
                }

                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    q.offer(neighbor);
                }
            }
        }

        return nodesSeen < n ? -1 : answer;
    }
}
  </code>
  C++
  <code>
    class Solution {
public:
    int largestPathValue(string colors, vector<vector<int>>& edges) {
        int n = colors.length();
        vector<vector<int>> adj(n);
        vector<int> indegree(n);

        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
            indegree[edge[1]]++;
        }

        vector<vector<int>> count(n, vector<int>(26));
        queue<int> q;

        // Push all the nodes with indegree zero in the queue.
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        int answer = 0, nodesSeen = 0;
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            answer = max(answer, ++count[node][colors[node] - 'a']);
            nodesSeen++;

            for (auto& neighbor : adj[node]) {
                for (int i = 0; i < 26; i++) {
                    // Try to update the frequency of colors for neighbor to include paths
                    // that use node->neighbor edge.
                    count[neighbor][i] = max(count[neighbor][i], count[node][i]);
                }

                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    q.push(neighbor);
                }
            }
        }

        return nodesSeen < n ? -1 : answer;
    }
};
  </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> be the number of nodes and <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> be the number of edges in the graph.</p>
<ul>
  <li>
    <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅m+26⋅n)=O(m+n)O(26 \cdot m + 26 \cdot n) = O(m + n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
    <ul>
      <li>Initializing the <code>adj</code> takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time as we go through all the edges. The <code>indegree</code> array take <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time and the <code>count</code> array takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅n)O(26 \cdot n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.</li>
      <li>Each queue operation takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span></span> time, and a single node will be pushed once, leading to <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> operations for <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> nodes. We iterate over the neighbor of each node that is popped out of the queue iterating over all the edges once. Since there are <code>m</code> edges at most and while iterating over each edge we try to update the frequencies of all the <span class="math math-inline"><span class="katex"><span class="katex-mathml">2626</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">26</span></span></span></span></span> colors, it would take <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅m)O(26 \cdot m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time.</li>
    </ul>
  </li>
  <li>
    <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+26⋅n)=O(m+n)O(m + 26 \cdot n) = O(m + n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
    <ul>
      <li>The <code>adj</code> arrays takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> space. The <code>count</code> array takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅n)O(26 \cdot n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.</li>
      <li>The queue can have no more than <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> elements in the worst-case scenario. It would take up <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space in that case.</li>
    </ul>
  </li>
</ul>
<hr>
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>In the previous approach, we obtained the maximum frequencies of the colours for the paths ending at <code>u</code> first and then moved to <code>v</code> for an edge <code>u -&gt; v</code>. We can also consider going in the opposite direction. We can use the maximum frequencies of colours across all paths that begin with <code>v</code> to form the maximum frequencies of colours for paths that begin with <code>u</code>. We can update the frequency of colours similar to the previous approach.</p>
<p>Using depth first search, we can also detect a cycle. To detect a cycle, we must keep track of the vertices that are currently in the function's recursion stack for DFS traversal. If a vertex is reached that is already in the recursion stack then there is a cycle in the graph.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
  <li>Create an integer variable <code>n = colors.length()</code> which stores the number of nodes in the graph.</li>
  <li>Create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all nodes with an incoming edge from node <code>x</code>.</li>
  <li>Create a 2D-array <code>count</code> with <code>n</code> rows and <code>26</code> columns where <code>count[x]</code> keeps track of the maximum frequencies of all the colors among all the paths that begin at node <code>x</code>. Note, the definition of <code>count</code> is opposite in this case. The color <code>a</code> corresponds to column <code>0</code>, <code>b</code> corresponds to column <code>1</code>, and so on.</li>
  <li>Create two boolean arrays, <code>visit</code> and <code>inStack</code>, each of size <code>n</code>. The <code>visit</code> array keeps track of visited nodes and <code>inStack</code> keeps track of nodes that are currently in the ongoing DFS stack. It will help us to detect cycle in the graph.</li>
  <li>Create an integer variable <code>answer = 0</code> to store the answer to the problem.</li>
  <li>For each node we begin the DFS traveral. We implement the <code>dfs</code> method which takes six parameters: an integer <code>node</code> from which the current traversal begins, <code>colors</code>, <code>adj</code>, <code>count</code>, <code>visit</code> and <code>inStack</code>. It returns the maximum frequency of the color of <code>node</code> that we can get across all the paths starting from <code>node</code>. We return infinity if there is a cycle, which we can detect by checking <code>inStack</code>. For each node <code>i</code>, we update <code>answer</code> whenever we can using <code>answer = max(answer, dfs(i, colors, adj, count, visit, inStack))</code>:
    <ul>
      <li>If <code>node</code> is already present in <code>inStack</code>, we have a cycle. We return infinity.</li>
      <li>If <code>node</code> is already visited, we return the frequency of <code>node</code>'s color, i.e., <code>count[node][colors[node] - 'a']</code>.</li>
      <li>We mark <code>node</code> as visited and also set <code>inStack[node] = true</code>.</li>
      <li>We iterate over all the outgoing edges of <code>node</code> and for each <code>neighbor</code>, we recursively call <code>dfs(neighbor, colors, adj, count, visit, inStack)</code>. If we get a cycle from <code>neighbor</code>, we return infinity. Otherwise, we try to update the frequencies of all colors stored for <code>node</code> by including the paths that use the <code>node -&gt; neighbor</code> edge. We perform <code>count[node][i] = max(count[neighbor][i], count[node][i])</code> for every color <code>i</code> where <code>a</code> corresponds to <code>0</code>, <code>b</code> corresponds to <code>1</code>, and so on.</li>
      <li>After we have processed all the outgoing edges of <code>node</code>, we increment the frequency of <code>node</code>'s color by <code>1</code> to count <code>node</code> itself.</li>
      <li>Mark <code>inStack[node] = false</code> to mark <code>node</code> as out of stack.</li>
      <li>Similar to the previous approach, it is sufficient to just use the frequency of <code>node</code>'s color. We return <code>count[node][colors[node] - 'a']</code>.</li>
    </ul>
  </li>
  <li>If <code>answer</code> is equal to infinity, we return <code>-1</code>, else we return <code>answer</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
  Java
  <code>
    class Solution {
    private int dfs(int node, String colors, Map<Integer, List<Integer>> adj, int[][] count,
            boolean[] visit, boolean[] inStack) {
        // If the node is already in the stack, we have a cycle.
        if (inStack[node]) {
            return Integer.MAX_VALUE;
        }
        if (visit[node]) {
            return count[node][colors.charAt(node) - 'a'];
        }
        // Mark the current node as visited and part of current recursion stack.
        visit[node] = true;
        inStack[node] = true;

        if (adj.containsKey(node)) {
            for (int neighbor : adj.get(node)) {
                if (dfs(neighbor, colors, adj, count, visit, inStack) == Integer.MAX_VALUE) {
                    return Integer.MAX_VALUE;
                }
                for (int i = 0; i < 26; i++) {
                    count[node][i] = Math.max(count[node][i], count[neighbor][i]);
                }
            }
        }

        // After all the incoming edges to the node are processed,
        // we count the color on the node itself.
        count[node][colors.charAt(node) - 'a']++;
        // Remove the node from the stack.
        inStack[node] = false;
        return count[node][colors.charAt(node) - 'a'];
    }

    public int largestPathValue(String colors, int[][] edges) {
        int n = colors.length();
        Map<Integer, List<Integer>> adj = new HashMap<>();
        int[] indegree = new int[n];

        for (int[] edge : edges) {
            adj.computeIfAbsent(edge[0], k->new ArrayList<Integer>()).add(edge[1]);
            indegree[edge[1]]++;
        }

        int[][] count = new int[n][26];
        boolean[] visit = new boolean[n];
        boolean[] inStack = new boolean[n];
        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = Math.max(answer, dfs(i, colors, adj, count, visit, inStack));
        }

        return answer == Integer.MAX_VALUE ? -1 : answer;
    }
}
  </code>
  C++
  <code>
    class Solution {
public:
    int dfs(int node, string& colors, vector<vector<int>>& adj, vector<vector<int>>& count,
            vector<bool>& visit, vector<bool>& inStack) {
        // If the node is already in the stack, we have a cycle.
        if (inStack[node]) {
            return INT_MAX;
        }
        if (visit[node]) {
            return count[node][colors[node] - 'a'];
        }
        // Mark the current node as visited and part of current recursion stack.
        visit[node] = true;
        inStack[node] = true;

        for (auto& neighbor : adj[node]) {
            if (dfs(neighbor, colors, adj, count, visit, inStack) == INT_MAX) {
                return INT_MAX;
            }
            for (int i = 0; i < 26; i++) {
                count[node][i] = max(count[node][i], count[neighbor][i]);
            }
        }

        // After all the incoming edges to the node are processed,
        // we count the color on the node itself.
        count[node][colors[node] - 'a']++;
        // Remove the node from the stack.
        inStack[node] = false;
        return count[node][colors[node] - 'a'];
    }

    int largestPathValue(string colors, vector<vector<int>>& edges) {
        int n = colors.length();
        vector<vector<int>> adj(n);
        for (auto& edge : edges) {
            adj[edge[0]].push_back(edge[1]);
        }

        vector<vector<int>> count(n, vector<int>(26));
        vector<bool> visit(n), inStack(n);
        int answer = 0;
        for (int i = 0; i < n; i++) {
            answer = max(answer, dfs(i, colors, adj, count, visit, inStack));
        }

        return answer == INT_MAX ? -1 : answer;
    }
};
  </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> be the number of nodes and <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span> be the number of edges in the graph.</p>
<ul>
  <li>
    <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅m+26⋅n)=O(m+n)O(26 \cdot m + 26 \cdot n) = O(m + n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
    <ul>
      <li>Initializing the <code>adj</code> takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time as we go through all the edges. The <code>count</code> array takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅n)O(26 \cdot n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.</li>
      <li>The <code>dfs</code> function visits each node once, which takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time in total. Since there are <code>m</code> edges at most and while iterating over each edge we try to update the frequencies of all the <span class="math math-inline"><span class="katex"><span class="katex-mathml">2626</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">26</span></span></span></span></span> colors, it would take <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅m)O(26 \cdot m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time.</li>
    </ul>
  </li>
  <li>
    <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+26⋅n)=O(m+n)O(m + 26 \cdot n) = O(m + n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
    <ul>
      <li>The <code>adj</code> arrays takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> space. The <code>count</code> array takes <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(26⋅n)O(26 \cdot n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">26</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.</li>
      <li>The recursion call stack used by <code>dfs</code> can have no more than <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span> elements in the worst-case scenario. It would take up <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space in that case.</li>
    </ul>
  </li>
</ul>
</body>
</html>