<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Restore The Array - Solution</title>
</head>
<body>
<h2 id="solution">Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>For example, we have <code>s = 19930613</code> and <code>k = 1000</code>. Some of the valid arrays are colored in
    green because they can be printed as <code>s</code>. However, the red arrays are invalid since they either contain
    leading zeros or are invalid integers.</p>
<p><img src="1.png" alt="img"></p>
<hr>
<h3 id="approach-1-dynamic-programming-top-down">Approach 1: Dynamic Programming (Top Down)</h3>
<h4 id="intuition">Intuition</h4>
<p>In order to find all arrays that can be printed as the entire string <code>s</code>, we can start with finding all
    possible first integers, as shown in the picture below, we find 3 possible first integers, <code>1</code>,
    <code>19</code>, and <code>199</code>. For each case, we can continue moving on to the remaining substring and solve
    the subproblems and so on. The tree-like structure of this problem implies that we can use the depth-first-search
    method to solve it.</p>
<p>Suppose the size of the input string is <code>m</code>, let <code>dfs(x)</code> be the number of arrays for the
    suffix substring <code>s[x ~ m - 1]</code>.</p>
<p><img src="td.png" alt="img"></p>
<p>Write the process in the picture above:</p>
<ul>
    <li>
        <p>If we let <code>1</code> be the first number, then we shall look for <code>dfs(1)</code>, the number of
            arrays that can be printed as <code>s[1 ~ m - 1]</code>.</p>
    </li>
    <li>
        <p>If we let <code>19</code> be the first number, then we shall look for <code>dfs(2)</code>, the number of
            arrays that can be printed as <code>s[2 ~ m - 1]</code>.</p>
    </li>
    <li>
        <p>If we let <code>199</code> be the first number, then we shall look for <code>dfs(3)</code>, the number of
            arrays that can be printed as <code>s[3 ~ m - 1]</code>.</p>
    </li>
</ul>
<p>In conclusion, the above observation can be rewritten as <code>dfs(0) = dfs(1) + dfs(2) + dfs(3)</code>. We can move
    on to <code>dfs(1)</code> and solve this subproblem, then move on to <code>dfs(2)</code>, and so on, we will handle
    all subproblems before getting <code>dfs(0)</code>.</p>
<p>However, there might be repeated computation, we can use an auxiliary array <code>dp</code> as memory to avoid double
    counting. We update <code>dp[x] = dfs(x)</code> immediately after getting the value of <code>dfs(x)</code>, so we
    don't need to recalculate <code>dfs(start)</code> later.</p>
<p><img src="5.png" alt="img"></p>
<p>The recursion stops when we reach base cases below, we can just return the corresponding value:</p>
<ul>
    <li>
        <p>If the digit <code>s[start]</code> equals <code>0</code>, it means we can't find any valid array since
            leading zeros are not allowed. Return <code>0</code>.</p>
    </li>
    <li>
        <p>If the index <code>start</code> equals <code>m</code> (the length of <code>s</code>), it means we are looking
            for the number of arrays that can be printed as an empty string. Only the empty array works, so we return
            <code>1</code>.</p>
    </li>
</ul>
<br>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>
        <p>Create an array <code>dp</code> of size <code>m + 1</code>, to store the value of <code>dfs(x)</code>.</p>
    </li>
    <li>
        <p>To get the value of <code>dfs(start)</code>, if a non-zero <code>dp[start]</code> exists, it means we have
            already got its value, return <code>dp[start]</code>. Otherwise:</p>
        <ul>
            <li>If <code>s[start] == 0</code>, return <code>0</code>.</li>
            <li>If <code>start = m</code>, return <code>1</code>.</li>
            <li>Initialize <code>count = 0</code>, the number of valid arrays.</li>
            <li>Then we look for every possible ending index <code>end</code> by iterating over indexes from
                <code>start</code>. If <code>s[start ~ end]</code> represents a valid integer, we continue looking for
                the subproblem <code>dfs(end + 1)</code> and update <code>count</code> as <code>count += dfs(end +
                    1)</code>.
            </li>
            <li>Update <code>dp[start]</code> as <code>dfs(start)</code>.</li>
        </ul>
    </li>
    <li>
        <p>Return <code>dfs(0)</code>.</p>
    </li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    int mod = 1_000_000_007;

    // Number of possible splits for substring s[start ~ m-1].
    private int dfs(int[] dp, int start, String s, int k) {
        // If we have already updated dp[start], return it.
        if (dp[start] != 0)
            return dp[start];

        // There is only 1 split for an empty string.
        if (start == s.length())
            return 1;

        // Number can't have leading zeros.
        if (s.charAt(start) == '0')
            return 0;

        // For all possible starting number, add the number of arrays
        // that can be printed as the remaining string to count.
        int count = 0;
        for (int end = start; end < s.length(); ++end) {
            String currNumber = s.substring(start, end + 1);
            if (Long.parseLong(currNumber) > k)
                break;
            count = (count + dfs(dp, end + 1, s, k)) % mod;
        }

        // Update dp[start] so we don't recalculate it later.
        dp[start] = count;
        return count;
    }

    public int numberOfArrays(String s, int k) {
        int m = s.length();
        int[] dp = new int[m + 1];
        return dfs(dp, 0, s, k);
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        m, n = len(s), len(str(k))
        mod = 10 ** 9 + 7
        dp = [0] * (m + 1)

        # Number of possible splits for s[start ~ m-1].
        def dfs(start):
            # If we have already updated dp[start], return it.
            if dp[start]:
                return dp[start]

            # There is only 1 split for an empty string.
            if start == m:
                return 1

            # Number can't have leading zeros.
            if s[start] == '0':
                return 0

            # For all possible starting number, add the number of arrays
            # that can be printed as the remaining string to count.
            count = 0
            for end in range(start, m):
                curr_number = s[start: end + 1]
                if int(curr_number) > k:
                    break
                count += dfs(end + 1)

            # Update dp[start] so we don't recalculate it later.
            dp[start] = count % mod
            return count

        return dfs(0) % mod
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Let <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html"
                                                                                                    aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
    be the length of the input string <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅log⁡k)O(m \cdot \log k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                      style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>
                <p>We create <code>dp</code> of length <code>m + 1</code> for memory, it takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    steps to update them.</p>
            </li>
            <li>
                <p>At each step <code>s[start]</code>, we look for all possible ending index <code>end</code>. In the
                    worst-case scenario, we will iterate over <span class="math math-inline"><span class="katex"><span
                            class="katex-mathml">log⁡k\log k</span><span class="katex-html" aria-hidden="true"><span
                            class="base"><span class="strut"
                                               style="height: 0.8889em; vertical-align: -0.1944em;"></span><span
                            class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                                      style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal"
                            style="margin-right: 0.03148em;">k</span></span></span></span></span> indexes before <code>currNumber</code>
                    is larger than <code>k</code>, because each iteration increases <code>currNumber</code> by a
                    magnitude.</p>
            </li>
            <li>
                <p>To sum up, the overall time complexity is <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(m⋅log⁡k)O(m \cdot \log k)</span><span class="katex-html"
                                                                                     aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                          style="margin-right: 0.2222em;"></span><span
                        class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                                  style="margin-right: 0.1667em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                        class="mclose">)</span></span></span></span></span>.</p>
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <ul>
            <li>We create an array <code>dp</code> of length <code>m + 1</code>.</li>
        </ul>
    </li>
</ul>
<br>
<hr>
<h3 id="approach-2-dynamic-programming-bottom-up">Approach 2: Dynamic Programming (Bottom Up)</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also solve this problem iteratively. That is, to solve the subproblem first, then move on to larger
    problems.</p>
<p>Similarly, we let <code>dp[i]</code> be the number of arrays for the prefix substring <code>s[0 ~ i]</code>, we will
    iterate over every index before getting <code>dp[m - 1]</code>. Suppose we have found <code>dp[start - 1]</code>.
    Then we move on to the index <code>start</code> and iterate for the ending index <code>end</code> and check if the
    integer made of <code>s[start ~ end]</code> is valid. If <code>s[start ~ end]</code> represents a valid integer, it
    means every valid array that can be printed as <code>s[0 ~ start - 1]</code> can also be printed as <code>s[0 ~
        end]</code> by appending the integer <code>s[start ~ end]</code>, so we increment <code>dp[end]</code> by <code>dp[start
        - 1]</code>.</p>
<p>As shown in the picture below, imagine that we have found <code>dp[2]</code>.</p>
<ul>
    <li><code>s[3 ~ 3] = 3</code> is a valid number, it means every array that can be printed as <code>s[0 ~ 2]</code>
        can also be printed as <code>s[0 ~ 3]</code> by appending <code>3</code>.
    </li>
    <li><code>s[3 ~ 4] = 30</code> is a valid number, it means every array that can be printed as <code>s[0 ~ 2]</code>
        can also be printed as <code>s[0 ~ 4]</code> by appending <code>30</code>.
    </li>
    <li><code>s[3 ~ 5] = 306</code> is a valid number, it means every array that can be printed as <code>s[0 ~ 2]</code>
        can also be printed as <code>s[0 ~ 5]</code> by appending <code>306</code>.
    </li>
</ul>
<p><img src="3.png" alt="img"></p>
<p>We create an array <code>dp</code> as memory where <code>dp[i]</code> stores the number of arrays that can be printed
    as the prefix string <code>s[0 ~ i-1]</code>. Initialize <code>dp[0] = 1</code> as there is one array (empty array)
    that can be printed as an empty string.</p>
<p>Back to the example above, suppose we have updated <code>dp[3]</code>.</p>
<ul>
    <li><code>s[3 ~ 3] = 3</code> is a valid number, so we update <code>dp[4] += dp[3]</code>.</li>
    <li><code>s[3 ~ 4] = 30</code> is a valid number, so we update <code>dp[5] += dp[3]</code>.</li>
    <li><code>s[3 ~ 5] = 306</code> is a valid number, so we update <code>dp[6] += dp[3]</code>.</li>
</ul>
<p>Once we finish the iteration, <code>dp[m]</code> is the number of arrays that can be printed as the entire string
    <code>s</code>.</p>
<br>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>
        <p>Let <code>m</code> be the size of input string <code>s</code>. We create an array <code>dp</code> of size
            <code>m + 1</code>. Set <code>dp[0] = 1</code>.</p>
    </li>
    <li>
        <p>Iterate over each starting index <code>start</code>. If <code>s[start] = 0</code>, repeat step 2 and move on
            to the next index. Otherwise:</p>
        <ul>
            <li>Start an inner iteration over the ending index <code>end</code> from <code>start</code>.</li>
            <li>If the number represented by <code>s[start ~ end]</code> is valid, increment <code>dp[end + 1]</code> by
                <code>dp[start]</code>.
            </li>
        </ul>
    </li>
    <li>
        <p>Return <code>dp[m + 1]</code> when the iteration ends.</p>
    </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public int numberOfArrays(String s, int k) {
        int m = s.length(), n = String.valueOf(k).length();
        int mod = 1_000_000_007;

        // dp[i] records the number of arrays that can be printed as
        // the prefix substring s[0 ~ i - 1]
        int[] dp = new int[m + 1];

        // Empty string has 1 valid split.
        dp[0] = 1;

        // Iterate over every digit, for each digit s[start]
        for (int start = 0; start < m; ++start) {
            if (s.charAt(start) == '0')
                continue;

            // Iterate over ending digit end and find all valid numbers
            // s[start ~ end].
            for (int end = start; end < m; ++end) {
                String currNumber = s.substring(start, end + 1);

                if (Long.parseLong(currNumber) > k)
                    break;

                // If s[start ~ end] is valid, increment dp[end + 1] by dp[start].
                dp[end + 1] = (dp[end + 1] + dp[start]) % mod;
            }
        }
        return dp[m];
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        m, n = len(s), len(str(k))
        mod = 10 ** 9 + 7

        # dp[i] records the number of arrays that can be printed as
        # the prefix substring s[0 ~ i - 1]
        dp = [1] + [0] * m

        # Iterate over every digit, for each digit s[start]:
        for start in range(m):
            if s[start] == '0':
                continue
            count = 0

            # Iterate over ending digit end and find all valid numbers
            # s[start ~ end].
            for end in range(start, m):
                curr_number = s[start:end + 1]
                if int(curr_number) > k:
                    break

                # If s[start ~ end] is valid, increment dp[end + 1] by dp[start].
                dp[end + 1] += dp[start]
                dp[end + 1] %= mod

        return dp[-1]
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Let <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html"
                                                                                                    aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
    be the length of the input string <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅log⁡k)O(m \cdot \log k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                      style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>
                <p>We create <code>dp</code> of length <code>m + 1</code> as memory, it takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    steps to update them.</p>
            </li>
            <li>
                <p>At each iteration step <code>s[start]</code>, we look for all possible ending index <code>end</code>.
                    In the worst-case scenario, we have to traverse <span class="math math-inline"><span
                            class="katex"><span class="katex-mathml">log⁡k\log k</span><span class="katex-html"
                                                                                             aria-hidden="true"><span
                            class="base"><span class="strut"
                                               style="height: 0.8889em; vertical-align: -0.1944em;"></span><span
                            class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                                      style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal"
                            style="margin-right: 0.03148em;">k</span></span></span></span></span> indexes before <code>currNumber</code>
                    is larger than <code>k</code>. This is because each iteration increases <code>currNumber</code> by a
                    magnitude.</p>
            </li>
            <li>
                <p>To sum up, the overall time complexity is <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(m⋅log⁡k)O(m \cdot \log k)</span><span class="katex-html"
                                                                                     aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                          style="margin-right: 0.2222em;"></span><span
                        class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                                  style="margin-right: 0.1667em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                        class="mclose">)</span></span></span></span></span>.</p>
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <ul>
            <li>We create an array <code>dp</code> of size <code>m + 1</code>.</li>
        </ul>
    </li>
</ul>
<br>
<hr>
<h3 id="approach-3-dynamic-programming-with-less-space-complexity">Approach 3: Dynamic Programming (with less space
    complexity)</h3>
<h4 id="intuition-2">Intuition</h4>
<p>In approach 2, we create an array <code>dp</code> of size <code>m + 1</code>. At each iteration step for the ending
    index <code>s[end]</code>, we increment <code>dp[end + 1]</code> by <code>dp[start]</code>. Each iteration over
    <code>end</code> increases the current integer made by <code>s[start ~ end]</code> by a magnitude, thus there are at
    most <span class="math math-inline"><span class="katex"><span class="katex-mathml">(log⁡k)(\log k)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mopen">(</span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span
            class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal"
                                                                        style="margin-right: 0.03148em;">k</span><span
            class="mclose">)</span></span></span></span></span> cells we need to update before the integer exceeds
    <code>k</code>.</p>
<p>The question is, can we reduce the size of <code>dp</code> if only part of it (<span class="math math-inline"><span
        class="katex"><span class="katex-mathml">(log⁡k)(\log k)</span><span class="katex-html" aria-hidden="true"><span
        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
        class="mopen">(</span><span class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span
        class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal"
                                                                    style="margin-right: 0.03148em;">k</span><span
        class="mclose">)</span></span></span></span></span>) are used each time?</p>
<p><img src="k1.png" alt="img"></p>
<p>As shown in the picture below, at most <span class="math math-inline"><span class="katex"><span class="katex-mathml">log⁡k\log k</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 0.8889em; vertical-align: -0.1944em;"></span><span
        class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                  style="margin-right: 0.1667em;"></span><span
        class="mord mathnormal" style="margin-right: 0.03148em;">k</span></span></span></span></span> cells are updated
    at each step. Once we pass the starting index <code>start</code> and move on to the next starting index <code>start
        + 1</code>, we will never need the value of <code>dp[start]</code> anymore. This implies that we don't need to
    store the entire <code>dp</code> as we did in approach 2. Instead, we can use less space by only maintaining a 'live
    window' of size <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">log⁡k+1\log k + 1</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mop">lo<span
            style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span
            class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                   style="margin-right: 0.2222em;"></span><span
            class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>.
</p>
<p><img src="k3.png" alt="img"></p>
<p>We can create <code>new_dp</code> of size <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">log⁡k+1\log k + 1</span><span class="katex-html" aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mop">lo<span
        style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                              style="margin-right: 0.1667em;"></span><span
        class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                               style="margin-right: 0.2222em;"></span><span
        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>. For
    distinction, let's call the previous array <code>old_dp</code>. Since the <code>new_dp</code> might be shorter than
    <code>s</code>, whenever we need to update <code>new_dp[x]</code> as we did for <code>old_dp[x]</code>, we can get
    the remainder of the index <code>x</code> for modulo <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">log⁡k+1\log k + 1</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mop">lo<span
            style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span
            class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                   style="margin-right: 0.2222em;"></span><span
            class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>
    as <span class="math math-inline"><span class="katex"><span class="katex-mathml">x&nbsp;%&nbsp;(log⁡k+1)x\ \% \ (\log k + 1)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal">x</span><span class="mspace">&nbsp;</span><span class="mord">%</span><span
            class="mspace">&nbsp;</span><span class="mopen">(</span><span class="mop">lo<span
            style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span
            class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                   style="margin-right: 0.2222em;"></span><span
            class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord">1</span><span class="mclose">)</span></span></span></span></span> and update <span
            class="math math-inline"><span class="katex"><span class="katex-mathml">new_dp[x&nbsp;%&nbsp;(log⁡k+1)]\text{new\_dp} [x\ \% \ (\log k + 1)]</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1.06em; vertical-align: -0.31em;"></span><span
            class="mord text"><span class="mord">new_dp</span></span><span class="mopen">[</span><span
            class="mord mathnormal">x</span><span class="mspace">&nbsp;</span><span class="mord">%</span><span
            class="mspace">&nbsp;</span><span class="mopen">(</span><span class="mop">lo<span
            style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span
            class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                   style="margin-right: 0.2222em;"></span><span
            class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord">1</span><span class="mclose">)]</span></span></span></span></span> to avoid the case of index
    out of range.</p>
<p><img src="k2.png" alt="img"></p>
<p>In the example below, the size of 'live' window is <code>4</code>. If we move to the next starting index
    <code>1</code>, <code>new_dp[0]</code> will represent <code>old_dp[4]</code>.</p>
<p><img src="k4.png" alt="img"></p>
<p>Before we move on to the next starting index <code>start + 1</code>, we need to reset the value representing the
    current starting index <code>start</code> as <code>0</code>, that is, <span class="math math-inline"><span
            class="katex"><span class="katex-mathml">new_dp[start&nbsp;%&nbsp;(log⁡k+1)]=0\text{new\_dp} [\text{start}\ \% \ (\log k + 1)] = 0</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1.06em; vertical-align: -0.31em;"></span><span
            class="mord text"><span class="mord">new_dp</span></span><span class="mopen">[</span><span
            class="mord text"><span class="mord">start</span></span><span class="mspace">&nbsp;</span><span
            class="mord">%</span><span class="mspace">&nbsp;</span><span class="mopen">(</span><span class="mop">lo<span
            style="margin-right: 0.01389em;">g</span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span
            class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                                   style="margin-right: 0.2222em;"></span><span
            class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord">1</span><span class="mclose">)]</span><span class="mspace"
                                                                     style="margin-right: 0.2778em;"></span><span
            class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span
            class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">0</span></span></span></span></span>.
    The reasons are as we said before:</p>
<blockquote>
    <p>Once we pass the index <code>start</code> and move on to the next index, we will never need the value of <code>dp[start]</code>
        anymore.</p>
</blockquote>
<p>Thus <span class="math math-inline"><span class="katex"><span class="katex-mathml">new_dp[start&nbsp;%&nbsp;(log⁡k+1)]\text{new\_dp} [\text{start}\ \% \ (\log k + 1)]</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1.06em; vertical-align: -0.31em;"></span><span
        class="mord text"><span class="mord">new_dp</span></span><span class="mopen">[</span><span
        class="mord text"><span class="mord">start</span></span><span class="mspace">&nbsp;</span><span
        class="mord">%</span><span class="mspace">&nbsp;</span><span class="mopen">(</span><span class="mop">lo<span
        style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                              style="margin-right: 0.1667em;"></span><span
        class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                               style="margin-right: 0.2222em;"></span><span
        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span
        class="mclose">)]</span></span></span></span></span> doesn't represent the cell <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">old_dp[start]\text{old\_dp} [\text{start}]</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1.06em; vertical-align: -0.31em;"></span><span
        class="mord text"><span class="mord">old_dp</span></span><span class="mopen">[</span><span
        class="mord text"><span class="mord">start</span></span><span
        class="mclose">]</span></span></span></span></span> anymore, but the cell with a larger index <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">old_dp[start+log⁡k+1]\text{old\_dp} [\text{start} + \log k + 1]</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1.06em; vertical-align: -0.31em;"></span><span
        class="mord text"><span class="mord">old_dp</span></span><span class="mopen">[</span><span
        class="mord text"><span class="mord">start</span></span><span class="mspace"
                                                                      style="margin-right: 0.2222em;"></span><span
        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 0.8889em; vertical-align: -0.1944em;"></span><span class="mop">lo<span
        style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                              style="margin-right: 0.1667em;"></span><span
        class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span class="mspace"
                                                                               style="margin-right: 0.2222em;"></span><span
        class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord">1</span><span
        class="mclose">]</span></span></span></span></span>, so we need to reset it as <code>0</code> and update it in
    the further steps.</p>
<br>
<h4 id="algorithm-2">Algorithm</h4>
<ol>
    <li>
        <p>We create an array <code>dp</code> of size <code>log k + 1</code>. Set <code>dp[0] = 1</code>.</p>
    </li>
    <li>
        <p>Iterate over each starting index <code>start</code>. If <code>s[start] = 0</code>, set <code>dp[start % (log
            k + 1)]</code> as <code>0</code>. Repeat step 2 and move on to the next index. Otherwise:</p>
        <ul>
            <li>Start an inner iteration over the ending index <code>end</code> from <code>start</code>.</li>
            <li>If the number represented by <code>s[start ~ end]</code> is valid, increment <code>dp[(end + 1) % (log k
                + 1)]</code> by <code>dp[start % (log k + 1)]</code>.
            </li>
            <li>Set <code>dp[start % (log k + 1)]</code> as <code>0</code>.</li>
        </ul>
    </li>
    <li>
        <p>Return <code>dp[(m + 1) % (log k + 1)]</code> when the iteration ends.</p>
    </li>
</ol>
<h4 id="implementation-2">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public int numberOfArrays(String s, int k) {
        int m = s.length(), n = String.valueOf(k).length();
        int mod = 1_000_000_007;

        // dp[i % (n + 1)] stands for the number of splits for substring s[0 ~ i - 1]
        int[] dp = new int[n + 1];

        // Empty string has 1 valid split.
        dp[0] = 1;

        // Iterate over every digit, for each digit s[start]
        for (int start = 0; start < m; ++start) {
            if (s.charAt(start) == '0') {
                dp[start % (n + 1)] = 0;
                continue;
            }

            // We travers forward to find all valid numbers s[start ~ end].
            for (int end = start; end < m; ++end) {
                String currNumber = s.substring(start, end + 1);

                if (Long.parseLong(currNumber) > k)
                    break;

                // If s[start ~ end] is valid, increment dp[(end + 1) % (n + 1)] by dp[start].
                dp[(end + 1) % (n + 1)] = (dp[(end + 1) % (n + 1)] + dp[start % (n + 1)]) % mod;
            }

            // Set dp[start % (n + 1)] as 0.
            dp[start % (n + 1)] = 0;
        }
        return dp[m % (n + 1)];
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:
        m, n = len(s), len(str(k))
        mod = 10 ** 9 + 7
        # dp[i % (n + 1)] records the number of arrays that can be printed as
        # the prefix substring s[0 ~ i - 1]
        dp = [1] + [0] * n

        # Iterate over every digit, for each digit s[start]:
        for start in range(m):
            if s[start] == '0':
                dp[start % (n + 1)] = 0
                continue

            # Iterate over ending digit end and find all valid numbers
            # s[start ~ end].
            for end in range(start, m):
                if int(s[start : end + 1]) > k:
                    break

                # If s[start ~ end] is valid, increment dp[(end + 1) % (n + 1)] by dp[start].
                dp[(end + 1) % (n + 1)] += dp[start % (n + 1)]
                dp[(end + 1) % (n + 1)] %= mod

            # Set dp[start % (n + 1)] as 0.
            dp[start % (n + 1)] = 0

        return dp[m % (n + 1)]
    </code>
</pre>
<h4 id="complexity-analysis-2">Complexity Analysis</h4>
<p>Let <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span class="katex-html"
                                                                                                    aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">m</span></span></span></span></span>
    be the length of the input string <code>s</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅log⁡k)O(m \cdot \log k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mop">lo<span
                style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                      style="margin-right: 0.1667em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>
                <p>It takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                    steps to iterate over string <code>s</code>.</p>
            </li>
            <li>
                <p>At each iteration step <code>s[start]</code>, we will look for all possible ending index
                    <code>end</code>. In the worst-case scenario, we have to traverse <span
                            class="math math-inline"><span class="katex"><span
                            class="katex-mathml">log⁡k\log k</span><span class="katex-html" aria-hidden="true"><span
                            class="base"><span class="strut"
                                               style="height: 0.8889em; vertical-align: -0.1944em;"></span><span
                            class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                                      style="margin-right: 0.1667em;"></span><span
                            class="mord mathnormal"
                            style="margin-right: 0.03148em;">k</span></span></span></span></span> indexes before <code>currNumber</code>
                    is larger than <code>k</code>. This is because each iteration increases <code>currNumber</code> by a
                    magnitude.</p>
            </li>
            <li>
                <p>To sum up, the overall time complexity is <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(m⋅log⁡k)O(m \cdot \log k)</span><span class="katex-html"
                                                                                     aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mspace"
                                                                                          style="margin-right: 0.2222em;"></span><span
                        class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mop">lo<span style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                                                  style="margin-right: 0.1667em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                        class="mclose">)</span></span></span></span></span>.</p>
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(logk)O(log k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal" style="margin-right: 0.01968em;">l</span><span
                class="mord mathnormal">o</span><span class="mord mathnormal"
                                                      style="margin-right: 0.03588em;">g</span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>We create an array <code>dp</code> of size <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">(log⁡k)(\log k)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mopen">(</span><span class="mop">lo<span
                    style="margin-right: 0.01389em;">g</span></span><span class="mspace"
                                                                          style="margin-right: 0.1667em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                    class="mclose">)</span></span></span></span></span>.
            </li>
        </ul>
    </li>
</ul>
<br>
</body>
</html>