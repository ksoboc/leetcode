<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Word Break</title>
</head>
<body>
<h2 id="solution-article">Solution Article</h2>
<hr>
<h4 id="approach-1-breadth-first-search">Approach 1: Breadth-First Search</h4>
<p><strong>Intuition</strong></p>
<p>Let's imagine the indices of <code>s</code> as a graph. Each index can be thought of as a node, which represents
    building <code>s</code> up to the index.</p>
<p>Adding a word to an existing string is like an edge between nodes. For a node <code>start</code>, we can move to node
    <code>end</code> if the substring of <code>s</code> between <code>start, end</code> exists in <code>wordDict</code>.
</p>
<p>For example, let's say we have <code>s = "leetcode"</code> and <code>wordDict = ["leet", "code"]</code>. We are
    currently at node <code>4</code>, which implies that we have built <code>"leet"</code> (the first 4 characters of
    <code>s</code>). We can move to node <code>8</code>, because the substring of <code>s</code> with indices <code>[4,
        8)</code> is <code>"code"</code>, which is in <code>wordDict</code>.</p>
<p>We start at node <code>0</code>, which represents the empty string. We want to reach node <code>s.length</code>,
    which implies that we have built the entire string. We can run a BFS to accomplish this traversal. If you're not
    familiar with BFS, check out the relevant <a
            href="https://leetcode.com/explore/learn/card/graph/620/breadth-first-search-in-graph/" target="_blank">Explore
        Card</a>.</p>
<p>At each node <code>start</code>, we iterate over all the nodes <code>end</code> that come after <code>start</code>.
    For each <code>end</code>, we check if the substring between <code>start, end</code> is in <code>wordDict</code>. If
    it is, we can add <code>end</code> to the queue.</p>
<p>We will first convert <code>wordDict</code> into a set so that we can perform the checks in constant time. We will
    also use a data structure <code>seen</code> to prevent us from visiting a node more than once.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Convert <code>wordDict</code> into a set <code>words</code>.</li>
    <li>Initialize a <code>queue</code> with <code>0</code> and a set <code>seen</code>.</li>
    <li>While the <code>queue</code> is not empty:
        <ul>
            <li>Remove the first element, <code>start</code>.</li>
            <li>If <code>start == s.length</code>, return <code>true</code>.</li>
            <li>Iterate <code>end</code> from <code>start + 1</code> up to and including <code>s.length</code>. For each
                <code>end</code>, if <code>end</code> has not been visited yet,
                <ul>
                    <li>Check the substring starting at <code>start</code> and ending before <code>end</code>. If it is
                        in <code>words</code>, add <code>end</code> to the queue and mark it in <code>seen</code>.
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Return <code>false</code> if the BFS finishes without reaching the final node.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
    class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> words = new HashSet<>(wordDict);
        Queue<Integer> queue = new LinkedList<>();
        boolean[] seen = new boolean[s.length() + 1];
        queue.add(0);

        while (!queue.isEmpty()) {
            int start = queue.remove();
            if (start == s.length()) {
                return true;
            }

            for (int end = start + 1; end <= s.length(); end++) {
                if (seen[end]) {
                    continue;
                }

                if (words.contains(s.substring(start, end))) {
                    queue.add(end);
                    seen[end] = true;
                }
            }
        }

        return false;
    }
}
                </code>
    C++
    <code>
        class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> words(wordDict.begin(), wordDict.end());
        queue<int> queue;
        vector<bool> seen(s.length(), false);
        queue.push(0);

        while (!queue.empty()) {
            int start = queue.front();
            queue.pop();

            if (start == s.length()) {
                return true;
            }

            for (int end = start + 1; end <= s.length(); end++) {
                if (seen[end]) {
                    continue;
                }

                if (words.find(s.substr(start, end - start)) != words.end()) {
                    queue.push(end);
                    seen[end] = true;
                }
            }
        }

        return false;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        words = set(wordDict)
        queue = deque([0])
        seen = set()

        while queue:
            start = queue.popleft()
            if start == len(s):
                return True

            for end in range(start + 1, len(s) + 1):
                if end in seen:
                    continue

                if s[start:end] in words:
                    queue.append(end)
                    seen.add(end)

        return False
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>, <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as the length of <code>wordDict</code>, and
    <span class="math math-inline"><span class="katex"><span class="katex-mathml">kk</span><span class="katex-html"
                                                                                                 aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.03148em;">k</span></span></span></span></span>
    as the average length of the words in <code>wordDict</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n3+m⋅k)O(n^3 + m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>There are <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> nodes. Because
            of <code>seen</code>, we never visit a node more than once. At each node, we iterate over the nodes in front
            of the current node, of which there are <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>. For each
            node <code>end</code>, we create a substring, which also costs <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>.</p>
        <p>Therefore, handling a node costs <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>, so the BFS could cost up to <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(n3)O(n^3)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">3</span></span></span></span></span></span></span></span><span
                class="mclose">)</span></span></span></span></span>. Finally, we also spent <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span> to create the set <code>words</code>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n+m⋅k)O(n + m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>We use <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space for
            <code>queue</code> and <code>seen</code>. We use <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                    class="mclose">)</span></span></span></span></span> space for the set <code>words</code>.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-2-top-down-dynamic-programming">Approach 2: Top-Down Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<blockquote>
    <p>If you're not familiar with dynamic programming, we recommend checking out the <a
            href="https://leetcode.com/explore/featured/card/dynamic-programming/" target="_blank">Dynamic Programming
        explore card</a>. This problem is on the difficult side, so we will assume that readers are already familiar
        with the principles of DP.</p>
</blockquote>
<p>Let's have a function <code>dp</code> that returns a boolean indicating if it is possible to build <code>s</code> up
    to and including the index <code>i</code>.</p>
<p>For example, given <code>s = "leetcode"</code> and <code>wordDict = ["leet", "code"]</code>, <code>dp(3)</code> would
    return <code>true</code>. <code>s</code> up to index <code>3</code> is <code>"leet"</code>, and we can build <code>"leet"</code>
    using the words in <code>wordDict</code>. The answer to the problem would be <code>dp(s.length - 1)</code>, which
    represents if we can build <code>s</code>.</p>
<p>The base case of this function is when <code>i &lt; 0</code>. This would represent an empty string, and we can always
    build an empty string by doing nothing. Therefore, <code>dp(i) = true</code> for <code>i &lt; 0</code>.</p>
<p>Given an index <code>i</code>, we need a recurrence relation to determine if <code>dp(i)</code> is <code>true</code>
    or <code>false</code>. For <code>dp(i)</code> to be <code>true</code>, there are two requirements:</p>
<ol>
    <li>First, there needs to be a <code>word</code> from <code>wordDict</code> that <strong>ends</strong> at index
        <code>i</code>. Given a <code>word</code>, the substring of <code>s</code> from indices <code>i - word.length +
            1</code> up to and including <code>i</code> should match <code>word</code>. We can check every
        <code>word</code> for this.
    </li>
    <li>If we manage to find a <code>word</code> that <strong>ends</strong> at index <code>i</code>, we would need to
        add it on top of another string (since we are building <code>s</code> by joining words together one by one). We
        need to make sure that the string we are adding onto is also buildable. If we find a <code>word</code> that
        passes the first check, it means <code>word</code> would start at index <code>i - word.length + 1</code>. The
        index before that is <code>i - word.length</code>. To check if the string ending at that index is buildable, we
        can refer to <code>dp(i - word.length)</code>.
    </li>
</ol>
<p>This gives us our recurrence relation:</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml">dp(i)=any(s[i&nbsp;-&nbsp;word.length&nbsp;+&nbsp;1,&nbsp;i]==word&nbsp;&amp;&amp;&nbsp;dp(i&nbsp;-&nbsp;word.length))\large{\text{dp(i)} = \text{any}(\text{s}[\text{i - word.length + 1, i}] == \text{word \&amp;\&amp; dp(i - \text{word.length})})}</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1.2em; vertical-align: -0.3em;"></span><span
        class="mord sizing reset-size6 size7"><span class="mord text"><span class="mord">dp(i)</span></span><span
        class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace"
                                                                                               style="margin-right: 0.2778em;"></span><span
        class="mord text"><span class="mord">any</span></span><span class="mopen">(</span><span class="mord text"><span
        class="mord">s</span></span><span class="mopen">[</span><span class="mord text"><span class="mord">i&nbsp;-&nbsp;word.length&nbsp;+&nbsp;1,&nbsp;i</span></span><span
        class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span
        class="mrel">==</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord text"><span
        class="mord">word&nbsp;&amp;&amp;&nbsp;dp(i&nbsp;-&nbsp;</span><span class="mord text"><span class="mord">word.length</span></span><span
        class="mord">)</span></span><span class="mclose">)</span></span></span></span></span></span></p>
<p>That is, there exists any <code>word</code> that satisfies both of the listed conditions.</p>
<p>We can implement a recursive function <code>dp(i)</code> that implements the base cases and recurrence. We need to
    use memoization to avoid repeated computation.</p>
<p>
<div class="relative mx-auto mb-6 flex flex-col overflow-hidden rounded-lg border-[1px] border-label-1"
     style="max-width: 960px;">
    <div class="rounded-lg" style="max-height: 540px;"><img alt="Current"
                                                            class="object-fit-contain !mb-0 max-h-full max-w-full"
                                                            src="blob:https://leetcode.com/efbce52f-d779-4cbb-a357-29ad285da815">
    </div>
    <div class="absolute top-[50%] left-[50%] flex h-12 w-12 translate-x-[-50%] translate-y-[-50%] items-center justify-center rounded-full bg-black/30">
        <div class="flex h-4 w-4 cursor-pointer items-center justify-center text-[35px]">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="h-full w-full text-white">
                <path fill-rule="evenodd"
                      d="M18.97 12.871l-12.96 7.29a1 1 0 01-1.49-.87V4.71a1 1 0 011.49-.872l12.96 7.29a1 1 0 010 1.743z"
                      clip-rule="evenodd"></path>
            </svg>
        </div>
    </div>
    <div class="relative flex h-8 select-none items-center justify-around bg-black">
        <div class="flex items-center space-x-7">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M16.091 4.929l-7.057 7.078 7.057 7.064a1 1 0 01-1.414 1.414l-7.764-7.77a1 1 0 010-1.415l7.764-7.785a1 1 0 111.415 1.414z"
                      clip-rule="evenodd"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M18.97 12.871l-12.96 7.29a1 1 0 01-1.49-.87V4.71a1 1 0 011.49-.872l12.96 7.29a1 1 0 010 1.743z"
                      clip-rule="evenodd"></path>
            </svg>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="1em" height="1em" fill="currentColor"
                 class="w-4 cursor-pointer text-gray-6 dark:text-dark-gray-6 hover:text-gray-7 dark:hover:text-dark-gray-7">
                <path fill-rule="evenodd"
                      d="M7.913 19.071l7.057-7.078-7.057-7.064a1 1 0 011.414-1.414l7.764 7.77a1 1 0 010 1.415l-7.764 7.785a1 1 0 01-1.414-1.414z"
                      clip-rule="evenodd"></path>
            </svg>
        </div>
        <div class="absolute right-0 mr-5 text-xs font-medium text-white">1 / 3</div>
    </div>
</div>
</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Declare a data structure <code>memo</code> that stores the values of <code>dp</code> for each index.</li>
    <li>Create a function <code>dp(i)</code>:
        <ul>
            <li>If <code>i &lt; 0</code>, return <code>true</code>.</li>
            <li>If we already calculated <code>i</code>, return the value stored in <code>memo</code>.</li>
            <li>Iterate over <code>wordDict</code>. For each <code>word</code>:
                <ul>
                    <li>Check the substring of <code>s</code> ending at <code>i</code> with the same length as <code>word</code>.
                        If the substring matches, and <code>dp(i - word.length)</code> is <code>true</code>, return
                        <code>true</code>.
                    </li>
                </ul>
            </li>
            <li>If no <code>word</code> satisfying the criteria was found, return <code>false</code>.</li>
        </ul>
    </li>
    <li>Return <code>dp(s.length - 1)</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<blockquote>
    <p>In Python, the <a href="https://docs.python.org/3/library/functools.html" target="_blank"
                         rel="noopener noreferrer">functools</a> module provides super handy tools that automatically
        memoize a function for us. We're going to use the <code>@cache</code> decorator in the Python implementation.
    </p>
    <p>In Java and C++, we will use an array <code>memo</code> to save values. <code>memo[i] = -1</code> if we haven't
        calculated yet, <code>memo[i] = 0</code> if <code>dp(i) = false</code>, and <code>memo[i] = 1</code> if <code>dp(i)
            = true</code>.</p>
</blockquote>
<pre>
    Java
    <code>
        class Solution {
    private String s;
    private List<String> wordDict;
    private int[] memo;

    private boolean dp(int i) {
        if (i < 0) return true;

        if (memo[i] != -1) {
            return memo[i] == 1;
        }

        for (String word: wordDict) {
            // Handle out of bounds case
            if (i - word.length() + 1 < 0) {
                continue;
            }

            if (s.substring(i - word.length() + 1, i + 1).equals(word) && dp(i - word.length())) {
                memo[i] = 1;
                return true;
            }
        }

        memo[i] = 0;
        return false;
    }

    public boolean wordBreak(String s, List<String> wordDict) {
        this.s = s;
        this.wordDict = wordDict;
        this.memo = new int[s.length()];
        Arrays.fill(this.memo, -1);
        return dp(s.length() - 1);
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    vector<int> memo;
    vector<string> wordDict;
    string s;

    bool wordBreak(string s, vector<string>& wordDict) {
        memo = vector(s.length(), -1);
        this->wordDict = wordDict;
        this->s = s;
        return dp(s.length() - 1);
    }

    bool dp(int i) {
        if (i < 0) return true;

        if (memo[i] != -1) {
            return memo[i] == 1;
        }

        for (string word: wordDict) {
            int currSize = word.length();
            // Handle out of bounds case
            if (i - currSize + 1 < 0) {
                continue;
            }

            if (s.substr(i - currSize + 1, currSize) == word && dp(i - currSize)) {
                memo[i] = 1;
                return true;
            }
        }

        memo[i] = 0;
        return false;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        @cache
        def dp(i):
            if i < 0:
                return True

            for word in wordDict:
                if s[i - len(word) + 1:i + 1] == word and dp(i - len(word)):
                    return True

            return False

        return dp(len(s) - 1)
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>, <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as the length of <code>wordDict</code>, and
    <span class="math math-inline"><span class="katex"><span class="katex-mathml">kk</span><span class="katex-html"
                                                                                                 aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.03148em;">k</span></span></span></span></span>
    as the average length of the words in <code>wordDict</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅m⋅k)O(n \cdot m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>There are <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 0.4306em;"></span><span
                class="mord mathnormal">n</span></span></span></span></span> states of <code>dp(i)</code>. Because of
            memoization, we only calculate each state once. To calculate a state, we iterate over <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.4306em;"></span><span
                    class="mord mathnormal">m</span></span></span></span></span> words, and for each word perform some
            substring operations which costs <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(k)O(k)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                    class="mclose">)</span></span></span></span></span>. Therefore, calculating a state costs <span
                    class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                    class="mclose">)</span></span></span></span></span>, and we need to calculate <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> states.
        </p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p>The data structure we use for memoization and the recursion call stack can use up to <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-3-bottom-up-dynamic-programming">Approach 3: Bottom-Up Dynamic Programming</h4>
<p><strong>Intuition</strong></p>
<p>The same algorithm can be implemented iteratively. Instead of using a function <code>dp(i)</code>, we will use an
    array <code>dp</code> where <code>dp[i]</code> represents the same thing that <code>dp(i)</code> did. We can use the
    same recurrence relation:</p>
<p><span class="math math-inline"><span class="katex"><span class="katex-mathml">dp[i]=any(s[i&nbsp;-&nbsp;word.length&nbsp;+&nbsp;1,&nbsp;i]==word&nbsp;&amp;&amp;&nbsp;dp[i&nbsp;-&nbsp;word.length])\large{\text{dp[i]} = \text{any}(\text{s}[\text{i - word.length + 1, i}] == \text{word \&amp;\&amp; dp[i - \text{word.length}]})}</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1.2em; vertical-align: -0.3em;"></span><span
        class="mord sizing reset-size6 size7"><span class="mord text"><span class="mord">dp[i]</span></span><span
        class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace"
                                                                                               style="margin-right: 0.2778em;"></span><span
        class="mord text"><span class="mord">any</span></span><span class="mopen">(</span><span class="mord text"><span
        class="mord">s</span></span><span class="mopen">[</span><span class="mord text"><span class="mord">i&nbsp;-&nbsp;word.length&nbsp;+&nbsp;1,&nbsp;i</span></span><span
        class="mclose">]</span><span class="mspace" style="margin-right: 0.2778em;"></span><span
        class="mrel">==</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mord text"><span
        class="mord">word&nbsp;&amp;&amp;&nbsp;dp[i&nbsp;-&nbsp;</span><span class="mord text"><span class="mord">word.length</span></span><span
        class="mord">]</span></span><span class="mclose">)</span></span></span></span></span></span></p>
<p>In top-down, we started at the top (<code>s.length - 1</code>) and work our way down to the base cases. In bottom-up,
    we start at the bottom <code>(i = 0)</code> and work our way up to the top.</p>
<p>Before we check <code>dp[i - word.length]</code>, we should check if <code>i == word.length - 1</code>. This would
    mean that the current <code>word</code> we are placing to end at index <code>i</code> is the first word. <code>i -
        word.length</code> would be negative, so we need to separately check this case.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Initialize an array <code>dp</code> with the same length as <code>s</code> and all values initially set to
        <code>false</code>.
    </li>
    <li>Iterate <code>i</code> over the indices of <code>s</code>. At each <code>i</code>:
        <ul>
            <li>Iterate over each <code>word</code> in <code>wordDict</code>:
                <ul>
                    <li>Check if <code>i == word.length - 1</code> or <code>dp[i - word.length] = true</code>.</li>
                    <li>If so, and the substring of <code>s</code> ending at <code>i</code> with the same length as
                        <code>word</code> matches, set <code>dp[i] = true</code> and <code>break</code>.
                    </li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Return <code>dp[s.length - 1]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        boolean[] dp = new boolean[s.length()];
        for (int i = 0; i < s.length(); i++) {
            for (String word: wordDict) {
                // Handle out of bounds case
                if (i < word.length() - 1) {
                    continue;
                }

                if (i == word.length() - 1 || dp[i - word.length()]) {
                    if (s.substring(i - word.length() + 1, i + 1).equals(word)) {
                        dp[i] = true;
                        break;
                    }
                }
            }
        }

        return dp[s.length() - 1];
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        vector<bool> dp(s.length());
        for (int i = 0; i < s.length(); i++) {
            for (string word: wordDict) {
                // Handle out of bounds case
                if (i < word.length() - 1) {
                    continue;
                }

                if (i == word.length() - 1 || dp[i - word.length()]) {
                    if (s.substr(i - word.length() + 1, word.length()) == word) {
                        dp[i] = true;
                        break;
                    }
                }
            }
        }

        return dp[s.length() - 1];
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = [False] * len(s)
        for i in range(len(s)):
            for word in wordDict:
                # Handle out of bounds case
                if i < len(word) - 1:
                    continue

                if i == len(word) - 1 or dp[i - len(word)]:
                    if s[i - len(word) + 1:i + 1] == word:
                        dp[i] = True
                        break

        return dp[-1]
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>, <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as the length of <code>wordDict</code>, and
    <span class="math math-inline"><span class="katex"><span class="katex-mathml">kk</span><span class="katex-html"
                                                                                                 aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.03148em;">k</span></span></span></span></span>
    as the average length of the words in <code>wordDict</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n⋅m⋅k)O(n \cdot m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>The logic behind the time complexity is identical to the previous approach. It costs us <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span> to calculate each state, and we calculate <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> states in
            total.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
        </p>
        <p>We use an array <code>dp</code> of length <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 0.4306em;"></span><span
                class="mord mathnormal">n</span></span></span></span></span>.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-4-trie-optimization">Approach 4: Trie Optimization</h4>
<p><strong>Intuition</strong></p>
<p>In the previous approach, we iterated over each state <code>i</code> and then calculated <code>dp[i]</code>. To
    calculate a given <code>dp[i]</code>, we did the following:</p>
<ul>
    <li>Iterate over every <code>word</code> in <code>wordDict</code></li>
    <li>Check if each <code>word</code> ended at the current index</li>
</ul>
<p>This cost us <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span class="katex-html" aria-hidden="true"><span
        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
        class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
        class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                 style="margin-right: 0.03148em;">k</span><span
        class="mclose">)</span></span></span></span></span>. In the problem constraints, we can see that the maximum
    value of <span class="math math-inline"><span class="katex"><span class="katex-mathml">m⋅km \cdot k</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.4445em;"></span><span
            class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
            class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
            class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.03148em;">k</span></span></span></span></span>
    is <code>20,000</code>, so this is expensive. We can optimize the time it takes to calculate a given
    <code>dp[i]</code> by using a trie.</p>
<p>A trie is a data structure that can be used to efficiently search for strings. If you are not familiar with tries, we
    highly recommend you read the official solution to <a
            href="https://leetcode.com/problems/implement-trie-prefix-tree/solution" target="_blank">this problem</a>
    before proceeding with this approach.</p>
<p>To summarize, a trie is a tree where each node is labeled. Here, we label each node with a character. The path from
    the root to any node represents the string that is built by the nodes on the path. The root represents the empty
    string.</p>
<p><img src="4.png" alt="" width="960"> <br></p>
<p>We can start by building a trie from the words in <code>wordDict</code>. Each trie node will have an additional
    attribute <code>isWord</code> which indicates if the current node represents a word from <code>wordDict</code>.
    Then, we will calculate the same <code>dp</code> array as in the previous approach. We will calculate each state as
    follows:</p>
<ul>
    <li>First, check if <code>i == 0</code> (placing first word) or <code>dp[i - 1]</code> (we could build the string up
        to this point). If neither are true, move on to the next state <code>i + 1</code>.
    </li>
    <li>Otherwise, we see if <code>dp[i]</code> can be <code>true</code>. Initialize a node <code>curr</code> at the
        <code>root</code> of the trie.
    </li>
    <li>Start iterating with a variable <code>j</code> from index <code>i</code>. For each character <code>s[j]</code>,
        check if we can traverse the trie.
    </li>
    <li>If we can't traverse the trie, it means no words exist starting at index <code>i</code> and ending at index
        <code>j</code> or beyond. We can break from the loop and move on to the next state <code>i + 1</code>.
    </li>
    <li>If we can traverse the trie, we move to the child node. We check the child's <code>isWord</code> attribute. If
        it is <code>true</code>, it means there is a word in <code>wordDict</code> starting at index <code>i</code> and
        ending at index <code>j</code>. We set <code>dp[j] = true</code>.
    </li>
    <li>We continue traversing the trie until we reach a dead end or <code>j</code> reaches the end of the string.</li>
</ul>
<p>This allows us to handle each state in <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
        class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> instead of <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
        class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
        class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span
        class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                 style="margin-right: 0.03148em;">k</span><span
        class="mclose">)</span></span></span></span></span>, which is a big improvement since <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">n≤300n \leq 300</span><span
        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                       style="height: 0.7719em; vertical-align: -0.136em;"></span><span
        class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span
        class="mrel">≤</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span
        class="strut" style="height: 0.6444em;"></span><span class="mord">300</span></span></span></span></span>.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Build a trie from <code>wordDict</code>. Each node should also have an <code>isWord</code> attribute. Store the
        root of the trie in <code>root</code>.
    </li>
    <li>Initialize an array <code>dp</code> with the same length as <code>s</code> and all values initially set to
        <code>false</code>.
    </li>
    <li>Iterate <code>i</code> over the indices of <code>s</code>. At each <code>i</code>:
        <ul>
            <li>Check if <code>i == 0</code> or <code>dp[i - 1] = true</code>. If not, continue to the next
                <code>i</code>.
            </li>
            <li>Set <code>curr = root</code>. Iterate <code>j</code> over the indices of <code>s</code>, starting from
                <code>i</code>. At each <code>j</code>,
                <ul>
                    <li>Get the character at index <code>j</code> as <code>c = s[j]</code>.</li>
                    <li>If <code>c</code> is not in the children of <code>curr</code>, we can <code>break</code> from
                        the loop.
                    </li>
                    <li>Otherwise, move <code>curr</code> to the child labeled <code>c</code>.</li>
                    <li>If <code>curr.isWord</code>, set <code>dp[j] = true</code>.</li>
                </ul>
            </li>
        </ul>
    </li>
    <li>Return <code>dp[s.length - 1]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        dp = [False] * len(s)
        for i in range(len(s)):
            for word in wordDict:
                # Handle out of bounds case
                if i < len(word) - 1:
                    continue

                if i == len(word) - 1 or dp[i - len(word)]:
                    if s[i - len(word) + 1:i + 1] == word:
                        dp[i] = True
                        break

        return dp[-1]
    </code>
    C++
    <code>
        struct TrieNode {
    bool isWord;
    unordered_map<char, TrieNode*> children;
    TrieNode() : isWord(false), children(unordered_map<char, TrieNode*>()) {}
};

class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        TrieNode* root = new TrieNode();
        for (string word: wordDict) {
            TrieNode* curr = root;
            for (char c: word) {
                if (curr->children.find(c) == curr->children.end()) {
                    curr->children[c] = new TrieNode();
                }
                curr = curr->children[c];
            }

            curr->isWord = true;
        }

        vector<bool> dp(s.length());
        for (int i = 0; i < s.length(); i++) {
            if (i == 0 || dp[i - 1]) {
                TrieNode* curr = root;
                for (int j = i; j < s.length(); j++) {
                    char c = s[j];
                    if (curr->children.find(c) == curr->children.end()) {
                        // No words exist
                        break;
                    }

                    curr = curr->children[c];
                    if (curr->isWord) {
                        dp[j] = true;
                    }
                }
            }
        }

        return dp[s.length() - 1];
    }
};
    </code>
    Python3
    <code>
        class TrieNode:
    def __init__(self):
        self.is_word = False
        self.children = {}

class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        root = TrieNode()
        for word in wordDict:
            curr = root
            for c in word:
                if c not in curr.children:
                    curr.children[c] = TrieNode()
                curr = curr.children[c]

            curr.is_word = True

        dp = [False] * len(s)
        for i in range(len(s)):
            if i == 0 or dp[i - 1]:
                curr = root
                for j in range(i, len(s)):
                    c = s[j]
                    if c not in curr.children:
                        # No words exist
                        break

                    curr = curr.children[c]
                    if curr.is_word:
                        dp[j] = True

        return dp[-1]
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>, <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as the length of <code>wordDict</code>, and
    <span class="math math-inline"><span class="katex"><span class="katex-mathml">kk</span><span class="katex-html"
                                                                                                 aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.03148em;">k</span></span></span></span></span>
    as the average length of the words in <code>wordDict</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2+m⋅k)O(n^2 + m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>Building the trie involves iterating over all characters of all words. This costs <span
                class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span>.</p>
        <p>Once we build the trie, we calculate <code>dp</code>. For each <code>i</code>, we iterate over all the
            indices after <code>i</code>. We have a basic nested for loop which costs <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> to handle all <code>dp[i]</code>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n+m⋅k)O(n + m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>The <code>dp</code> array takes <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
            space. The trie can have up to <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">m⋅km \cdot k</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 0.4445em;"></span><span
                    class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                            style="margin-right: 0.03148em;">k</span></span></span></span></span>
            nodes in it.</p>
    </li>
</ul>
<br>
<hr>
<h4 id="approach-5-a-different-dp">Approach 5: A Different DP</h4>
<p><strong>Intuition</strong></p>
<blockquote>
    <p>In this approach, we will take a look at another way to implement the DP algorithm. Note that this approach is
        the one covered in the video.</p>
</blockquote>
<p>Here, we let <code>dp[i]</code> hold the answer to the question: "is it possible to form <code>s</code> up to a
    length of <code>i</code>? To find the answer for each index, instead of iterating over the words in
    <code>wordDict</code> and checking if a <code>word</code> ends at the current index <code>i</code>, we will instead
    iterate over <strong>all substrings that end before index <code>i</code></strong>. If we find one of these
    substrings is in <code>wordDict</code> <strong>and</strong> we can form the string prior to the substring, then
    <code>dp[i] = true</code>.</p>
<p>The reason we are checking for <strong>before</strong> index <code>i</code> is because we have slightly changed our
    <code>dp</code> definition here. In the previous problem, <code>i</code> represented the index of the last
    character. Here, <code>i</code> represents the length, so we are offset by one.</p>
<p>Before starting the DP, we first convert <code>wordsDict</code> to a set so that we can perform the checks in <span
        class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span class="katex-html"
                                                                                                     aria-hidden="true"><span
        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span
        class="mclose">)</span></span></span></span></span>. The rest of the algorithm follows similarly to the previous
    approaches.</p>
<p><strong>Algorithm</strong></p>
<ol>
    <li>Convert <code>wordsDict</code> to a set <code>words</code>.</li>
    <li>Initialize an array <code>dp</code> of length <code>n + 1</code> with all values set to <code>false</code>.</li>
    <li>Iterate <code>i</code> from <code>1</code> until and including <code>n</code>. Here, <code>i</code> represents
        the length of the string starting from the beginning.
        <ul>
            <li>Iterate <code>j</code> from <code>0</code> until <code>i</code>. Here, <code>j</code> represents the
                first index of the substring we are checking.
            </li>
            <li>If <code>dp[j]</code> is true AND the substring <code>s[j:i]</code> is in <code>words</code>, set <code>dp[i]
                = true</code> and break. Note that <code>s[j:i]</code> represents the substring starting at
                <code>j</code> and ending at <code>i - 1</code>.
            </li>
        </ul>
    </li>
    <li>Return <code>dp[n]</code>.</li>
</ol>
<p><strong>Implementation</strong></p>
<pre>
    Java
    <code>
        class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int n = s.length();
        Set<String> words = new HashSet<>(wordDict);
        boolean[] dp = new boolean[n + 1];
        dp[0] = true;

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && words.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[n];
    }
}
    </code>
    Python3
    <code>
        class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        n = len(s)
        words = set(wordDict)
        dp = [False] * (n + 1)
        dp[0] = True

        for i in range(1, n + 1):
            for j in range(i):
                if dp[j] and s[j:i] in words:
                    dp[i] = True
                    break

        return dp[-1]
    </code>
</pre>
<p><strong>Complexity Analysis</strong></p>
<p>Given <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    as the length of <code>s</code>, <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> as the length of <code>wordDict</code>, and
    <span class="math math-inline"><span class="katex"><span class="katex-mathml">kk</span><span class="katex-html"
                                                                                                 aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal"
                                                                                    style="margin-right: 0.03148em;">k</span></span></span></span></span>
    as the average length of the words in <code>wordDict</code>,</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n3+m⋅k)O(n^3 + m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span
                class="sizing reset-size6 size3 mtight"><span
                class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace"
                                                                                                   style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>First, we spend <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span> to convert <code>wordDict</code> into a set. Then we
            have a nested loop over <code>n</code>, which iterates <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n2)O(n^2)</span><span class="katex-html"
                                                                                     aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">2</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span> times. For each iteration, we have a substring
            operation which could cost up to <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>. Thus this
            nested loop costs <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n3)O(n^3)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1.0641em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span
                    class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span
                    style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut"
                                                                       style="height: 2.7em;"></span><span
                    class="sizing reset-size6 size3 mtight"><span
                    class="mord mtight">3</span></span></span></span></span></span></span></span><span
                    class="mclose">)</span></span></span></span></span>.</p>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(n+m⋅k)O(n + m \cdot k)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 0.4445em;"></span><span class="mord mathnormal">m</span><span
                class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">⋅</span><span class="mspace"
                                                                                                       style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                class="mclose">)</span></span></span></span></span></p>
        <p>The <code>dp</code> array takes <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal"
                                                                                         style="margin-right: 0.02778em;">O</span><span
                class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
            space. The set <code>words</code> takes up <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m⋅k)O(m \cdot k)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                    class="mbin">⋅</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.03148em;">k</span><span
                    class="mclose">)</span></span></span></span></span> space.</p>
    </li>
</ul>
<br>
<hr>
</body>
</html>