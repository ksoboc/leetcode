<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Find Eventual Safe States - Solution</title>
</head>
<body>
<h2 id="solution">Find Eventual Safe States - Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>We are given a directed graph of <code>n</code> nodes with each node labeled from <code>0</code> to <code>n -
    1</code>. The graph is represented by a 2D integer array <code>graph</code> where <code>graph[i]</code> is an
    integer array of nodes that have an incoming edge from node <code>i</code>.</p>
<p>The problem states that a node is a <strong>terminal node</strong> if there are no outgoing edges. A node is a
    <strong>safe node</strong> if every possible path starting from that node leads to a terminal node (or another safe
    node).</p>
<p>Our task is to return a sorted array of all the safe nodes of the graph.</p>
<hr>
<h3 id="approach-1-topological-sort-using-kahns-algorithm">Approach 1: Topological Sort Using Kahn's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>To solve the problem, we must first consider when a node is safe or unsafe. If we begin at any node and proceed along
    any path from that node, we will eventually reach either a terminal node or enter a cycle and continue to loop in it
    without ever reaching a terminal node.</p>
<p>If there is no path from the node that enters a cycle, we will always be able to reach a terminal node. As a result,
    such a node is a safe node and should be added to our answer array.</p>
<blockquote>
    <p>The problem is reduced to finding the nodes that do not have any paths that lead to a cycle.</p>
</blockquote>
<p>Intuitively, we can realize that a node is safe if all of its outgoing edges are to nodes that are also safe. This is
    due to the fact that if no neighbor leads to a cycle, no path from the node can either.</p>
<p>We know the terminal nodes are safe. As a result, nodes that solely have outgoing edges to terminal nodes are
    eventually safe nodes. Then we may check the nodes that have just outgoing edges to safe nodes again and keep
    updating until no new safe node is discovered.</p>
<p>The question is, how do we efficiently traverse from terminal nodes to nodes that only have outgoing edges to
    terminal nodes? We can reverse the edges of the graph to create a new graph with reversed edges. After we have
    visited all of the terminal nodes, we can use this new graph to go to the nodes that have edges to the terminal
    nodes in the original graph by using the reverse edges that we added.</p>
<p>Let's put this new graph to use now. A node is a safe node if all of its incoming edges come from previously
    identified safe nodes in the graph. If we erase the edges outgoing from the safe node and discover a node with no
    incoming edges, it is a new safe node. This gives us hints for thinking about Kahn's method, which does a
    topological sort by removing the edges in the exact way we want.</p>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for
    every directed edge <code>u -&gt; v</code> from vertex <code>u</code> to vertex <code>v</code>, <code>u</code> comes
    before <code>v</code> in the ordering.</p>
<p>In a directed acyclic graph, we can use Kahn's algorithm to get the topological ordering. Kahnâ€™s algorithm works by
    keeping track of the number of incoming edges into each node (indegree). It works by repeatedly visiting the nodes
    with an indegree of zero and deleting all the edges associated with it leading to a decrement of indegree for the
    nodes whose incoming edges are deleted. This process continues until no elements with zero indegree can be
    found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a
        href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/"
        target="_blank">LeetCode Explore Card</a>.</p>
<p>The advantage of using Kahn's technique is that it also aids in the discovery of graph cycles. The Kahn's method does
    not visit any node in a cycle. As a result, nodes with outgoing edges from nodes in the cycle (in this reversed
    graph) will never be visited and so will never be marked safe. Nodes with outgoing edges from these unsafe nodes
    will never be visited as well, and so on. Basically, every node in the original network that has a path to the cycle
    will never be visited by Kahn's algorithm, which is exactly what we want.</p>
<p>Let's perform Kahn's algorithm on a directed graph having a cycle. Here's a visual step-by-step represenntation of
    how it would work:</p>
<p><img src="802-1.png" alt="img"></p>
<p>We can see that if there is a cycle, the indegree of nodes in the cycle cannot be set to <code>0</code> due to cyclic
    dependency. We are unable to visit the cycle's nodes. We are also unable to visit any node with an incoming edge
    from any node in the cycle. Similary, realize that any node with an incoming edge from nodes <code>3</code> or
    <code>5</code> would not have been visited as well.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create an integer <code>n</code> equal to the length of <code>graph</code> to get the number of nodes in the
        given graph.
    </li>
    <li>Create an array <code>indegree</code> of length <code>n</code> where <code>indegree[x]</code> stores the number
        of edges entering node <code>x</code>.
    </li>
    <li>We create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all the nodes with an
        incoming edge from node <code>x</code>, i.e., neighbors of node <code>x</code>. We create this adjacency list by
        iterating over <code>graph</code> and adding the <strong>reverse edges</strong>. For a node <code>i</code> which
        originally has outgoing edges to nodes in <code>graph[i]</code>, we push <code>i</code> into
        <code>adj[node]</code> to add a reverse edge from <code>node</code> to <code>i</code>.
    </li>
    <li>Initialize a queue of integers <code>q</code> and start a BFS algorithm moving from the leaf nodes to the parent
        nodes.
    </li>
    <li>Begin the BFS traversal by pushing all of the leaf nodes (<code>indegree</code> equal to <code>0</code>) in the
        queue.
    </li>
    <li>Create a boolean array <code>safe</code> of size <code>n</code> to track the safe nodes in the graph.</li>
    <li>While the queue is not empty;
        <ul>
            <li>Dequeue the first <code>node</code> from the queue.</li>
            <li>Mark <code>node</code> as safe.</li>
            <li>For each <code>neighbor</code> (nodes that have an incoming edge from <code>node</code>) of
                <code>node</code>, we decrement <code>indegree[neighbor]</code>by <code>1</code> to delete the <code>node
                    -&gt; neighbor</code> edge.
            </li>
            <li>If <code>indegree[neighbor] == 0</code>, it means that <code>neighbor</code> behaves as a leaf node, so
                we push <code>neighbor</code> in the queue.
            </li>
        </ul>
    </li>
    <li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from
        <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>.
    </li>
    <li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public List<Integer> eventualSafeNodes(int[][] graph) {
        int n = graph.length;
        int[] indegree = new int[n];
        List<List<Integer>> adj = new ArrayList<>();

        for(int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }

        for (int i = 0; i < n; i++) {
            for (int node : graph[i]) {
                adj.get(node).add(i);
                indegree[i]++;
            }
        }

        Queue<Integer> q = new LinkedList<>();
        // Push all the nodes with indegree zero in the queue.
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.add(i);
            }
        }

        boolean[] safe = new boolean[n];
        while (!q.isEmpty()) {
            int node = q.poll();
            safe[node] = true;

            for (int neighbor : adj.get(node)) {
                // Delete the edge "node -> neighbor".
                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    q.add(neighbor);
                }
            }
        }

        List<Integer> safeNodes = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (safe[i]) {
                safeNodes.add(i);
            }
        }
        return safeNodes;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<int> indegree(n);
        vector<vector<int>> adj(n);

        for (int i = 0; i < n; i++) {
            for (auto node : graph[i]) {
                adj[node].push_back(i);
                indegree[i]++;
            }
        }

        queue<int> q;
        // Push all the nodes with indegree zero in the queue.
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        vector<bool> safe(n);
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            safe[node] = true;

            for (auto& neighbor : adj[node]) {
                // Delete the edge "node -> neighbor".
                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    q.push(neighbor);
                }
            }
        }

        vector<int> safeNodes;
        for(int i = 0; i < n; i++) {
            if(safe[i]) {
                safeNodes.push_back(i);
            }
        }
        return safeNodes;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n = len(graph)
        indegree = [0] * n
        adj = [[] for _ in range(n)]

        for i in range(n):
            for node in graph[i]:
                adj[node].append(i)
                indegree[i] += 1

        q = deque()
        # Push all the nodes with indegree zero in the queue.
        for i in range(n):
            if indegree[i] == 0:
                q.append(i)

        safe = [False] * n
        while q:
            node = q.popleft()
            safe[node] = True

            for neighbor in adj[node]:
                # Delete the edge "node -> neighbor".
                indegree[neighbor] -= 1
                if indegree[neighbor] == 0:
                    q.append(neighbor)

        safeNodes = []
        for i in range(n):
            if safe[i]:
                safeNodes.append(i)

        return safeNodes
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the number of nodes and <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> is number of edges in the graph.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m+n)O(m + n)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Initializing the <code>adj</code> list takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time as we
                go through all the edges. The <code>indegree</code> array take <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                time.
            </li>
            <li>Initializing the boolean <code>safe</code> array also takes <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
            <li>Each queue operation takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span> time, and a single
                node will be pushed once, leading to <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                operations for <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                nodes. We iterate over the neighbors of each node that is popped out of the queue iterating over all the
                edges once. Since there are total of <code>m</code> edges, it would take <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                time to iterate over the edges.
            </li>
            <li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>The <code>adj</code> arrays takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> space. The
                <code>indegree</code> array takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space.
            </li>
            <li>The <code>safe</code> array also takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space.
            </li>
            <li>The queue can have no more than <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                    class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                elements in the worst-case scenario. It would take up <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space in that case.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also use a depth-first search (DFS) traversal to detect the nodes that lead to a cycle, i.e., unsafe
    nodes.</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a
    branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this
    branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>A node remains in the DFS recursion stack until all of its branches (all nodes in its subtree) have not been
    explored. When we have examined all of a node's branches, i.e. visited all of the nodes in its subtree, the node is
    removed from the DFS recursive stack.</p>
<p>If you are new to Depth First Search, please see our <a
        href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/" target="_blank">Leetcode
    Explore Card</a> for more information on it!</p>
<p>To find the unsafe nodes, we must first recognise a cycle in the graph. If we find a cycle, we will mark all of the
    nodes in the cycle as unsafe and then go back and mark all of the nodes that led to this cycle as unsafe. Let's find
    a cycle first.</p>
<p>If the graph has a cycle, we must have a <strong>back edge</strong> connecting a node to one of its ancestors while
    traversing nodes in the DFS manner.</p>
<p>Let's think how we can establish whether or not a node's neighbor is an ancestor when navigating from one node to
    another.</p>
<p>If the neighboring node has not yet been visited, it cannot be an ancestor (it is a child node).</p>
<p>Otherwise, if a neighboring node is visited, it may or may not be an ancestor. If the neighboring node is an
    ancestor, i.e. there is a back edge, it means that we visited this ancestor node first in the DFS traversal, then
    visited and explored some other nodes, and eventually visited a node that connects back to the ancestor node. As we
    are still exploring the ancestor node's subtree while iterating over this path, hence this node must be in the
    current DFS recursive stack.</p>
<p>However, if a neighboring node is visited but not in the recursion stack, it signifies we have previously explored
    that node in a different branch, and it does not form a cycle in the current branch.</p>
<p>As a result, to detect the cycle we must keep track of the visited nodes (like in a normal DFS) and also the nodes in
    the function's recursion call stack for DFS traversal. The nodes in the stack store the current path that we are on.
    There is a cycle in the graph if a node is reached that is already in the recursion stack. We use a boolean array
    <code>inStack</code> of length <code>n</code> to track which nodes are in the call stack so we can check if a node
    exists in <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord">1</span><span class="mclose">)</span></span></span></span></span>. Note that this
    <code>inStack</code> array is emulating the call stack that the computer is using under the hood to execute
    recursion. We mark an unvisited node in <code>inStack</code> when we make a recursive call to it and then unmark it
    when we return from that call.</p>
<p>Now that we've identified the cycle, let's look for the unsafe nodes. When we get a cycle, all of the nodes in the
    recursion stack either form or lead to a cycle. If we start a DFS traversal from node <code>1</code> in a graph
    <code>1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 2</code>, nodes <code>2</code>, <code>3</code>, and <code>4</code> form a
    cycle. When we discovered this cycle, node <code>1</code> was also in the stack. So, when we have a cycle, all the
    nodes in the recursion stack are unsafe since they form or lead to a loop.</p>
<p>In addition to detecting cycles, we can use the same <code>inStack</code> array to store the unsafe nodes. We do not
    unmark any of the unsafe nodes from <code>inStack</code> to keep track of them. When any <code>node</code> has an
    outgoing edge to any of the unsafe nodes, we can immediately return the DFS call for <code>node</code> without
    unmarking it from <code>inStack</code>, i.e, we do not perform <code>inStack[node] = false</code>. This is because
    if any <code>neighbor</code> of <code>node</code> is marked <code>inStack</code>, it signifies that either <code>neighbor</code>
    and <code>node</code> are part of a cycle or <code>neighbor</code> is a previously detected unsafe node. In both the
    cases, <code>node</code> is also an unsafe node and hence we return the DFS call without unmarking <code>node</code>
    from <code>inStack</code>.</p>
<p>We only unmark a node from <code>inStack</code>, if we have explored all of its branches and no branch leads to an
    unsafe node.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>We create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all the nodes with an
        incoming edge from node <code>x</code>, i.e., neighbors of node <code>x</code>. We create this adjacency list by
        iterating over <code>graph</code>. For every node <code>i</code>, we add edges from <code>i</code> to all the
        nodes in <code>graph[i]</code>.
    </li>
    <li>Create two boolean arrays, <code>visit</code> and <code>inStack</code>, each of size <code>n</code>. The <code>visit</code>
        array keeps track of visited nodes and <code>inStack</code> keeps track of nodes that are currently in the
        ongoing DFS stack. It will help us to detect a cycle in the graph and the unsafe nodes.
    </li>
    <li>For each node we begin a DFS traversal. We implement the <code>dfs</code> method which takes four parameters: an
        integer <code>node</code> from which the current traversal begins, <code>adj</code>, <code>visit</code>, and
        <code>inStack</code>. It returns a boolean indicating whether <code>node</code> is unsafe. We perform the
        following in this method:
        <ul>
            <li>If <code>node</code> is already present in <code>inStack</code>, either we just got a cycle or a
                previously detected unsafe node. We return <code>true</code> in this case as the <code>node</code> is
                unsafe.
            </li>
            <li>If <code>node</code> is already visited (but not in <code>inStack</code>), we return <code>false</code>
                because we already visited this <code>node</code> and didn't find it as unsafe node. It is a safe node.
            </li>
            <li>We mark <code>node</code> as visited and also mark it in <code>inStack</code> (<code>inStack[node] =
                true</code>).
            </li>
            <li>We iterate over all the outgoing edges of <code>node</code> and for each <code>neighbor</code>, we
                recursively call <code>dfs(neighbor, adj, visit, inStack)</code>. If we get a cycle from
                <code>neighbor</code> (or <code>neighbor</code> is a previously detected unsafe node), we return <code>true</code>
                without unmarking <code>node</code> in <code>inStack</code>.
            </li>
            <li>After we have processed all the outgoing edges of <code>node</code>, we mark <code>inStack[node] =
                false</code> to mark <code>node</code> as safe. We return <code>false</code>.
            </li>
        </ul>
    </li>
    <li>Create an answer array <code>safeNodes</code> of size <code>n</code>. Iterate over all the nodes from
        <code>0</code> to <code>n - 1</code> and add all the safe nodes in <code>safeNodes</code>, i.e., the nodes with
        <code>inStack[node] == false</code>.
    </li>
    <li>Return <code>safeNodes</code>.</li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public boolean dfs(int node, List<List<Integer>> adj, boolean[] visit, boolean[] inStack) {
        // If the node is already in the stack, we have a cycle.
        if (inStack[node]) {
            return true;
        }
        if (visit[node]) {
            return false;
        }
        // Mark the current node as visited and part of current recursion stack.
        visit[node] = true;
        inStack[node] = true;
        for (int neighbor : adj.get(node)) {
            if (dfs(neighbor, adj, visit, inStack)) {
                return true;
            }
        }
        // Remove the node from the stack.
        inStack[node] = false;
        return false;
    }

    public List<Integer> eventualSafeNodes(int[][] graph) {
        int n = graph.length;
        List<List<Integer>> adj = new ArrayList<>();

        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
            for (int node : graph[i]) {
                adj.get(i).add(node);
            }
        }

        boolean[] visit = new boolean[n];
        boolean[] inStack = new boolean[n];

        for (int i = 0; i < n; i++) {
            dfs(i, adj, visit, inStack);
        }

        List<Integer> safeNodes = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            if (!inStack[i]) {
                safeNodes.add(i);
            }
        }
        return safeNodes;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    bool dfs(int node, vector<vector<int>>& adj, vector<bool>& visit, vector<bool>& inStack) {
        // If the node is already in the stack, we have a cycle.
        if (inStack[node]) {
            return true;
        }
        if (visit[node]) {
            return false;
        }
        // Mark the current node as visited and part of current recursion stack.
        visit[node] = true;
        inStack[node] = true;
        for (auto neighbor : adj[node]) {
            if (dfs(neighbor, adj, visit, inStack)) {
                return true;
            }
        }
        // Remove the node from the stack.
        inStack[node] = false;
        return false;
    }

    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {
        int n = graph.size();
        vector<vector<int>> adj(n);

        for (int i = 0; i < n; i++) {
            for (auto node : graph[i]) {
                adj[i].push_back(node);
            }
        }

        vector<bool> visit(n), inStack(n);

        for (int i = 0; i < n; i++) {
            dfs(i, adj, visit, inStack);
        }

        vector<int> safeNodes;
        for (int i = 0; i < n; i++) {
            if (!inStack[i]) {
                safeNodes.push_back(i);
            }
        }
        return safeNodes;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def dfs(self, node, adj, visit, inStack):
        # If the node is already in the stack, we have a cycle.
        if inStack[node]:
            return True
        if visit[node]:
            return False
        # Mark the current node as visited and part of current recursion stack.
        visit[node] = True
        inStack[node] = True
        for neighbor in adj[node]:
            if self.dfs(neighbor, adj, visit, inStack):
                return True
        # Remove the node from the stack.
        inStack[node] = False
        return False

    def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
        n = len(graph)
        adj = [[] for _ in range(n)]

        for i in range(n):
            for node in graph[i]:
                adj[i].append(node)

        visit = [False] * n
        inStack = [False] * n

        for i in range(n):
            self.dfs(i, adj, visit, inStack)

        safeNodes = []
        for i in range(n):
            if not inStack[i]:
                safeNodes.append(i)

        return safeNodes
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    is the number of nodes and <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">mm</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> is number of edges in the graph.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m+n)O(m + n)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Initializing <code>adj</code> takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time as we
                go through all the edges.
            </li>
            <li>Initializing the <code>visit</code> and <code>inStack</code> arrays take <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time each.
            </li>
            <li>The <code>dfs</code> function handles each node once, which takes <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time in
                total. From each node, we iterate over all the outgoing edges, which further takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                time to iterate over all the edges as there are a total of <code>m</code> edges.
            </li>
            <li>Iterating over all the nodes and pushing only safe nodes into <code>safeNodes</code> also takes <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">O(n)O(n)</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>The <code>adj</code> arrays takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> space.
            </li>
            <li>The <code>visit</code> and <code>inStack</code> arrays take <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space
                each.
            </li>
            <li>The recursion call stack used by <code>dfs</code> can have no more than <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.4306em;"></span><span
                    class="mord mathnormal">n</span></span></span></span></span> elements in the worst-case scenario. It
                would take up <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space in that case.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>