<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Course Schedule - Solution</title>
</head>
<body>
<h2 id="solution">Course Schedule - Solution</h2>
<hr>
<h3 id="overview">Overview</h3>
<p>We are given a total of <code>numCourses</code> courses one has to take, labeled from <code>0</code> to <code>numCourses
    - 1</code>. We are also given an array <code>prerequisites</code> where <code>prerequisites[i]</code> = [<span
        class="math math-inline"><span class="katex"><span class="katex-mathml">aia_i</span><span class="katex-html"
                                                                                                  aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span
        class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
        class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
        style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                            style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span
        class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
                                                                   style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>,
    <span class="math math-inline"><span class="katex"><span class="katex-mathml">bib_i</span><span class="katex-html"
                                                                                                    aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span
            class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span
            class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>]
    indicates that course <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">bib_i</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span
            class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
            class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>
    must be taken first if you want to take course <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">aia_i</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span
            class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
            class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>.
</p>
<p>Our task is to return a boolean indicating whether it is possible to complete all the courses or not.</p>
<hr>
<h3 id="approach-1-topological-sort-using-kahns-algorithm">Approach 1: Topological Sort Using Kahn's Algorithm</h3>
<h4 id="intuition">Intuition</h4>
<p>We can see that we have been given certain courses with some dependencies between them. The dependencies are
    expressed as pairs, which provides some hints for framing the problem in terms of a graph.</p>
<p>If we regard each course as a node and draw an edge from <span class="math math-inline"><span class="katex"><span
        class="katex-mathml">bib_i</span><span class="katex-html" aria-hidden="true"><span class="base"><span
        class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span
        class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span
        class="vlist" style="height: 0.3117em;"><span
        style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                            style="height: 2.7em;"></span><span
        class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span
        class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist"
                                                                   style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>
    to <span class="math math-inline"><span class="katex"><span class="katex-mathml">aia_i</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.5806em; vertical-align: -0.15em;"></span><span
            class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span
            class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>
    for any prerequisite [<span class="math math-inline"><span class="katex"><span
            class="katex-mathml">aia_i</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span
            class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
            class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>,
    <span class="math math-inline"><span class="katex"><span class="katex-mathml">bib_i</span><span class="katex-html"
                                                                                                    aria-hidden="true"><span
            class="base"><span class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span
            class="mord"><span class="mord mathnormal">b</span><span class="msupsub"><span
            class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>]
    (to indicate that course <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">bib_i</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.8444em; vertical-align: -0.15em;"></span><span class="mord"><span
            class="mord mathnormal">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
            class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>
    should be completed before taking course <span class="math math-inline"><span class="katex"><span
            class="katex-mathml">aia_i</span><span class="katex-html" aria-hidden="true"><span class="base"><span
            class="strut" style="height: 0.5806em; vertical-align: -0.15em;"></span><span class="mord"><span
            class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span
            class="vlist-r"><span class="vlist" style="height: 0.3117em;"><span
            style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut"
                                                                                style="height: 2.7em;"></span><span
            class="sizing reset-size6 size3 mtight"><span
            class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span
            class="vlist-r"><span class="vlist" style="height: 0.15em;"><span></span></span></span></span></span></span></span></span></span></span>),
    we get a directed graph.</p>
<p>If there is a cycle in this directed graph, it suggests that we will not be able to finish all of the courses.
    Otherwise, we can perform a <strong>topological sort</strong> of the graph to determine the order in which all of
    the courses can be finished.</p>
<p>As a result, the problem is reduced to determining whether a cycle occurs in a graph. If there is a cycle, we must
    return <code>false</code>. If not, we return <code>true</code>.</p>
<p>A topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for
    every directed edge <code>u -&gt; v</code> from vertex <code>u</code> to vertex <code>v</code>, <code>u</code> comes
    before <code>v</code> in the ordering.</p>
<p>In a directed acyclic graph, we can use Kahn's algorithm to get the topological ordering. Kahn’s algorithm works by
    keeping track of the number of incoming edges into each node (indegree). It works by repeatedly visiting the nodes
    with an indegree of zero and deleting all the edges associated with it leading to a decrement of indegree for the
    nodes whose incoming edges are deleted. This process continues until no elements with zero indegree can be
    found.</p>
<p>If you are not familiar with Kahn's algorithm, we suggest you read our <a
        href="https://leetcode.com/explore/learn/card/graph/623/kahns-algorithm-for-topological-sorting/3886/"
        target="_blank">LeetCode Explore Card</a>.</p>
<p>The advantage of using Kahn's algorithm is that it also aids in the detection of graph cycles.</p>
<p>Let's perform Kahn's algorithm on a directed graph having a cycle. Here's a visual step-by-step represenntation of
    how it would work:</p>
<p><img src="207-1.png" alt="img"></p>
<p>We can see that if there is a cycle, the indegree of nodes in the cycle cannot be set to <code>0</code> due to cyclic
    dependency. We are unable to visit the cycle's nodes. So, if the number of visited nodes is less than the total
    number of nodes in the graph, we have a cycle.</p>
<h4 id="algorithm">Algorithm</h4>
<ol>
    <li>Create an array <code>indegree</code> of length <code>n</code> where <code>indegree[x]</code> stores the number
        of edges entering node <code>x</code>.
    </li>
    <li>We create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all the nodes with an
        incoming edge from node <code>x</code>, i.e., neighbors of node <code>x</code>. We create this adjacency list by
        iterating over <code>prerequisites</code>. For every <code>prerequisite</code> in <code>prerequisites</code>, we
        add an edge from <code>prerequisite[1]</code> to <code>prerequisite[0]</code> and increment the indegree of
        <code>prerequisite[0]</code> by <code>1</code>.
    </li>
    <li>Initialize a queue of integers <code>q</code> and start a BFS algorithm moving from the leaf nodes to the parent
        nodes.
    </li>
    <li>Begin the BFS traversal by pushing all of the leaf nodes (<code>indegree</code> equal to <code>0</code>) in the
        queue.
    </li>
    <li>Create an integer variable <code>nodesVisited = 0</code> to count the number of visited nodes.</li>
    <li>While the queue is not empty;
        <ul>
            <li>Dequeue the first <code>node</code> from the queue.</li>
            <li>Increment <code>nodesVisited</code> by <code>1</code>.</li>
            <li>For each <code>neighbor</code> (nodes that have an incoming edge from <code>node</code>) of
                <code>node</code>, we decrement <code>indegree[neighbor]</code>by <code>1</code> to delete the <code>node
                    -&gt; neighbor</code> edge.
            </li>
            <li>If <code>indegree[neighbor] == 0</code>, it means that <code>neighbor</code> behaves as a leaf node, so
                we push <code>neighbor</code> in the queue.
            </li>
        </ul>
    </li>
    <li>If the number of nodes visited is less than the total number of nodes, i.e., <code>nodesVisited &lt; n</code> we
        return <code>false</code> as there must be a cycle. Otherwise, if <code>nodesVisited == numCourses</code>, we
        return <code>true</code>. We can shorten it to just return <code>nodesVisited == numCourses</code>.
    </li>
</ol>
<h4 id="implementation">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegree = new int[numCourses];
        List<List<Integer>> adj = new ArrayList<>(numCourses);

        for (int i = 0; i < numCourses; i++) {
            adj.add(new ArrayList<>());
        }

        for (int[] prerequisite : prerequisites) {
            adj.get(prerequisite[1]).add(prerequisite[0]);
            indegree[prerequisite[0]]++;
        }

        Queue<Integer> queue = new LinkedList<>();
        // Push all the nodes with indegree zero in the queue.
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                queue.offer(i);
            }
        }

        int nodesVisited = 0;
        while (!queue.isEmpty()) {
            int node = queue.poll();
            nodesVisited++;

            for (int neighbor : adj.get(node)) {
                // Delete the edge "node -> neighbor".
                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    queue.offer(neighbor);
                }
            }
        }

        return nodesVisited == numCourses;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<int> indegree(numCourses);
        vector<vector<int>> adj(numCourses);
        for (auto prerequisite : prerequisites) {
            adj[prerequisite[1]].push_back(prerequisite[0]);
            indegree[prerequisite[0]]++;
        }

        queue<int> q;
        // Push all the nodes with indegree zero in the queue.
        for (int i = 0; i < numCourses; i++) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }

        int nodesVisited = 0;
        while (!q.empty()) {
            int node = q.front();
            q.pop();
            nodesVisited++;

            for (auto& neighbor : adj[node]) {
                // Delete the edge "node -> neighbor".
                indegree[neighbor]--;
                if (indegree[neighbor] == 0) {
                    q.push(neighbor);
                }
            }
        }

        return nodesVisited == numCourses;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def canFinish(self, numCourses, prerequisites):
        indegree = [0] * numCourses
        adj = [[] for _ in range(numCourses)]

        for prerequisite in prerequisites:
            adj[prerequisite[1]].append(prerequisite[0])
            indegree[prerequisite[0]] += 1

        queue = deque()
        for i in range(numCourses):
            if indegree[i] == 0:
                queue.append(i)

        nodesVisited = 0
        while queue:
            node = queue.popleft()
            nodesVisited += 1

            for neighbor in adj[node]:
                indegree[neighbor] -= 1
                if indegree[neighbor] == 0:
                    queue.append(neighbor)

        return nodesVisited == numCourses
    </code>
</pre>
<h4 id="complexity-analysis">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    be the number of courses and <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> be the size of <code>prerequisites</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m+n)O(m + n)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Initializing the <code>adj</code> list takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time as we
                go through all the edges. The <code>indegree</code> array take <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                time.
            </li>
            <li>Each queue operation takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(1)O(1)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord">1</span><span class="mclose">)</span></span></span></span></span> time, and a single
                node will be pushed once, leading to <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                operations for <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                nodes. We iterate over the neighbors of each node that is popped out of the queue iterating over all the
                edges once. Since there are total of <code>m</code> edges, it would take <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(m)O(m)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                time to iterate over the edges.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>The <code>adj</code> arrays takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> space. The
                <code>indegree</code> array takes <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space.
            </li>
            <li>The queue can have no more than <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">nn</span><span class="katex-html" aria-hidden="true"><span class="base"><span
                    class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
                elements in the worst-case scenario. It would take up <span class="math math-inline"><span
                        class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html"
                                                                                      aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space in that case.
            </li>
        </ul>
    </li>
</ul>
<hr>
<h3 id="approach-2-depth-first-search">Approach 2: Depth First Search</h3>
<h4 id="intuition-1">Intuition</h4>
<p>We can also use a depth-first search (DFS) traversal to detect a cycle in a directed graph.</p>
<p>In DFS, we use a recursive function to explore nodes as far as possible along each branch. Upon reaching the end of a
    branch, we backtrack to the previous node and continue exploring the next branches.</p>
<p>Once we encounter an unvisited node, we will take one of its neighbor nodes (if exists) as the next node on this
    branch. Recursively call the function to take the next node as the 'starting node' and solve the subproblem.</p>
<p>A node remains in the DFS recursion stack until all of its branches (all nodes in its subtree) have not been
    explored. When we have examined all of a node's branches, i.e. visited all of the nodes in its subtree, the node is
    removed from the DFS recursive stack.</p>
<p>If you are new to Depth First Search, please see our <a
        href="https://leetcode.com/explore/featured/card/graph/619/depth-first-search-in-graph/3882/" target="_blank">Leetcode
    Explore Card</a> for more information on it!</p>
<p>If the graph has a cycle, we must have a <strong>back edge</strong> connecting a node to one of its ancestors while
    traversing nodes in the DFS manner.</p>
<p>Let's think how we can establish whether or not a node's neighbor is an ancestor when navigating from one node to
    another.</p>
<p>If the neighboring node has not yet been visited, it cannot be an ancestor (it is a child node).</p>
<p>Otherwise, if a neighboring node is visited, it may or may not be an ancestor. If the neighboring node is an
    ancestor, i.e. there is a back edge, it means that we visited this ancestor node first in the DFS traversal, then
    visited and explored some other nodes, and eventually visited a node that connects back to the ancestor node. As we
    are still exploring the ancestor node's subtree while iterating over this path, hence this node must be in the
    current DFS recursive stack.</p>
<p>However, if a neighboring node is visited but not in the recursion stack, it signifies we have previously explored
    that node in a different branch, and it does not form a cycle in the current branch.</p>
<p>As a result, to detect the cycle we must keep track of the visited nodes (like in a normal DFS) and also the nodes in
    the function's recursion call stack for DFS traversal. The nodes in the stack store the current path that we are on.
    There is a cycle in the graph if a node is reached that is already in the recursion stack. We use a boolean array of
    length <code>n</code> to track which nodes are in the call stack so we can check if a node exists in <span
            class="math math-inline"><span class="katex"><span class="katex-mathml">O(1)O(1)</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 1em; vertical-align: -0.25em;"></span><span
            class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
            class="mord">1</span><span class="mclose">)</span></span></span></span></span>.</p>
<h4 id="algorithm-1">Algorithm</h4>
<ol>
    <li>We create an adjacency list <code>adj</code> in which <code>adj[x]</code> contains all the nodes with an
        incoming edge from node <code>x</code>, i.e., neighbors of node <code>x</code>. We create this adjacency list by
        iterating over <code>prerequisites</code>. For every <code>prerequisite</code> in <code>prerequisites</code>, we
        add an edge from <code>prerequisite[1]</code> to <code>prerequisite[0]</code>.
    </li>
    <li>Create two boolean arrays, <code>visit</code> and <code>inStack</code>, each of size <code>n</code>. The <code>visit</code>
        array keeps track of visited nodes and <code>inStack</code> keeps track of nodes that are currently in the
        ongoing DFS stack. It will help us to detect a cycle in the graph.
    </li>
    <li>For each node we begin a DFS traversal. We implement the <code>dfs</code> method which takes four parameters: an
        integer <code>node</code> from which the current traversal begins, <code>adj</code>, <code>visit</code>, and
        <code>inStack</code>. It returns a boolean indicating whether there is a cycle in the graph. If any
        <code>dfs</code> call returns <code>true</code>, we have a cycle. In such a case, we return <code>false</code>
        immediately as our answer to the problem. Otherwise, if no <code>dfs</code> call from all the nodes result in a
        cycle, we return <code>true</code>. We perform the following in this method:
        <ul>
            <li>If <code>node</code> is already present in <code>inStack</code>, we have a cycle. We return
                <code>true</code>.
            </li>
            <li>If <code>node</code> is already visited, we return <code>false</code> because we already visited this
                <code>node</code> and didn't find a cycle earlier.
            </li>
            <li>We mark <code>node</code> as visited and also set <code>inStack[node] = true</code>.</li>
            <li>We iterate over all the outgoing edges of <code>node</code> and for each <code>neighbor</code>, we
                recursively call <code>dfs(neighbor, adj, visit, inStack)</code>. If we get a cycle from
                <code>neighbor</code>, we return <code>true</code>.
            </li>
            <li>After we have processed all the outgoing edges of <code>node</code>, we mark <code>inStack[node] =
                false</code> to mark <code>node</code> as out of stack. We also return <code>false</code> as we didn't
                find any cycle.
            </li>
        </ul>
    </li>
</ol>
<h4 id="implementation-1">Implementation</h4>
<pre>
    Java
    <code>
        class Solution {
    public boolean dfs(int node, List<List<Integer>> adj, boolean[] visit, boolean[] inStack) {
        // If the node is already in the stack, we have a cycle.
        if (inStack[node]) {
            return true;
        }
        if (visit[node]) {
            return false;
        }
        // Mark the current node as visited and part of current recursion stack.
        visit[node] = true;
        inStack[node] = true;
        for (int neighbor : adj.get(node)) {
            if (dfs(neighbor, adj, visit, inStack)) {
                return true;
            }
        }
        // Remove the node from the stack.
        inStack[node] = false;
        return false;
    }

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        List<List<Integer>> adj = new ArrayList<>(numCourses);
        for (int i = 0; i < numCourses; i++) {
            adj.add(new ArrayList<>());
        }

        for (int[] prerequisite : prerequisites) {
            adj.get(prerequisite[1]).add(prerequisite[0]);
        }

        boolean[] visit = new boolean[numCourses];
        boolean[] inStack = new boolean[numCourses];
        for (int i = 0; i < numCourses; i++) {
            if (dfs(i, adj, visit, inStack)) {
                return false;
            }
        }
        return true;
    }
}
    </code>
    C++
    <code>
        class Solution {
public:
    bool dfs(int node, vector<vector<int>>& adj, vector<bool>& visit, vector<bool>& inStack) {
        // If the node is already in the stack, we have a cycle.
        if (inStack[node]) {
            return true;
        }
        if (visit[node]) {
            return false;
        }
        // Mark the current node as visited and part of current recursion stack.
        visit[node] = true;
        inStack[node] = true;
        for (auto neighbor : adj[node]) {
            if (dfs(neighbor, adj, visit, inStack)) {
                return true;
            }
        }
        // Remove the node from the stack.
        inStack[node] = false;
        return false;
    }

    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        vector<vector<int>> adj(numCourses);
        for (auto prerequisite : prerequisites) {
            adj[prerequisite[1]].push_back(prerequisite[0]);
        }

        vector<bool> visit(numCourses);
        vector<bool> inStack(numCourses);
        for (int i = 0; i < numCourses; i++) {
            if (dfs(i, adj, visit, inStack)) {
                return false;
            }
        }
        return true;
    }
};
    </code>
    Python3
    <code>
        class Solution:
    def dfs(self, node, adj, visit, inStack):
        # If the node is already in the stack, we have a cycle.
        if inStack[node]:
            return True
        if visit[node]:
            return False
        # Mark the current node as visited and part of current recursion stack.
        visit[node] = True
        inStack[node] = True
        for neighbor in adj[node]:
            if self.dfs(neighbor, adj, visit, inStack):
                return True
        # Remove the node from the stack.
        inStack[node] = False
        return False

    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        adj = [[] for _ in range(numCourses)]
        for prerequisite in prerequisites:
            adj[prerequisite[1]].append(prerequisite[0])

        visit = [False] * numCourses
        inStack = [False] * numCourses
        for i in range(numCourses):
            if self.dfs(i, adj, visit, inStack):
                return False
        return True
    </code>
</pre>
<h4 id="complexity-analysis-1">Complexity Analysis</h4>
<p>Here, <span class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span class="katex-html"
                                                                                                      aria-hidden="true"><span
        class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>
    be the number of courses and <span class="math math-inline"><span class="katex"><span class="katex-mathml">mm</span><span
            class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                           style="height: 0.4306em;"></span><span
            class="mord mathnormal">m</span></span></span></span></span> be the size of <code>prerequisites</code>.</p>
<ul>
    <li>
        <p>Time complexity: <span class="math math-inline"><span class="katex"><span
                class="katex-mathml">O(m+n)O(m + n)</span><span class="katex-html" aria-hidden="true"><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>Initializing <code>adj</code> takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> time as we
                go through all the edges.
            </li>
            <li>Initializing the <code>visit</code> and <code>inStack</code> arrays take <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time each.
            </li>
            <li>The <code>dfs</code> function handles each node once, which takes <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> time in
                total. From each node, we iterate over all the outgoing edges, which further takes <span
                        class="math math-inline"><span class="katex"><span class="katex-mathml">O(m)O(m)</span><span
                        class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                       style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span>
                time to iterate over all the edges as there are a total of <code>m</code> edges.
            </li>
        </ul>
    </li>
    <li>
        <p>Space complexity: <span class="math math-inline"><span class="katex"><span class="katex-mathml">O(m+n)O(m + n)</span><span
                class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                               style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                class="mord mathnormal">m</span><span class="mspace" style="margin-right: 0.2222em;"></span><span
                class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span
                class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span></p>
        <ul>
            <li>The <code>adj</code> arrays takes <span class="math math-inline"><span class="katex"><span
                    class="katex-mathml">O(m)O(m)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span></span> space.
            </li>
            <li>The <code>visit</code> and <code>inStack</code> arrays take <span class="math math-inline"><span
                    class="katex"><span class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                    class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                    class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span class="mopen">(</span><span
                    class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span> space
                each.
            </li>
            <li>The recursion call stack used by <code>dfs</code> can have no more than <span
                    class="math math-inline"><span class="katex"><span class="katex-mathml">nn</span><span
                    class="katex-html" aria-hidden="true"><span class="base"><span class="strut"
                                                                                   style="height: 0.4306em;"></span><span
                    class="mord mathnormal">n</span></span></span></span></span> elements in the worst-case scenario. It
                would take up <span class="math math-inline"><span class="katex"><span
                        class="katex-mathml">O(n)O(n)</span><span class="katex-html" aria-hidden="true"><span
                        class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span
                        class="mord mathnormal" style="margin-right: 0.02778em;">O</span><span
                        class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></span>
                space in that case.
            </li>
        </ul>
    </li>
</ul>
</body>
</html>